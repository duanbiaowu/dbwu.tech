<!doctype html>

<html lang="en">

<head>
  <title>Kubernetes HPA 设计与实现 - 蛮荆</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="" />
<meta name="author" content="" />
<link rel="shortcut icon" href="https://dbwu.tech/favicon.ico" type="image/x-icon" /><meta property="og:title" content="Kubernetes HPA 设计与实现" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dbwu.tech/posts/k8s/source_code/hpa_controller/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-31T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-12-31T00:00:00+00:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kubernetes HPA 设计与实现"/>
<meta name="twitter:description" content=""/>

<meta name="generator" content="Hugo 0.120.3">
    
    <script src="https://dbwu.tech/js/mathjax-config.js" defer></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CZMGTTFLNY"></script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3261056100776781" crossorigin="anonymous"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-CZMGTTFLNY');
  </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>


  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/normalize.min.css" />
  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/all.min.css" />
  
    
    <link href="//fonts.googleapis.com/css?family=Staatliches" rel="stylesheet">
  
  
  <link rel="stylesheet" type="text/css" href="https://dbwu.tech/css/styles-light.css" />
  </head>

<body>
  <div id="container">
    <header>
      
      <h1>
        <a href="https://dbwu.tech/">蛮荆</a>
      </h1>

      <ul id="social-media">
      </ul>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="active" href="https://dbwu.tech/posts/">
                <i class="fa-li fa  fa-lg"></i><span>归档</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/tags/">
                <i class="fa-li fa  fa-lg"></i><span>标签</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://github.com/duanbiaowu">
                <i class="fa-li fa  fa-lg"></i><span>Github</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/index.xml">
                <i class="fa-li fa  fa-lg"></i><span>RSS</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<article>

    <h1>Kubernetes HPA 设计与实现</h1>

    
      
<p>
    <span>2023-12-31</span>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/cloud-native">Cloud Native</a>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/kubernetes">Kubernetes</a>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/%E8%AF%BB%E4%BB%A3%E7%A0%81">读代码</a>
    
</p>

    

    
      

    

    <h2 id="概述">概述</h2>
<blockquote>
<p>水平自动伸缩 (Horizontal Pod AutoScale) 简称 HPA, 目标是自动伸缩 Pod 的副本数量来满足应用服务负载。</p>
</blockquote>
<p><img src="https://dbwu.tech/images/k8s/source_code/hpa_2.png" alt="HPA"></p>
<p>HPA 的使用方法和最佳实践在 <a href="https://dbwu.tech/posts/k8s/best_practice/hpa/">这篇文章</a> 中已经介绍过了，本文不再赘述，本文着重从源代码的角度分析一下 HPA 的实现原理。</p>
<p>HPA 功能对应的源代码位于 Kubernetes 项目的 <code>pkg/controller/podautoscaler/</code> 目录，本文以 Kubernetes <code>v1.28</code> 版本源代码进行分析。</p>
<p><img src="https://dbwu.tech/images/k8s/source_code/hpa_1.png" alt="HPA 源代码目录"></p>
<hr>
<h2 id="流程图">流程图</h2>
<p><img src="https://dbwu.tech/images/k8s/source_code/hpa_flow.png" alt="HPA 控制器执行流程图"></p>
<p>下面我们跟着流程图一起看下源代码的具体实现。</p>
<h2 id="horizontalcontroller">HorizontalController</h2>
<p>首先来看看 <code>HorizontalController</code> 控制器对象，该对象是实现 HPA 功能的核心对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// HorizontalController 控制器负责将 Pod 的状态调整到对应的 HPA 期望状态
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">type</span> HorizontalController <span style="color:#6ab825;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// HPA 配置对象列表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	hpaLister       autoscalinglisters.HorizontalPodAutoscalerLister
</span></span><span style="display:flex;"><span>	hpaListerSynced cache.InformerSynced
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// Pod 列表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	podLister       corelisters.PodLister
</span></span><span style="display:flex;"><span>	podListerSynced cache.InformerSynced
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// HPA 对象延迟队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">//    如何理解这个延迟队列？
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">//    本质上就是内部除了队列数据结构外，还有一个专门的根据时间排序的 {最小堆} 数据结构
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">//    然后启动一个专门的 goroutine, 监听到期的对象并直接放入队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 队列中存储发生了变化的控制器
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	queue workqueue.RateLimitingInterface
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="配置信息">配置信息</h2>
<p><code>HPAControllerConfiguration</code> 对象表示 <code>HorizontalController</code> 控制器的配置对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">type</span> HPAControllerConfiguration <span style="color:#6ab825;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>RecommendedDefaultHPAControllerConfiguration</code> 方法用于设置配置对象的默认值。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">RecommendedDefaultHPAControllerConfiguration</span>(obj *kubectrlmgrconfigv1alpha1.HPAControllerConfiguration) {
</span></span><span style="display:flex;"><span>	zero := metav1.Duration{}
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 用于并发处理 HPA 逻辑的 goroutine 数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 默认为 5 个
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> obj.ConcurrentHorizontalPodAutoscalerSyncs == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		obj.ConcurrentHorizontalPodAutoscalerSyncs = <span style="color:#3677a9">5</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 控制器队列 - 延迟入队时间
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 默认为 15 秒
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> obj.HorizontalPodAutoscalerSyncPeriod == zero {
</span></span><span style="display:flex;"><span>		obj.HorizontalPodAutoscalerSyncPeriod = metav1.Duration{Duration: <span style="color:#3677a9">15</span> * time.Second}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 两次扩容的间隔时间
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 默认为 3 分钟
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> obj.HorizontalPodAutoscalerUpscaleForbiddenWindow == zero {
</span></span><span style="display:flex;"><span>		obj.HorizontalPodAutoscalerUpscaleForbiddenWindow = metav1.Duration{Duration: <span style="color:#3677a9">3</span> * time.Minute}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 两次缩容的间隔时间
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// 默认为 5 分钟
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> obj.HorizontalPodAutoscalerDownscaleStabilizationWindow == zero {
</span></span><span style="display:flex;"><span>		obj.HorizontalPodAutoscalerDownscaleStabilizationWindow = metav1.Duration{Duration: <span style="color:#3677a9">5</span> * time.Minute}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="初始化">初始化</h3>
<p><code>NewHorizontalController</code> 方法用于 <code>HorizontalController</code> 控制器对象的初始化工作，并返回一个实例化对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">NewHorizontalController</span>(...) *HorizontalController {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	hpaController := &amp;HorizontalController{
</span></span><span style="display:flex;"><span>		queue: workqueue.<span style="color:#447fcf">NewNamedRateLimitingQueue</span>(<span style="color:#447fcf">NewDefaultHPARateLimiter</span>(resyncPeriod), <span style="color:#ed9d13">&#34;horizontalpodautoscaler&#34;</span>),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 增加 informer 监听事件
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	hpaInformer.<span style="color:#447fcf">Informer</span>().<span style="color:#447fcf">AddEventHandlerWithResyncPeriod</span>(
</span></span><span style="display:flex;"><span>		cache.ResourceEventHandlerFuncs{
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 新增 HPA 回调方法
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			AddFunc:    hpaController.enqueueHPA,
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 修改 HPA 回调方法
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			UpdateFunc: hpaController.updateHPA,
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 删除 HPA 回调方法
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			DeleteFunc: hpaController.deleteHPA,
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 监听事件的定时周期
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		resyncPeriod,
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 创建一个新的副本计算器
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 这样就可以计算出 Pod 的目标数量，然后在此基础上扩容或者缩容
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	replicaCalc := <span style="color:#447fcf">NewReplicaCalculator</span>(
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>	hpaController.replicaCalc = replicaCalc
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> hpaController
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="注册事件通知">注册事件通知</h2>
<p>初始化 <code>HorizontalController</code> 控制器对象时会注册 informer 监听事件，后续当对应的事件被触发时，就会执行的对应的事件回调方法。</p>
<h3 id="新增-hpa-回调">新增 HPA 回调</h3>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (a *HorizontalController) <span style="color:#447fcf">enqueueHPA</span>(obj <span style="color:#6ab825;font-weight:bold">interface</span>{}) {
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="修改-hpa-回调">修改 HPA 回调</h3>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (a *HorizontalController) <span style="color:#447fcf">updateHPA</span>(old, cur <span style="color:#6ab825;font-weight:bold">interface</span>{}) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="删除-hpa-回调">删除 HPA 回调</h3>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (a *HorizontalController) <span style="color:#447fcf">deleteHPA</span>(obj <span style="color:#6ab825;font-weight:bold">interface</span>{}) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="启动-hpa">启动 HPA</h2>
<p><code>NewHorizontalController</code> 方法返回对象示例之后，立即调用对象的 <code>Run</code> 方法开始运行自动伸缩的逻辑。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// cmd/kube-controller-manager/app/autoscaling.go
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">startHPAControllerWithMetricsClient</span>(ctx context.Context, ...) (controller.Interface, <span style="color:#6ab825;font-weight:bold">bool</span>, <span style="color:#6ab825;font-weight:bold">error</span>) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 启动一个独立的 goroutine 来完成 {初始化 &amp;&amp; 运行}
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">go</span> podautoscaler.<span style="color:#447fcf">NewHorizontalController</span>(
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>	).<span style="color:#447fcf">Run</span>(ctx, <span style="color:#24909d">int</span>(controllerContext.ComponentConfig.HPAController.ConcurrentHorizontalPodAutoscalerSyncs))
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>HorizontalController.Run</code> 方法执行具体的自动伸缩操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (a *HorizontalController) <span style="color:#447fcf">Run</span>(ctx context.Context, workers <span style="color:#6ab825;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// (根据配置) 启动多个 goroutine 处理逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#3677a9">0</span>; i &lt; workers; i++ {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">go</span> wait.<span style="color:#447fcf">UntilWithContext</span>(ctx, a.worker, time.Second)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>HorizontalController.worker</code> 方法本质上就是一个无限循环轮询器，通过定时检测所有资源使用率，并进行对应的扩容｜缩容操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (a *HorizontalController) <span style="color:#447fcf">worker</span>(ctx context.Context) {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> a.<span style="color:#447fcf">processNextWorkItem</span>(ctx) {
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (a *HorizontalController) <span style="color:#447fcf">processNextWorkItem</span>(ctx context.Context) <span style="color:#6ab825;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 从队列中取出一个 HPA 对象
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	key, quit := a.queue.<span style="color:#447fcf">Get</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 实现扩容｜缩容
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 这里调用了 reconcileKey 方法
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	deleted, err := a.<span style="color:#447fcf">reconcileKey</span>(ctx, key.(<span style="color:#6ab825;font-weight:bold">string</span>))
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// HPA 对象再次放入队列，方便后续可以持续检测
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> !deleted {
</span></span><span style="display:flex;"><span>		a.queue.<span style="color:#447fcf">AddRateLimited</span>(key)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>HorizontalController.reconcileKey</code> 方法，最后返回参数对应的 HPA 对象是否已经被删除。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (a *HorizontalController) <span style="color:#447fcf">reconcileKey</span>(ctx context.Context, key <span style="color:#6ab825;font-weight:bold">string</span>) (deleted <span style="color:#6ab825;font-weight:bold">bool</span>, err <span style="color:#6ab825;font-weight:bold">error</span>) {
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	hpa, err := a.hpaLister.<span style="color:#447fcf">HorizontalPodAutoscalers</span>(namespace).<span style="color:#447fcf">Get</span>(name)
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> k8serrors.<span style="color:#447fcf">IsNotFound</span>(err) {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 如果参数对应的 HPA 对象已经被删除了，返回 true
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">true</span>, <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 接下来，就可以进入扩容｜缩容的主要逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>, a.<span style="color:#447fcf">reconcileAutoscaler</span>(ctx, hpa, key)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="计算副本数量">计算副本数量</h2>
<p><code>HorizontalController.reconcileAutoscaler</code> 方法会根据当前副本数量和 HPA 对象中定义的期望副本数量计算出调整后的数量，并进行对应的扩容｜缩容操作，
<strong>这是 HPA 中的核心方法</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (a *HorizontalController) <span style="color:#447fcf">reconcileAutoscaler</span>(ctx context.Context, ...) (...) {
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 初始化本次期望副本数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	desiredReplicas := <span style="color:#24909d">int32</span>(<span style="color:#3677a9">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 初始化最小副本数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">var</span> minReplicas <span style="color:#6ab825;font-weight:bold">int32</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> hpa.Spec.MinReplicas != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		minReplicas = *hpa.Spec.MinReplicas
</span></span><span style="display:flex;"><span>	} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>		minReplicas = <span style="color:#3677a9">1</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 是否需要扩容｜缩容
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	rescale := <span style="color:#6ab825;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 如果当前副本数量为 0，关闭自动扩容
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> currentReplicas == <span style="color:#3677a9">0</span> &amp;&amp; minReplicas != <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		desiredReplicas = <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>		rescale = <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>	} <span style="color:#6ab825;font-weight:bold">else</span> <span style="color:#6ab825;font-weight:bold">if</span> currentReplicas &gt; hpa.Spec.MaxReplicas {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 如果当前副本数量 大于 HPA 配置的副本最大数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 设置本次期望副本数量为 HPA 配置的副本最大数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		desiredReplicas = hpa.Spec.MaxReplicas
</span></span><span style="display:flex;"><span>	} <span style="color:#6ab825;font-weight:bold">else</span> <span style="color:#6ab825;font-weight:bold">if</span> currentReplicas &lt; minReplicas {
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 如果当前副本数量 小于 HPA 配置的副本最小数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        <span style="color:#999;font-style:italic">// 设置本次期望副本数量为 HPA 配置的副本最小数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		desiredReplicas = minReplicas
</span></span><span style="display:flex;"><span>	} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 如果当前副本数量位于 {HPA 配置的副本最小数量 -&gt; 最大数量} 区间内
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 根据 metric 计算期望的副本数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		metricDesiredReplicas, ... = a.<span style="color:#447fcf">computeReplicasForMetrics</span>(ctx, ...)
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 根据计算出来的期望副本数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 再次对本次期望副本数量进行调整
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		rescaleMetric := <span style="color:#ed9d13">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> metricDesiredReplicas &gt; desiredReplicas {
</span></span><span style="display:flex;"><span>			desiredReplicas = metricDesiredReplicas
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> hpa.Spec.Behavior == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			desiredReplicas = a.<span style="color:#447fcf">normalizeDesiredReplicas</span>(hpa, key, currentReplicas, desiredReplicas, minReplicas)
</span></span><span style="display:flex;"><span>		} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>			desiredReplicas = a.<span style="color:#447fcf">normalizeDesiredReplicasWithBehaviors</span>(hpa, key, currentReplicas, desiredReplicas, minReplicas)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 如果当前副本数量不等于期望副本数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 标记本次需要扩容｜缩容
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		rescale = desiredReplicas != currentReplicas
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 如果本次需要执行扩容｜缩容操作
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> rescale {
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 执行扩容｜缩容操作
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 向 API Server 发送扩容｜缩容请求
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		_, err = a.scaleNamespacer.<span style="color:#447fcf">Scales</span>(hpa.Namespace).<span style="color:#447fcf">Update</span>(ctx, ...)
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="根据-metric-计算期望的副本数量">根据 metric 计算期望的副本数量</h2>
<p><code>HorizontalController.computeReplicasForMetrics</code> 方法会根据 HPA 配置对象中的所有 metric 计算出需要的副本数量，
方法内部会遍历 HPA 配置对象的所有 metric, 然后以多个 metric 中的最大值为准，例如根据 CPU metric 计算出来的副本数量是 10 个，
根据内存 metric 计算出来的副本数量是 15 个，则最终返回的副本数量为 15 个。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (a *HorizontalController) <span style="color:#447fcf">computeReplicasForMetrics</span>(ctx context.Context, ...) (...) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 遍历 HAP 配置对象中的 metric (例如 CPU, 内存 等)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> i, metricSpec := <span style="color:#6ab825;font-weight:bold">range</span> metricSpecs {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 通过当前 metric 计算需要的副本数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		replicaCountProposal, ..., err := a.<span style="color:#447fcf">computeReplicasForMetric</span>(ctx, ...)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 如果通过当前 metric 计算出来的副本数量 大于 已有的副本数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 就以大的副本数量为准
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> replicas == <span style="color:#3677a9">0</span> || replicaCountProposal &gt; replicas {
</span></span><span style="display:flex;"><span>			replicas = replicaCountProposal
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> replicas, ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>HorizontalController.computeReplicasForMetric</code> 方法会根据单个 metric 计算出需要的副本数量。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (a *HorizontalController) <span style="color:#447fcf">computeReplicasForMetric</span>(ctx context.Context, ...) (...) {
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 根据不同的 metric 类型执行不同的计算方式
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">switch</span> spec.Type {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">case</span> autoscalingv2.ObjectMetricSourceType:
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 根据 Kubernetes 对象 metric 进行计算
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		...
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">case</span> autoscalingv2.PodsMetricSourceType:
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 根据 Pod metric 进行计算
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        ...
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">case</span> autoscalingv2.ResourceMetricSourceType:
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 根据 Pod 资源 metric 进行计算
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 例如 CPU, 内存使用量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        ...
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">case</span> autoscalingv2.ContainerResourceMetricSourceType:
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 根据 Pod 内容器资源 metric 进行计算
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 例如容器的 CPU, 内存使用量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">case</span> autoscalingv2.ExternalMetricSourceType:
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 根据外部 metric 进行计算
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">default</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 无效的 metric 类型
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        ...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> replicaCountProposal, ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="根据-pod-资源-metric-计算副本数量">根据 Pod 资源 metric 计算副本数量</h2>
<p><code>HorizontalController.computeStatusForResourceMetric</code> 方法会根据 Pod 当前的资源使用量 (例如 CPU, 内存) 计算出需要的副本数量。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (a *HorizontalController) <span style="color:#447fcf">computeStatusForResourceMetric</span>(ctx context.Context, ...) (...) {
</span></span><span style="display:flex;"><span>	replicaCountProposal, ... := a.<span style="color:#447fcf">computeStatusForResourceMetricGeneric</span>(ctx, ...)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> replicaCountProposal, ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>HorizontalController.computeStatusForResourceMetricGeneric</code> 方法会根据当前副本数量和期望副本数量计算出一个合适的目标副本数量，
其内部最终调用的是 <code>ReplicaCalculator.GetResourceReplicas</code> 方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (a *HorizontalController) <span style="color:#447fcf">computeStatusForResourceMetricGeneric</span>(ctx context.Context, ...) (...) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	replicaCountProposal, ... := a.replicaCalc.<span style="color:#447fcf">GetResourceReplicas</span>(ctx, ...)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> replicaCountProposal, ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (c *ReplicaCalculator) <span style="color:#447fcf">GetResourceReplicas</span>(ctx context.Context, ...) (...) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 获取与指定选择器匹配的所有 Pod 的 metric 数据 
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	metrics, ... := c.metricsClient.<span style="color:#447fcf">GetResourceMetric</span>(ctx, ...)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 获取 Pod 列表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	podList, err := c.podLister.<span style="color:#447fcf">Pods</span>(namespace).<span style="color:#447fcf">List</span>(selector)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 将 Pod 列表进行分组为 
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// [就绪列表，未就绪列表，未设置 metric 的列表，标记为删除的列表]
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	readyPodCount, unreadyPods, missingPods, ignoredPods := <span style="color:#447fcf">groupPods</span>(podList, ...)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 清除 {标记为删除的} Pod
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">removeMetricsForPods</span>(metrics, ignoredPods)
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 清除未就绪的 Pod
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">removeMetricsForPods</span>(metrics, unreadyPods)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 获取每个 Pod 的资源请求配置信息
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	requests, err := <span style="color:#447fcf">calculatePodRequests</span>(podList, container, resource)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 获取 metric 对应的资源利用率
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	usageRatio, ... := metricsclient.<span style="color:#447fcf">GetResourceUtilizationRatio</span>(metrics, ...)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 扩容时是否需要考虑未就绪 Pod 的数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	scaleUpWithUnready := <span style="color:#24909d">len</span>(unreadyPods) &gt; <span style="color:#3677a9">0</span> &amp;&amp; usageRatio &gt; <span style="color:#3677a9">1.0</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 如果没有未就绪的 Pod 列表并且 metric 资源的利用率没有超过负载 (1)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">//   并且
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 不存在未设置 metric 的 Pod
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 那么就可以直接计算目标副本数量了
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> !scaleUpWithUnready &amp;&amp; <span style="color:#24909d">len</span>(missingPods) == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// Pod 目标副本数量 = ceil(metric 资源利用率 * 已就绪 Pod 数量)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 举几个例子:
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">//   1. 扩容: 当前已就绪 Pod 数量为 10, 资源利用率为 1.5, Pod 目标副本数量 = 15
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">//   2. 缩容: 当前已就绪 Pod 数量为 10, 资源利用率为 0.8, Pod 目标副本数量 = 8
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">//   3. 不变: 当前已就绪 Pod 数量为 10, 资源利用率为 1, Pod 目标副本数量 = 10
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#24909d">int32</span>(math.<span style="color:#447fcf">Ceil</span>(usageRatio * <span style="color:#24909d">float64</span>(readyPodCount))), ...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 如果存在未设置 metric 的 Pod
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#24909d">len</span>(missingPods) &gt; <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 如果资源利用率没有达到 1 (负载不严重)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> usageRatio &lt; <span style="color:#3677a9">1.0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 缩容模式
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 直接假设 Pod 的 metric 资源利用为 100%
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 如果资源利用目标高于 100%，就以目标利用为准
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			fallbackUtilization := <span style="color:#24909d">int64</span>(<span style="color:#24909d">max</span>(<span style="color:#3677a9">100</span>, targetUtilization))
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">for</span> podName := <span style="color:#6ab825;font-weight:bold">range</span> missingPods {
</span></span><span style="display:flex;"><span>				metrics[podName] = metricsclient.PodMetric{Value: requests[podName] * fallbackUtilization / <span style="color:#3677a9">100</span>}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		} <span style="color:#6ab825;font-weight:bold">else</span> <span style="color:#6ab825;font-weight:bold">if</span> usageRatio &gt; <span style="color:#3677a9">1.0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 扩容模式
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 直接假设 Pod 的 metric 资源利用为 0%
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#6ab825;font-weight:bold">for</span> podName := <span style="color:#6ab825;font-weight:bold">range</span> missingPods {
</span></span><span style="display:flex;"><span>				metrics[podName] = metricsclient.PodMetric{Value: <span style="color:#3677a9">0</span>}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 如果扩容时是否需要考虑未就绪 Pod 的数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> scaleUpWithUnready {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 直接将未就绪的 Pod 的 metric 资源利用为 0%
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">for</span> podName := <span style="color:#6ab825;font-weight:bold">range</span> unreadyPods {
</span></span><span style="display:flex;"><span>			metrics[podName] = metricsclient.PodMetric{Value: <span style="color:#3677a9">0</span>}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 因为上面更新了一些 Pod 的 metric
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 所以这里需要重新计算一下资源利用率
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	newUsageRatio, ... := metricsclient.<span style="color:#447fcf">GetResourceUtilizationRatio</span>(metrics, ...)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> math.<span style="color:#447fcf">Abs</span>(<span style="color:#3677a9">1.0</span>-newUsageRatio) &lt;= c.tolerance || (usageRatio &lt; <span style="color:#3677a9">1.0</span> &amp;&amp; newUsageRatio &gt; <span style="color:#3677a9">1.0</span>) || (usageRatio &gt; <span style="color:#3677a9">1.0</span> &amp;&amp; newUsageRatio &lt; <span style="color:#3677a9">1.0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 如果重新计算后的资源利用率不高
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">//   或者
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 重新计算后的资源利用率会引起逆向伸缩操作 (扩容 -&gt; 缩容，缩容 -&gt; 扩容)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        <span style="color:#999;font-style:italic">// 那么直接返回当前副本数量即可
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">return</span> currentReplicas, ...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// Pod 目标副本数量 = ceil(metric 资源利用率 * metric 个数)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	newReplicas := <span style="color:#24909d">int32</span>(math.<span style="color:#447fcf">Ceil</span>(newUsageRatio * <span style="color:#24909d">float64</span>(<span style="color:#24909d">len</span>(metrics))))
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> (newUsageRatio &lt; <span style="color:#3677a9">1.0</span> &amp;&amp; newReplicas &gt; currentReplicas) || (newUsageRatio &gt; <span style="color:#3677a9">1.0</span> &amp;&amp; newReplicas &lt; currentReplicas) {
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 如果重新计算后的资源利用率不高
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        <span style="color:#999;font-style:italic">//   或者
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        <span style="color:#999;font-style:italic">// 重新计算后的资源利用率会引起逆向伸缩操作 (扩容 -&gt; 缩容，缩容 -&gt; 扩容)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        <span style="color:#999;font-style:italic">// 那么直接返回当前副本数量即可
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">return</span> currentReplicas, ...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> newReplicas, ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="计算资源利用率">计算资源利用率</h2>
<p>在 <code>ReplicaCalculator.GetResourceReplicas</code> 方法内部，调用了两次 <code>GetResourceUtilizationRatio</code> 方法来获取 metric 的资源使用率。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">GetResourceUtilizationRatio</span>(metrics PodMetricsInfo, ...) (...) {
</span></span><span style="display:flex;"><span>	metricsTotal := <span style="color:#24909d">int64</span>(<span style="color:#3677a9">0</span>)
</span></span><span style="display:flex;"><span>	requestsTotal := <span style="color:#24909d">int64</span>(<span style="color:#3677a9">0</span>)
</span></span><span style="display:flex;"><span>	numEntries := <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 计算所有 Pod 的 metric 总值和 request 总值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> podName, metric := <span style="color:#6ab825;font-weight:bold">range</span> metrics {
</span></span><span style="display:flex;"><span>		request, hasRequest := requests[podName]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		metricsTotal += metric.Value
</span></span><span style="display:flex;"><span>		requestsTotal += request
</span></span><span style="display:flex;"><span>		numEntries++
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 计算资源利用率
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 资源利用率 = metric 总值 * 100 / request 总值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">//   例如 内存 request 为 1 GB, 但是 metric (实际使用量) 为 4 GB, 那么资源使用率 = 200%
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	currentUtilization = <span style="color:#24909d">int32</span>((metricsTotal * <span style="color:#3677a9">100</span>) / requestsTotal)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="后续操作">后续操作</h2>
<p>计算出目标副本数量后，<code>HPA 控制器</code> 会向 <code>API Server</code> 发送关联 <code>Deployment</code> 对应的扩容｜缩容操作请求，然后 <code>Deployment</code> 控制器会通过接收 informer 监听事件，
触发执行对应的操作。篇幅所限，这部分源代码内容本文不做分析，感兴趣的读者可以参考 <a href="https://dbwu.tech/posts/k8s/source_code/deployment_controller/">Deployment实现原理</a>。</p>
<hr>
<h2 id="小结">小结</h2>
<p>自动伸缩过程中，Pod 的期望 (目标) 副本数量的计算公式为:</p>
<blockquote>
<p>Pod 期望副本数 = ceil[Pod 当前副本数 * (当前指标 / 期望指标)]</p>
</blockquote>
<p>假设使用 CPU 使用量作为自动伸缩的度量指标，如果当前 CPU 的使用量指标为 200m, 期望指标为 100m, 当前副本数量为 5，则副本数量等于:</p>
<blockquote>
<p>ceil [5 * (200m / 100m)] = 10</p>
</blockquote>
<p>如果当前 CPU 的使用量指标为 50m, 期望指标为 100m, 当前副本数量为 10，则副本数量等于:</p>
<blockquote>
<p>ceil [10 * (50m / 100m)] = 5</p>
</blockquote>
<h3 id="源代码计算公式">源代码计算公式</h3>
<p>根据前文中的源代码分析可以看到，Kubernetes 将上述公式分为两步计算，第一步先调用 <code>GetResourceUtilizationRatio</code> 方法计算出资源利用率 <code>usageRatio</code>;</p>
<blockquote>
<p>资源利用率 = 当前指标 / 期望指标</p>
</blockquote>
<p>然后第二步根据资源利用率求出 Pod 的期望副本数量。</p>
<blockquote>
<p>Pod 期望副本数 = ceil[Pod 当前副本数 * 资源利用率]</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">if</span> !scaleUpWithUnready &amp;&amp; <span style="color:#24909d">len</span>(missingPods) == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 1. 计算出资源利用率
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 2. 计算 Pod 期望副本数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#24909d">int32</span>(math.<span style="color:#447fcf">Ceil</span>(usageRatio * <span style="color:#24909d">float64</span>(readyPodCount))), ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="hpa-控制器执行流程图">HPA 控制器执行流程图</h3>
<p><img src="https://dbwu.tech/images/k8s/source_code/hpa_flow.png" alt="HPA 控制器执行流程图"></p>
<h2 id="扩展阅读">扩展阅读</h2>
<ul>
<li><a href="https://github.com/kubernetes/autoscaler">kubernetes/autoscaler</a></li>
</ul>


</article>

<article>
    <img src="https://dbwu.tech/images/wechat.png">
</article>

<article>
    <h3>转载申请</h3>

    <p>
        本作品采用 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> 进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，商业转载请联系作者获得授权。
    </p>
</article>

<section class="post-nav">
    <ul>
        <li>
        
            <a href="https://dbwu.tech/posts/k8s/source_code/deployment_controller/"><i class="fa fa-chevron-circle-left"></i> Kubernetes Deployment 滚动更新实现原理</a>
        
        </li>
        <li>
        
            <a href="https://dbwu.tech/posts/k8s/source_code/job_controller/">Kubernetes Job 设计与实现 <i class="fa fa-chevron-circle-right"></i> </a>
        
        </li>
    </ul>
</section>
  
    
    
  


<script src="https://giscus.app/client.js"
        data-repo="duanbiaowu/dbwu.tech"
        data-repo-id="R_kgDOIkkjjw"
        data-category="Announcements"
        data-category-id="DIC_kwDOIkkjj84CV78j"
        data-mapping="specific"
        data-term="Kubernetes HPA 设计与实现"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous" async>
</script>




</main>
    <footer>
        <ul>
            <li>
                <h6><a href="mailto:codean.net@gmail.com">codean.net@gmail.com</a> | 
                    <img src="https://dbwu.tech/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" />
                    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61011302001681" target="_blank">陕公网安备 61011302001681 号</a> |
                    <a href="https://beian.miit.gov.cn" target="_blank">陕ICP备2023004378号-1</a> |
                    Rendered by <a href="https://themes.gohugo.io" title="Hugo" target="_blank">Hugo</a>
                </h6>
            </li>
            
            
        </ul>
    </footer>
</div>
<script src="https://dbwu.tech/js/scripts.js"></script>


</body>

</html>

