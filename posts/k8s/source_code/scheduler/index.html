<!doctype html>

<html lang="en">

<head>
  <title>Kubernetes 调度器 - 核心流程 - 蛮荆</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="" />
<meta name="author" content="" />
<link rel="shortcut icon" href="https://dbwu.tech/favicon.ico" type="image/x-icon" /><meta property="og:title" content="Kubernetes 调度器 - 核心流程" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dbwu.tech/posts/k8s/source_code/scheduler/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-20T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-01-20T00:00:00+00:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kubernetes 调度器 - 核心流程"/>
<meta name="twitter:description" content=""/>

<meta name="generator" content="Hugo 0.120.3">
    
    <script src="https://dbwu.tech/js/mathjax-config.js" defer></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CZMGTTFLNY"></script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3261056100776781" crossorigin="anonymous"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-CZMGTTFLNY');
  </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>


  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/normalize.min.css" />
  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/all.min.css" />
  
    
    <link href="//fonts.googleapis.com/css?family=Staatliches" rel="stylesheet">
  
  
  <link rel="stylesheet" type="text/css" href="https://dbwu.tech/css/styles-light.css" />
  </head>

<body>
  <div id="container">
    <header>
      
      <h1>
        <a href="https://dbwu.tech/">蛮荆</a>
      </h1>

      <ul id="social-media">
      </ul>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="active" href="https://dbwu.tech/posts/">
                <i class="fa-li fa  fa-lg"></i><span>归档</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/tags/">
                <i class="fa-li fa  fa-lg"></i><span>标签</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://github.com/duanbiaowu">
                <i class="fa-li fa  fa-lg"></i><span>Github</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/index.xml">
                <i class="fa-li fa  fa-lg"></i><span>RSS</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<article>

    <h1>Kubernetes 调度器 - 核心流程</h1>

    
      
<p>
    <span>2024-01-20</span>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/cloud-native">Cloud Native</a>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/kubernetes">Kubernetes</a>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/%E8%AF%BB%E4%BB%A3%E7%A0%81">读代码</a>
    
</p>

    

    
      

    

    <h2 id="概述">概述</h2>
<p>在 Kubernetes 中，调度过程 是指将 Pod 绑定到合适的 Node (节点) 上，以便对应 Node 上的 Kubelet 能够运行这些 Pod，而实现调度过程的就是本文的主角 - <strong>调度器</strong>。</p>
<blockquote>
<p>调度器通过 Kubernetes 的监测（Watch）机制来发现集群中新创建且尚未被调度的 Pod，然后为每一个 Pod 选择一个适合运行的 Node 进行绑定和运行。</p>
</blockquote>
<p><strong>调度时需要考虑的因素包括</strong>：单独和整体的资源请求、硬件/软件/策略限制、亲和以及反亲和要求、数据局部性、负载间的干扰等等。</p>
<p><strong>需要注意的是</strong>: 调度器本身并不会直接和 Node 节点进行交互去运行指定的 Pod, 根据 Kubernetes 的声明式语义哲学，调度器只需要通过 API Server 更新 Pod 的定义，
然后由 API Server 向 Node (kubelet) 发送请求，当目标 Node 上的 kubelet 发现有 Pod 调度到本节点时，它就会创建并运行指定 Pod 的容器。</p>
<h2 id="源码说明">源码说明</h2>
<p>本文着重从源代码的角度分析一下 <strong>调度器</strong> 的实现原理，默认的调度器功能对应的源代码位于 Kubernetes 项目的 <code>cmd/kube-scheduler</code> 目录，本文以 Kubernetes <code>v1.28</code> 版本源代码进行分析。</p>
<p><img src="https://dbwu.tech/images/k8s/source_code/scheduler_1.png" alt="Scheduler 源代码目录"></p>
<h3 id="核心流程">核心流程</h3>
<p>Kubernetes 中的调度过程主要分为两个大的步骤:</p>
<ol>
<li><strong>调度周期</strong>: 调度器从多个候选的 Nodes 中 (执行各种过滤操作) 为 Pod 选择一个最适合的</li>
<li><strong>绑定周期</strong>: 绑定 Pod 和 Node</li>
</ol>
<h3 id="过滤节点">过滤节点</h3>
<p>调度过程中会使用 [插件 + 扩展点] 来实现过滤机制，以此来决定哪些 Node 对 Pod 是可用的，例如常见的过滤条件有:</p>
<ul>
<li>Node 是否满足 Pod 的资源请求</li>
<li>Node 是否负载过重</li>
<li>Pod 是否指定了 Node 名称</li>
<li>Pod 是否指定了标签和污点容忍度</li>
<li>等等</li>
</ul>
<p>假设调度器要为一个 Pod 寻找合适的 Node, 该 Pod 的资源请求如下:</p>
<table>
<thead>
<tr>
<th>资源名称</th>
<th>请求量</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU</td>
<td>2000 m</td>
</tr>
<tr>
<td>内存</td>
<td>4096 MB</td>
</tr>
<tr>
<td>存储</td>
<td>SSD</td>
</tr>
</tbody>
</table>
<p>调度器会对参与调度的节点进行筛选过滤，并为 Pod 选择一个最合适的 Node 运行，假设本地参与调度的 Nodes 数量为 8 个，并且最终调度器选中 4 号 Node 为目标 Node,
下面是一个简化的调度流程过滤示例图:</p>
<p><img src="https://dbwu.tech/images/k8s/source_code/scheduler_filter_demo.png" alt="Scheduler 过滤示例图"></p>
<p>从上面的示例图中可以可以看到，经过各种条件的层层筛选，最终调度器确定的目标为 4 号 Node。</p>
<h3 id="插件">插件</h3>
<p>插件可以简单地理解为 “一个调用方法”，通过注册的方式注册到一个或多个 “扩展点” 被调用，插件只需要实现 “插件接口” 即可，具体功能不做限制。
<strong>一个插件可以改变调度的决策结果，也可以仅仅提供一些数据，还可以实现别的其他自定义功能</strong>。</p>
<p>常见的插件:</p>
<ul>
<li>NodeName: 筛选出和 Pod 指定的 Node 名称一样的 Node 列表</li>
<li>TaintToleration: 筛选出符合 Pod 污点容忍度的 Node 列表</li>
<li>NodeAffinity: 筛选出符合 Pod 亲和性的 Node 列表</li>
<li>NodeResourcesFit: 筛选出符合 Pod 请求资源的 Node 列表</li>
<li>等等</li>
</ul>
<h3 id="调度周期内的扩展点-事件-列表">调度周期内的扩展点 (事件) 列表</h3>
<table>
<thead>
<tr>
<th style="text-align:left">事件名称</th>
<th style="text-align:left">事件作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">PreFilter</td>
<td style="text-align:left">预处理 Pod</td>
</tr>
<tr>
<td style="text-align:left">Filter</td>
<td style="text-align:left">过滤 Nodes</td>
</tr>
<tr>
<td style="text-align:left">PostFilter</td>
<td style="text-align:left">仅在该 Pod 没有可行的 Node 时调用</td>
</tr>
<tr>
<td style="text-align:left">PreScore</td>
<td style="text-align:left">打分预处理</td>
</tr>
<tr>
<td style="text-align:left">Score</td>
<td style="text-align:left">对 Nodes 进行打分</td>
</tr>
<tr>
<td style="text-align:left">NormalizeScore</td>
<td style="text-align:left">在调度器计算 Node 排名之前修改分数</td>
</tr>
<tr>
<td style="text-align:left">Reserve</td>
<td style="text-align:left">调度器实际将一个 Pod 绑定到其指定节点之前，调用该扩展点</td>
</tr>
<tr>
<td style="text-align:left">Permit</td>
<td style="text-align:left">每个 Pod 调度周期的最后调用，用于防止或延迟 Pod 的绑定</td>
</tr>
<tr>
<td style="text-align:left">PreBind</td>
<td style="text-align:left">执行 Pod 绑定前所需的所有工作</td>
</tr>
<tr>
<td style="text-align:left">Bind</td>
<td style="text-align:left">将 Pod 绑定到 Node 上</td>
</tr>
<tr>
<td style="text-align:left">PostBind</td>
<td style="text-align:left">在 Pod 成功绑定后被调用</td>
</tr>
<tr>
<td style="text-align:left">Unreserve</td>
<td style="text-align:left">如果 Pod 被保留，然后在后面的阶段中被拒绝，则 Unreserve 将被通知</td>
</tr>
</tbody>
</table>
<p><strong>单个扩展点可以配合插件机制来改变调度决策</strong>，例如在执行 <code>Filter</code> 扩展点时，可以使用一批插件来过滤掉不符合当前 Pod 运行条件的 Nodes。</p>
<p>限于篇幅，上述表格中的事件，本文不一定都能分析到，感兴趣的读者可以在读完本文之后，根据兴趣自行阅读相关源代码。</p>
<h3 id="调度整体流程图">调度整体流程图</h3>
<p><img src="https://dbwu.tech/images/k8s/source_code/scheduling-framework-extensions.png" alt="图片来源: https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/624-scheduling-framework"></p>
<p>下面我们跟着流程图一起看下源代码的具体实现。</p>
<hr>
<h2 id="scheduler-对象">Scheduler 对象</h2>
<p><code>Scheduler</code> (调度器) 对象负责检测未被调度的 <code>Pods</code>, 并尝试为每个 Pod 寻找一个合适的 <code>Node</code> (节点) 运行，然后将 <code>Pod + Node</code> 的绑定关系更新到 <code>ApiServer</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">type</span> Scheduler <span style="color:#6ab825;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 调度器相关的数据缓存对象
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	Cache internalcache.Cache
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// NextPod 方法返回下一个调度的 Pod, 调用方式为阻塞调用
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	NextPod <span style="color:#6ab825;font-weight:bold">func</span>(logger klog.Logger) (*framework.QueuedPodInfo, <span style="color:#6ab825;font-weight:bold">error</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 调度失败回调方法
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 初始化 Scheduler 对象时
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 使用 Scheduler.handleSchedulingFailure 方法作为默认回调方法
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	FailureHandler FailureHandlerFn
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// SchedulePod 方法尝试从参数 Nodes 列表中为参数 Pod 选择一个合适的 Node
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	SchedulePod <span style="color:#6ab825;font-weight:bold">func</span>(ctx context.Context, ...) (ScheduleResult, <span style="color:#6ab825;font-weight:bold">error</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 调度器停止 channel
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	StopEverything &lt;-<span style="color:#6ab825;font-weight:bold">chan</span> <span style="color:#6ab825;font-weight:bold">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 等待被调度的 Pod 队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	SchedulingQueue internalqueue.SchedulingQueue
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 调度时筛选的 Node 比例 (默认为 50%)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	percentageOfNodesToScore <span style="color:#6ab825;font-weight:bold">int32</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// Node 队列索引
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	nextStartNodeIndex <span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 事件回调方法集合
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 主要用来检测在调度器开始调取之前，所有的回调方法是否已经全部完成初始化
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	registeredHandlers []cache.ResourceEventHandlerRegistration
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="创建--初始化">创建 &amp; 初始化</h3>
<p><code>New</code> 方法用于实例化一个 <code>Scheduler</code> (调度器) 对象并返回。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">New</span>(ctx context.Context, ...) (*Scheduler, <span style="color:#6ab825;font-weight:bold">error</span>) {
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 通过 informer 获取所有 Pods
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	podLister := informerFactory.<span style="color:#447fcf">Core</span>().<span style="color:#447fcf">V1</span>().<span style="color:#447fcf">Pods</span>().<span style="color:#447fcf">Lister</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 通过 informer 获取所有 Nodes
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	nodeLister := informerFactory.<span style="color:#447fcf">Core</span>().<span style="color:#447fcf">V1</span>().<span style="color:#447fcf">Nodes</span>().<span style="color:#447fcf">Lister</span>()
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 初始化优先级队列 (PriorityQueue 数据结构)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	podQueue := internalqueue.<span style="color:#447fcf">NewSchedulingQueue</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 将 Pods 加入到队列中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		internalqueue.<span style="color:#447fcf">WithPodLister</span>(podLister),
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 初始化调度器数据缓存
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	schedulerCache := internalcache.<span style="color:#447fcf">New</span>(ctx, durationToExpireAssumedPod)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 初始化调度器对象
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	sched := &amp;Scheduler{
</span></span><span style="display:flex;"><span>		Cache:                    schedulerCache,
</span></span><span style="display:flex;"><span>		SchedulingQueue:          podQueue,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 将队列第一个 Pod 出队
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 作为第一个调度的 Pod
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	sched.NextPod = podQueue.Pop
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 定义调度失败回调方法
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	sched.<span style="color:#447fcf">applyDefaultHandlers</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 注册自定义事件回调处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> err = <span style="color:#447fcf">addAllEventHandlers</span>(sched, ...); err != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">nil</span>, fmt.<span style="color:#447fcf">Errorf</span>(<span style="color:#ed9d13">&#34;adding event handlers: %w&#34;</span>, err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> sched, <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="监听-nodepod-变化">监听 Node/Pod 变化</h3>
<p><code>addAllEventHandlers</code> 方法主要将各种不同的事件回调处理方法添加到 <code>Scheduler</code> (调度器) 对象上面，这里着重展示监听 <code>Node/Pod</code> 变化的源代码，</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">addAllEventHandlers</span>(sched *Scheduler, ...) <span style="color:#6ab825;font-weight:bold">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">var</span> (
</span></span><span style="display:flex;"><span>		handlerRegistration cache.ResourceEventHandlerRegistration
</span></span><span style="display:flex;"><span>		err                 <span style="color:#6ab825;font-weight:bold">error</span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 回调事件处理方法队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		handlers            []cache.ResourceEventHandlerRegistration
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// Pods 变化时的回调处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> handlerRegistration, err = informerFactory.<span style="color:#447fcf">Core</span>().<span style="color:#447fcf">V1</span>().<span style="color:#447fcf">Pods</span>().<span style="color:#447fcf">Informer</span>().<span style="color:#447fcf">AddEventHandler</span>(
</span></span><span style="display:flex;"><span>		cache.FilteringResourceEventHandler{
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// Pod 过滤器
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			FilterFunc: <span style="color:#6ab825;font-weight:bold">func</span>(obj <span style="color:#6ab825;font-weight:bold">interface</span>{}) <span style="color:#6ab825;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>				...
</span></span><span style="display:flex;"><span>			},
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// Pod 新增/更新/删除时，更新调度器的对应的缓存
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			Handler: cache.ResourceEventHandlerFuncs{
</span></span><span style="display:flex;"><span>				AddFunc:    sched.addPodToCache,
</span></span><span style="display:flex;"><span>				UpdateFunc: sched.updatePodInCache,
</span></span><span style="display:flex;"><span>				DeleteFunc: sched.deletePodFromCache,
</span></span><span style="display:flex;"><span>			},
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// Pods 回调函数方法添加到队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	handlers = <span style="color:#24909d">append</span>(handlers, handlerRegistration)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 未调度的 Pods 的回调处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> handlerRegistration, err = informerFactory.<span style="color:#447fcf">Core</span>().<span style="color:#447fcf">V1</span>().<span style="color:#447fcf">Pods</span>().<span style="color:#447fcf">Informer</span>().<span style="color:#447fcf">AddEventHandler</span>(
</span></span><span style="display:flex;"><span>		cache.FilteringResourceEventHandler{
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// Pod 过滤器
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			FilterFunc: <span style="color:#6ab825;font-weight:bold">func</span>(obj <span style="color:#6ab825;font-weight:bold">interface</span>{}) <span style="color:#6ab825;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>				...
</span></span><span style="display:flex;"><span>			},
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 未调度的 Pod 创建/更新/删除时，更新调度器的调度队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			Handler: cache.ResourceEventHandlerFuncs{
</span></span><span style="display:flex;"><span>				AddFunc:    sched.addPodToSchedulingQueue,
</span></span><span style="display:flex;"><span>				UpdateFunc: sched.updatePodInSchedulingQueue,
</span></span><span style="display:flex;"><span>				DeleteFunc: sched.deletePodFromSchedulingQueue,
</span></span><span style="display:flex;"><span>			},
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// Pods 回调函数方法添加到队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	handlers = <span style="color:#24909d">append</span>(handlers, handlerRegistration)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// Nodes 变化时的回调处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> handlerRegistration, err = informerFactory.<span style="color:#447fcf">Core</span>().<span style="color:#447fcf">V1</span>().<span style="color:#447fcf">Nodes</span>().<span style="color:#447fcf">Informer</span>().<span style="color:#447fcf">AddEventHandler</span>(
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// Node 新增/更新/删除时，更新调度器的对应的缓存
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		cache.ResourceEventHandlerFuncs{
</span></span><span style="display:flex;"><span>			AddFunc:    sched.addNodeToCache,
</span></span><span style="display:flex;"><span>			UpdateFunc: sched.updateNodeInCache,
</span></span><span style="display:flex;"><span>			DeleteFunc: sched.deleteNodeFromCache,
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// Nodes 回调函数方法添加到队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	handlers = <span style="color:#24909d">append</span>(handlers, handlerRegistration)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 将事件回调函数集合绑定到调度器对象
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	sched.registeredHandlers = handlers
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="注册调度器">注册调度器</h2>
<p>目录根路径下面的 <code>scheduler.go</code> 文件中包含调度器的启动入口方法，内部使用 <code>cobra</code> 命令行脚手架注册了具体的初始化执行对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {
</span></span><span style="display:flex;"><span>	command := app.<span style="color:#447fcf">NewSchedulerCommand</span>()
</span></span><span style="display:flex;"><span>	code := cli.<span style="color:#447fcf">Run</span>(command)
</span></span><span style="display:flex;"><span>	os.<span style="color:#447fcf">Exit</span>(code)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>NewSchedulerCommand</code> 方法是脚手架的具体注册方法，其中需要执行的具体的方法为 <code>runCommand</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">NewSchedulerCommand</span>(registryOptions ...Option) *cobra.Command {
</span></span><span style="display:flex;"><span>	opts := options.<span style="color:#447fcf">NewOptions</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	cmd := &amp;cobra.Command{
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 默认调度器名称
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		Use: <span style="color:#ed9d13">&#34;kube-scheduler&#34;</span>, 
</span></span><span style="display:flex;"><span>		RunE: <span style="color:#6ab825;font-weight:bold">func</span>(cmd *cobra.Command, args []<span style="color:#6ab825;font-weight:bold">string</span>) <span style="color:#6ab825;font-weight:bold">error</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#447fcf">runCommand</span>(cmd, opts, registryOptions...)
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> cmd
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">runCommand</span>(cmd *cobra.Command, ...) <span style="color:#6ab825;font-weight:bold">error</span> {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 调用 Setup 方法初始化调度器对象
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	cc, sched, err := <span style="color:#447fcf">Setup</span>(ctx, opts, registryOptions...)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 调用 Run 方法启动调度器
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#447fcf">Run</span>(ctx, cc, sched)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">Setup</span>(ctx context.Context, ...) (*schedulerserverconfig.CompletedConfig, *scheduler.Scheduler, <span style="color:#6ab825;font-weight:bold">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 获取调度器的默认配置
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> cfg, err := latest.<span style="color:#447fcf">Default</span>(); err != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">nil</span>, <span style="color:#6ab825;font-weight:bold">nil</span>, err
</span></span><span style="display:flex;"><span>	} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>		opts.ComponentConfig = cfg
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 创建调度器对象
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	sched, err := scheduler.<span style="color:#447fcf">New</span>(ctx,
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> &amp;cc, sched, <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="启动调度器">启动调度器</h2>
<p><code>Run</code> 方法根据参数配置和调度器对象运行调度过程，方法内部会执行一系列必要的初始化和检测工作，最后调用参数 <code>Scheduler.Run</code> 方法真正执行调度过程。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">Run</span>(ctx context.Context, cc *schedulerserverconfig.CompletedConfig, sched *scheduler.Scheduler) <span style="color:#6ab825;font-weight:bold">error</span> {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	startInformersAndWaitForSync := <span style="color:#6ab825;font-weight:bold">func</span>(ctx context.Context) {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 启动所有 Informer
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		cc.InformerFactory.<span style="color:#447fcf">Start</span>(ctx.<span style="color:#447fcf">Done</span>())
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 开始调度过程之前等待所有缓存数据初始化完成
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		cc.InformerFactory.<span style="color:#447fcf">WaitForCacheSync</span>(ctx.<span style="color:#447fcf">Done</span>())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 开始调度过程之前等待所有事件回调方法注册完成
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> err := sched.<span style="color:#447fcf">WaitForHandlersSync</span>(ctx); err != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 调用 Scheduler.Run 方法
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	sched.<span style="color:#447fcf">Run</span>(ctx)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (sched *Scheduler) <span style="color:#447fcf">Run</span>(ctx context.Context) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 启动调度队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 默认的实现是一个优先队列，该队列了实现了 Pod 的 添加/更新/删除/获取 等操作
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 为了节省篇幅，这里先不对队列源代码实现展开分析
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	sched.SchedulingQueue.<span style="color:#447fcf">Run</span>(logger)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 单独启动一个 goroutine 用于处理调度逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 因为每次获取要调度的 Pod 时，获取操作本身是阻塞式的
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 如果没有新的 Pod 需要调度，操作就会阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 同时启动新的 goroutine 可以防止在 context 收到信号时发生死锁
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">go</span> wait.<span style="color:#447fcf">UntilWithContext</span>(ctx, sched.scheduleOne, <span style="color:#3677a9">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 等待 context 结束
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	&lt;-ctx.<span style="color:#447fcf">Done</span>()
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 关闭调度队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	sched.SchedulingQueue.<span style="color:#447fcf">Close</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="执行调度">执行调度</h2>
<p><code>Scheduler.scheduleOne</code> 是实现调度逻辑 (工作流) 的具体方法，每次调用该方法时，会从 <code>调度队列</code> 中取出一个等待调度的 Pod, 然后为该 Pod 选择一个合适的 Node 执行。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (sched *Scheduler) <span style="color:#447fcf">scheduleOne</span>(ctx context.Context) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 从调度队列中获取等待调度的 Pod
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	podInfo, err := sched.<span style="color:#447fcf">NextPod</span>(logger)
</span></span><span style="display:flex;"><span>	pod := podInfo.Pod
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 各种异常状态检测
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 计算 &amp; 选择一个适合 Pod 运行的 Node
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	scheduleResult, assumedPodInfo, status := sched.<span style="color:#447fcf">schedulingCycle</span>(schedulingCycleCtx, ...)
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> !status.<span style="color:#447fcf">IsSuccess</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 调度失败回调
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		sched.<span style="color:#447fcf">FailureHandler</span>(schedulingCycleCtx, ...)
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 绑定 Pod 和 Node 的关系
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 注意这里的绑定操作是异步执行的
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">go</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 绑定 Pod 和 Node
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		status := sched.<span style="color:#447fcf">bindingCycle</span>(bindingCycleCtx, ...)
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> !status.<span style="color:#447fcf">IsSuccess</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 绑定关系操作失败
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			sched.<span style="color:#447fcf">handleBindingCycleError</span>(bindingCycleCtx, ...)
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 将 Pod 标记为已完成调度
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		sched.SchedulingQueue.<span style="color:#447fcf">Done</span>(assumedPodInfo.Pod.UID)
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="选择-node-节点">选择 Node 节点</h2>
<p><code>Scheduler.schedulingCycle</code> 方法是 Pod 选取 Node 节点过程的调用入口。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (sched *Scheduler) <span style="color:#447fcf">schedulingCycle</span>(ctx context.Context, ...) (...) {
</span></span><span style="display:flex;"><span>	pod := podInfo.Pod
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 为 Pod 筛选适合运行的 Node
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	scheduleResult, err := sched.<span style="color:#447fcf">SchedulePod</span>(ctx, fwk, state, pod)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 如果发生了错误，说明没有合适的 Node 
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> err != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 如果已经没有可用的 Nodes 了，直接返回 
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		...
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 运行过滤插件 {执行后的钩子方法} ...
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		...
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> ...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 记录筛选 Node 过程的 Metric
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Scheduler.schedulePod</code> 方法尝试从参数 Nodes 列表中为参数 Pod 选择一个合适的 Node, 如果能匹配到合适的 Node 就直接返回，如果匹配不到就返回具体的匹配失败原因。</p>
<p>节点选择的过程主要分为两步:</p>
<ol>
<li>[预筛选] 筛选出符合条件的 Nodes</li>
<li>[打分排序] 对筛选出来的 Nodes 进行打分，最后得分最高的 Node 就是 Pod 要调度的目标 Node</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (sched *Scheduler) <span style="color:#447fcf">schedulePod</span>(ctx context.Context, ..., pod *v1.Pod) (result ScheduleResult, err <span style="color:#6ab825;font-weight:bold">error</span>) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// [预筛选] 先筛选出符合条件的 Nodes
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	feasibleNodes, diagnosis, err := sched.<span style="color:#447fcf">findNodesThatFitPod</span>(ctx, fwk, state, pod)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 如果没有符合条件的 Node, 直接返回失败原因
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#24909d">len</span>(feasibleNodes) == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> result, &amp;framework.FitError{
</span></span><span style="display:flex;"><span>            ...
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 如果符合条件的 Node 只有 1 个
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 嫁鸡随鸡，嫁狗随狗了 :-)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#24909d">len</span>(feasibleNodes) == <span style="color:#3677a9">1</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> ScheduleResult{
</span></span><span style="display:flex;"><span>            ...
</span></span><span style="display:flex;"><span>		}, <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 再来一波优先级打分排序
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	priorityList, err := <span style="color:#447fcf">prioritizeNodes</span>(ctx, ...)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// [打分排序] 从打分排序完成的列表中择优录取 Node 返回
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	host, _, err := <span style="color:#447fcf">selectHost</span>(priorityList, numberOfHighestScoredNodesToReport)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> ScheduleResult{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>	}, err
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="预筛选过程">预筛选过程</h2>
<p><code>Scheduler.findNodesThatFitPod</code> 方法根据过滤插件和过滤扩展，筛选出适合 Pod 运行的 Node 列表。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (sched *Scheduler) <span style="color:#447fcf">findNodesThatFitPod</span>(ctx context.Context, ..., pod *v1.Pod) ([]*v1.Node, ...) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 获取所有的 Nodes
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	allNodes, err := sched.nodeInfoSnapshot.<span style="color:#447fcf">NodeInfos</span>().<span style="color:#447fcf">List</span>()
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 运行预处理插件过滤 Nodes
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	preRes, s := fwk.<span style="color:#447fcf">RunPreFilterPlugins</span>(ctx, state, pod)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	nodes := allNodes
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> !preRes.<span style="color:#447fcf">AllNodes</span>() {
</span></span><span style="display:flex;"><span>		nodes = <span style="color:#24909d">make</span>([]*framework.NodeInfo, <span style="color:#3677a9">0</span>, <span style="color:#24909d">len</span>(preRes.NodeNames))
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 遍历预处理插件过滤完的 Nodes
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 逐个获取 Node 对象并追加到 Nodes 列表中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">for</span> n := <span style="color:#6ab825;font-weight:bold">range</span> preRes.NodeNames {
</span></span><span style="display:flex;"><span>			nInfo, err := sched.nodeInfoSnapshot.<span style="color:#447fcf">NodeInfos</span>().<span style="color:#447fcf">Get</span>(n)
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> err != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">nil</span>, diagnosis, err
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			nodes = <span style="color:#24909d">append</span>(nodes, nInfo)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 运行过滤插件过滤 Nodes
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	feasibleNodes, err := sched.<span style="color:#447fcf">findNodesThatPassFilters</span>(ctx, ..., nodes)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 更新调度器的 Nodes 列表读取索引
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 保证每个 Node 都有机会被选取 &amp; 调度
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	processedNodes := <span style="color:#24909d">len</span>(feasibleNodes) + <span style="color:#24909d">len</span>(diagnosis.NodeToStatusMap)
</span></span><span style="display:flex;"><span>	sched.nextStartNodeIndex = (sched.nextStartNodeIndex + processedNodes) % <span style="color:#24909d">len</span>(nodes)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 运行过滤扩展再次过滤 Nodes
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	feasibleNodes, err = <span style="color:#447fcf">findNodesThatPassExtenders</span>(ctx, ...)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> feasibleNodes, diagnosis, <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="计算参与过滤的-nodes-数量">计算参与过滤的 Nodes 数量</h3>
<p>一个 Kubernetes 集群中少则几十个 Nodes, 多则好几千 Nodes, 如果每次过滤时所有的 Nodes 都参与，那么这个计算量就太耗时了，严重甚至会影响 Pod 的调度性能。</p>
<p>为了避免这个问题，每次过滤时都会调用 <code>Scheduler.numFeasibleNodesToFind</code> 方法计算出一个数量值，作为参与过滤的 Nodes 数量。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">const</span> (
</span></span><span style="display:flex;"><span>    minFeasibleNodesToFind = <span style="color:#3677a9">100</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    minFeasibleNodesPercentageToFind = <span style="color:#3677a9">5</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (sched *Scheduler) <span style="color:#447fcf">numFeasibleNodesToFind</span>(percentageOfNodesToScore *<span style="color:#6ab825;font-weight:bold">int32</span>, numAllNodes <span style="color:#6ab825;font-weight:bold">int32</span>) (numNodes <span style="color:#6ab825;font-weight:bold">int32</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 如果节点数量少于 100 个
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 几乎没什么性能影响，直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> numAllNodes &lt; minFeasibleNodesToFind {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> numAllNodes
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 计算要参与过滤的 Pos 比例
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 如果参数中没有设置，就以调度器对象的配置字段为准 (50%)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">var</span> percentage <span style="color:#6ab825;font-weight:bold">int32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> percentageOfNodesToScore != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		percentage = *percentageOfNodesToScore
</span></span><span style="display:flex;"><span>	} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>		percentage = sched.percentageOfNodesToScore
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> percentage == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		percentage = <span style="color:#24909d">int32</span>(<span style="color:#3677a9">50</span>) - numAllNodes/<span style="color:#3677a9">125</span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 参与过滤的 Nodes 数量最少为 5 个
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> percentage &lt; minFeasibleNodesPercentageToFind {
</span></span><span style="display:flex;"><span>			percentage = minFeasibleNodesPercentageToFind
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	numNodes = numAllNodes * percentage / <span style="color:#3677a9">100</span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> numNodes &lt; minFeasibleNodesToFind {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 参与过滤的 Nodes 数量最少为 100 个
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">return</span> minFeasibleNodesToFind
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> numNodes
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="过滤插件">过滤插件</h3>
<p><code>Scheduler.findNodesThatPassFilters</code> 方法运行过滤插件，筛选出适合 Pod 运行的 Nodes。</p>
<p>从数据结构的角度来看，整个 “执行插件过滤 -&gt; 筛选 Nodes” 的过程就是一个典型的 <code>MapReduce</code> 计算，然后结合源代码中的多个 <code>goroutine</code> 并行计算，
最后的流程图如下所示。</p>
<p><img src="https://dbwu.tech/images/k8s/source_code/scheduling_filter_nodes.png" alt="Scheduler Node 过滤流程图"></p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (sched *Scheduler) <span style="color:#447fcf">findNodesThatPassFilters</span>(ctx context.Context, pod *v1.Pod, ... nodes []*framework.NodeInfo) ([]*v1.Node, <span style="color:#6ab825;font-weight:bold">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 计算参数 Nodes 的数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	numAllNodes := <span style="color:#24909d">len</span>(nodes)
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 计算参与过滤条件的 Nodes 数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	numNodesToFind := sched.<span style="color:#447fcf">numFeasibleNodesToFind</span>(fwk.<span style="color:#447fcf">PercentageOfNodesToScore</span>(), <span style="color:#24909d">int32</span>(numAllNodes))
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 初始化返回结果 Nodes 列表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	feasibleNodes := <span style="color:#24909d">make</span>([]*v1.Node, numNodesToFind)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 如果没有注册过滤插件
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 事情就变得简单了，直接从调度器的 Nodes 队列中根据索引，返回具体数量的 Nodes 即可
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> !fwk.<span style="color:#447fcf">HasFilterPlugins</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#6ab825;font-weight:bold">range</span> feasibleNodes {
</span></span><span style="display:flex;"><span>			feasibleNodes[i] = nodes[(sched.nextStartNodeIndex+i)%numAllNodes].<span style="color:#447fcf">Node</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> feasibleNodes, <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 并行过滤中，单个 goroutine 中的执行 (回调) 方法
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 参数 i 就是调度器的 Nodes 队列中的索引
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 起始索引就是上一轮调度结束的索引 “偏移量”
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	checkNode := <span style="color:#6ab825;font-weight:bold">func</span>(i <span style="color:#6ab825;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 根据参数 i 获取队列中对应的 Node 对象
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		nodeInfo := nodes[(sched.nextStartNodeIndex+i)%numAllNodes]
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 运行过滤插件检测 Node 是否合适
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		status := fwk.<span style="color:#447fcf">RunFilterPluginsWithNominatedPods</span>(ctx, state, pod, nodeInfo)
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> status.<span style="color:#447fcf">IsSuccess</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 每当有一个 Node 通过检测时
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 计数器原子操作 + 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			length := atomic.<span style="color:#447fcf">AddInt32</span>(&amp;feasibleNodesLen, <span style="color:#3677a9">1</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> length &gt; numNodesToFind {
</span></span><span style="display:flex;"><span>                <span style="color:#999;font-style:italic">// 如果通过检测的 Node 数量大于 {参与过滤条件的 Nodes 数量}
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>                <span style="color:#999;font-style:italic">//   说明当前这轮调度需要的 Node 数量已经足够了
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>                <span style="color:#999;font-style:italic">//   此时并行任务退出即可
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>				<span style="color:#999;font-style:italic">// 执行 cancel() 通知其他并行的 goroutine 结束 (所有并行的 goroutine 共享一个 Context 对象)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>				<span style="color:#447fcf">cancel</span>()
</span></span><span style="display:flex;"><span>				atomic.<span style="color:#447fcf">AddInt32</span>(&amp;feasibleNodesLen, -<span style="color:#3677a9">1</span>)
</span></span><span style="display:flex;"><span>			} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#999;font-style:italic">// 为对应的 Nodes 结果列表中对应的索引赋值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>				feasibleNodes[length-<span style="color:#3677a9">1</span>] = nodeInfo.<span style="color:#447fcf">Node</span>()
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 调度过程记录 Metric
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 启动并行过滤
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	fwk.<span style="color:#447fcf">Parallelizer</span>().<span style="color:#447fcf">Until</span>(ctx, numAllNodes, checkNode, metrics.Filter)
</span></span><span style="display:flex;"><span>	feasibleNodes = feasibleNodes[:feasibleNodesLen]
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> feasibleNodes, <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="打分排序过程">打分排序过程</h2>
<p><code>prioritizeNodes</code> 方法通过一系列打分插件和扩展对参数 Nodes 进行打分，来确定 Node 的优先级，返回的结果 Nodes 列表中的每个 Node 都有一个对应的权重 (分数)。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">prioritizeNodes</span>(ctx context.Context, ..., pod *v1.Pod, nodes []*v1.Node) ([]framework.NodePluginScores, <span style="color:#6ab825;font-weight:bold">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 如果打分插件和扩展都为空
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 那么所有的 Nodes 的权重都是 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 直接返回即可
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#24909d">len</span>(extenders) == <span style="color:#3677a9">0</span> &amp;&amp; !fwk.<span style="color:#447fcf">HasScorePlugins</span>() {
</span></span><span style="display:flex;"><span>		result := <span style="color:#24909d">make</span>([]framework.NodePluginScores, <span style="color:#3677a9">0</span>, <span style="color:#24909d">len</span>(nodes))
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#6ab825;font-weight:bold">range</span> nodes {
</span></span><span style="display:flex;"><span>			result = <span style="color:#24909d">append</span>(result, framework.NodePluginScores{
</span></span><span style="display:flex;"><span>				Name:       nodes[i].Name,
</span></span><span style="display:flex;"><span>				TotalScore: <span style="color:#3677a9">1</span>,
</span></span><span style="display:flex;"><span>			})
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> result, <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 运行打分前的预处理插件
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	preScoreStatus := fwk.<span style="color:#447fcf">RunPreScorePlugins</span>(ctx, state, pod, nodes)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 运行打分插件
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	nodesScores, scoreStatus := fwk.<span style="color:#447fcf">RunScorePlugins</span>(ctx, state, pod, nodes)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 记录 Nodes 分数日志
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    ...
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 运行打分扩展，继续打分
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#24909d">len</span>(extenders) != <span style="color:#3677a9">0</span> &amp;&amp; nodes != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#6ab825;font-weight:bold">range</span> extenders {
</span></span><span style="display:flex;"><span>			...
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> nodesScores, <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="根据打分结果选取-node">根据打分结果选取 Node</h2>
<p><code>selectHost</code> 方法根据打完分数的 Nodes 列表，选取一个最适合 Pod 运行的 Node 并返回。</p>
<p>注意: 如果存在多个 Nodes 分数一样时，会将多个 Nodes 列表一起返回，但是会进行简单的随机处理 (提升负载均衡)，
这样最后返回结果中 Pod 的目标 Node 仍然是列表中的第一个元素。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">selectHost</span>(nodeScoreList []framework.NodePluginScores, count <span style="color:#6ab825;font-weight:bold">int</span>) (<span style="color:#6ab825;font-weight:bold">string</span>, []framework.NodePluginScores, <span style="color:#6ab825;font-weight:bold">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">var</span> h nodeScoreHeap = nodeScoreList
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 使用堆排序
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	heap.<span style="color:#447fcf">Init</span>(&amp;h)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 初始化返回结果 Nodes 列表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	sortedNodeScoreList := <span style="color:#24909d">make</span>([]framework.NodePluginScores, <span style="color:#3677a9">0</span>, count)
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 现将堆中的最高分 Node 加入到返回结果列表中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	sortedNodeScoreList = <span style="color:#24909d">append</span>(sortedNodeScoreList, heap.<span style="color:#447fcf">Pop</span>(&amp;h).(framework.NodePluginScores))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 寻找和最高分数值相同的所有 Nodes
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> ns := heap.<span style="color:#447fcf">Pop</span>(&amp;h).(framework.NodePluginScores); ; ns = heap.<span style="color:#447fcf">Pop</span>(&amp;h).(framework.NodePluginScores) {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> ns.TotalScore != sortedNodeScoreList[<span style="color:#3677a9">0</span>].TotalScore &amp;&amp; <span style="color:#24909d">len</span>(sortedNodeScoreList) == count {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 如果当前元素 Node 和最高分 Node 分数值一样
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 从两个 Node 中随机选择一个作为返回结果中的目标 Node，提升负载均衡
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> ns.TotalScore == sortedNodeScoreList[<span style="color:#3677a9">0</span>].TotalScore {
</span></span><span style="display:flex;"><span>			cntOfMaxScore++
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> rand.<span style="color:#447fcf">Intn</span>(cntOfMaxScore) == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>				selectedIndex = cntOfMaxScore - <span style="color:#3677a9">1</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		sortedNodeScoreList = <span style="color:#24909d">append</span>(sortedNodeScoreList, ns)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> h.<span style="color:#447fcf">Len</span>() == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> selectedIndex != <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 存在和最高分 Node 分数值一样的 Node
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 直接交换两者
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 感觉代码作者对 Go 语言语法不熟悉？ 
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">//   下面的 3 行代码可以缩减为 1 行
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		previous := sortedNodeScoreList[<span style="color:#3677a9">0</span>]
</span></span><span style="display:flex;"><span>		sortedNodeScoreList[<span style="color:#3677a9">0</span>] = sortedNodeScoreList[selectedIndex]
</span></span><span style="display:flex;"><span>		sortedNodeScoreList[selectedIndex] = previous
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> sortedNodeScoreList[<span style="color:#3677a9">0</span>].Name, sortedNodeScoreList, <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="调度失败">调度失败</h2>
<p><code>Scheduler.handleSchedulingFailure</code> 方法是调取失败时的回调方法，方法内部主要做两件事情:</p>
<ol>
<li>记录调度失败的 Pod 对象信息、失败原因、失败日志</li>
<li>将调度失败的 Pod 重新加入调度器的队列</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (sched *Scheduler) <span style="color:#447fcf">handleSchedulingFailure</span>(ctx context.Context, ...) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 记录日志
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 尝试通过 informer 的缓存获取 Pod 列表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	podLister := fwk.<span style="color:#447fcf">SharedInformerFactory</span>().<span style="color:#447fcf">Core</span>().<span style="color:#447fcf">V1</span>().<span style="color:#447fcf">Pods</span>().<span style="color:#447fcf">Lister</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 从 Pod 列表中根据名字获取对应的 Pod
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	cachedPod, e := podLister.<span style="color:#447fcf">Pods</span>(pod.Namespace).<span style="color:#447fcf">Get</span>(pod.Name)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> e != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>	} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#24909d">len</span>(cachedPod.Spec.NodeName) != <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// Pod 已经分配到 Node 了
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		} <span style="color:#6ab825;font-weight:bold">else</span> { 
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 将 Pod 加入到调度器的队列中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			podInfo.PodInfo, _ = framework.<span style="color:#447fcf">NewPodInfo</span>(cachedPod.<span style="color:#447fcf">DeepCopy</span>())
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> err := sched.SchedulingQueue.<span style="color:#447fcf">AddUnschedulableIfNotPresent</span>(logger, podInfo, ...); err != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			    ...	
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="小结">小结</h2>
<p><img src="https://dbwu.tech/images/k8s/source_code/scheduling_flow.png" alt="Scheduler 调度流程图"></p>
<p>本文从源代码的角度，分析了 Kubernetes 中默认调度器的核心调度流程，并对流程中的扩展点 (事件)、过滤插件、打分机制做了简答的概述，限于篇幅，
有几个重要的知识点没有展开分析，例如 <code>调度器队列</code>、 <code>扩展点 + 插件过滤机制</code>、 <code>调度过程中的串行/并行执行机制</code> 这些重要的设计，接下来，
笔者会在本文的基础上进一步分析这几个重要功能的实现，并输出单独的文章。希望可以帮助读者了解并熟悉调度器的主体流程，并在此基础上根据自己的兴趣深入研究。</p>
<h3 id="faq">FAQ</h3>
<h4 id="1-为什么-绑定周期-可以并行执行而-调度周期-只能串行执行">1. 为什么 绑定周期 可以并行执行，而 调度周期 只能串行执行？</h4>
<p>因为根据当前调度器的设计，通过预筛选过程和打分排序过程筛选出来的 Node, 无法保证并发安全，例如筛选出来的 Node 在并发场景下可能被多个 Pod 绑定。</p>
<h4 id="2-调度器的核心并发数量居然为-1-">2. 调度器的核心并发数量居然为 1 ？</h4>
<p>从前文中的 <code>scheduleOne</code> 方法的源代码可以看到，整个调度只有一个 goroutine 用于调用 <code>scheduleOne</code> 方法。而针对这个问题，
云原生社区中有人使用 <a href="https://github.com/fabric8io/kansible/blob/master/vendor/k8s.io/kubernetes/docs/devel/kubemark-guide.md">kubemark</a>
模拟 2000 个节点的规模来压测 调度器 的处理性能及时延, 测试结果是 30s 内完成了 15000 个 Pod 调度任务。
此外，虽然 调度器 是单并发模型, 但由于预筛选过程和打分排序过程都属于计算型任务非阻塞 IO,
最重要的是绝大部分场景中创建 Pod 的操作通常不会太频繁. 综上所述，即使调度器的的并发数量为 1, 从性能方面来说也是可以接受的。</p>
<h4 id="3-pod-处于-pending-状态且事件信息显示-failedscheduling-">3. Pod 处于 pending 状态且事件信息显示 failedScheduling ?</h4>
<p>如果调度器找不到任何可以运行该 Pod 的节点，会将该 Pod 标记为不可调度状态，直到出现一个可以被调度到的节点。</p>
<p>出现这种情况时，可以尝试进行如下操作:</p>
<ul>
<li>检查节点容量和已分配的资源数量 (kubectl describe nodes)</li>
<li>向集群添加更多节点</li>
<li>终止不需要的 Pod，为不可调度的 Pod 节省出运行资源</li>
<li>考虑是否可以降低 Pod 所需的申请运行资源</li>
<li>检查节点上的污点和 Pod 容忍度是否存在冲突</li>
</ul>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/624-scheduling-framework/README.md">Kubernetes Scheduling Framework</a></li>
<li><a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/kube-scheduler/">Scheduler</a></li>
<li><a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/scheduling-framework/">Scheduling Framework</a></li>
<li><a href="https://github.com/kubernetes/community/blob/f03b6d5692bd979f07dd472e7b6836b2dad0fd9b/contributors/devel/sig-scheduling/scheduling_code_hierarchy_overview.md">Scheduler code hierarchy overview</a></li>
<li><a href="https://github.com/rfyiamcool/notes/blob/main/kubernetes_scheduler_code.md">源码分析 kubernetes scheduler 核心调度器的实现原理</a></li>
</ul>
<h2 id="扩展阅读">扩展阅读</h2>
<ul>
<li><a href="https://itnext.io/kubernetes-scheduler-deep-dive-fdfcb516be30">Kubernetes Scheduler Deep Dive</a></li>
<li><a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-scheduler/">kube-scheduler</a></li>
<li><a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/pod-priority-preemption/">Pod 优先级和抢占</a></li>
<li><a href="https://mp.weixin.qq.com/s/urpyLd1tzZKBgSOEy4a3lA">Crane-Scheduler:真实工作负载感知的调度器设计与实现</a></li>
<li><a href="https://mp.weixin.qq.com/s/CgW1zqfQBdUQo8qDtV-57Q">Kubernetes 资源拓扑感知调度优化</a></li>
</ul>


</article>

<article>
    <img src="https://dbwu.tech/images/wechat.png">
</article>

<article>
    <h3>转载申请</h3>

    <p>
        本作品采用 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> 进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，商业转载请联系作者获得授权。
    </p>
</article>

<section class="post-nav">
    <ul>
        <li>
        
            <a href="https://dbwu.tech/posts/k8s/network/cni/"><i class="fa fa-chevron-circle-left"></i> Kubernetes Networking Model &amp; CNI</a>
        
        </li>
        <li>
        
            <a href="https://dbwu.tech/posts/k8s/source_code/scheduler_queue/">Kubernetes 调度器队列 - 设计与实现 <i class="fa fa-chevron-circle-right"></i> </a>
        
        </li>
    </ul>
</section>
  
    
    
  


<script src="https://giscus.app/client.js"
        data-repo="duanbiaowu/dbwu.tech"
        data-repo-id="R_kgDOIkkjjw"
        data-category="Announcements"
        data-category-id="DIC_kwDOIkkjj84CV78j"
        data-mapping="specific"
        data-term="Kubernetes 调度器 - 核心流程"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous" async>
</script>




</main>
    <footer>
        <ul>
            <li>
                <h6><a href="mailto:codean.net@gmail.com">codean.net@gmail.com</a> | 
                    <img src="https://dbwu.tech/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" />
                    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61011302001681" target="_blank">陕公网安备 61011302001681 号</a> |
                    <a href="https://beian.miit.gov.cn" target="_blank">陕ICP备2023004378号-1</a> |
                    Rendered by <a href="https://themes.gohugo.io" title="Hugo" target="_blank">Hugo</a>
                </h6>
            </li>
            
            
        </ul>
    </footer>
</div>
<script src="https://dbwu.tech/js/scripts.js"></script>


</body>

</html>

