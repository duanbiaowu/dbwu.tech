<!doctype html>

<html lang="en">

<head>
  <title>goroutine 泄漏与检测 - 蛮荆</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="Go 语言内置 GC，因此一般不会内存泄漏，但是 goroutine 可能会发生泄漏，泄漏的 goroutine 引用的内存同样无法被 GC 正常回收 &hellip;" />
<meta name="author" content="" />
<link rel="shortcut icon" href="https://dbwu.tech/favicon.ico" type="image/x-icon" /><meta property="og:title" content="goroutine 泄漏与检测" />
<meta property="og:description" content="Go 语言内置 GC，因此一般不会内存泄漏，但是 goroutine 可能会发生泄漏，泄漏的 goroutine 引用的内存同样无法被 GC 正常回收。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dbwu.tech/posts/golang_goroutine_leak/" />
<meta property="article:published_time" content="2023-06-11T00:00:00+08:00" />
<meta property="article:modified_time" content="2023-06-11T00:00:00+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="goroutine 泄漏与检测"/>
<meta name="twitter:description" content="Go 语言内置 GC，因此一般不会内存泄漏，但是 goroutine 可能会发生泄漏，泄漏的 goroutine 引用的内存同样无法被 GC 正常回收。"/>

<meta name="generator" content="Hugo 0.68.3" />
    
    <script src="https://dbwu.tech/js/mathjax-config.js" defer></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CZMGTTFLNY"></script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3261056100776781" crossorigin="anonymous"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-CZMGTTFLNY');
  </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>


  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/normalize.min.css" />
  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/all.min.css" />
  
    
    <link href="//fonts.googleapis.com/css?family=Staatliches" rel="stylesheet">
  
  
  <link rel="stylesheet" type="text/css" href="https://dbwu.tech/css/styles-light.css" />
  </head>

<body>
  <div id="container">
    <header>
      
      <h1>
        <a href="https://dbwu.tech/">蛮荆</a>
      </h1>

      <ul id="social-media">
      </ul>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://dbwu.tech/posts/">
                <i class="fa-li fa  fa-lg"></i><span>归档</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/tags/">
                <i class="fa-li fa  fa-lg"></i><span>标签</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://github.com/duanbiaowu">
                <i class="fa-li fa  fa-lg"></i><span>Github</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/index.xml">
                <i class="fa-li fa  fa-lg"></i><span>RSS</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<article>

    <h1>goroutine 泄漏与检测</h1>

    
      
<li>
    
    
    <a href="https://dbwu.tech/tags/golang">Golang</a>
    
    
    <a href="https://dbwu.tech/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">并发编程</a>
    
    
    <a href="https://dbwu.tech/tags/go-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Go 源码分析</a>
    
    
    <a href="https://dbwu.tech/tags/%E8%AF%BB%E4%BB%A3%E7%A0%81">读代码</a>
    
</li>

    

    
      

    

    <h2 id="概述">概述</h2>
<p>Go 语言内置 GC，因此一般不会内存泄漏，但是 <code>goroutine</code> 可能会发生泄漏，泄漏的 <code>goroutine</code> 引用的内存同样无法被 GC 正常回收。</p>
<h2 id="常见-goroutine-泄漏场景">常见 goroutine 泄漏场景</h2>
<p>下面总结一下开发中经常遇到的 <code>goroutine</code> 泄漏场景，本文示例代码只是为了演示，没有任何现实意义。</p>
<h3 id="通道为-nil">通道为 nil</h3>
<p>在 <code>nil 通道</code> 上发送和接收操作将永久阻塞，会造成 <code>goroutine 泄漏</code>。</p>
<blockquote>
<p>最佳实践:</p>
<ol>
<li>永远不要对 <code>nil 通道</code> 进行任何操作</li>
<li>直接使用 <code>make()</code> 初始化通道</li>
</ol>
</blockquote>
<h4 id="接收通道为-nil">接收通道为 nil</h4>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {
	<span style="color:#6ab825;font-weight:bold">var</span> ch <span style="color:#6ab825;font-weight:bold">chan</span> <span style="color:#6ab825;font-weight:bold">bool</span>

	<span style="color:#6ab825;font-weight:bold">go</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
		<span style="color:#6ab825;font-weight:bold">defer</span> <span style="color:#6ab825;font-weight:bold">func</span>() { <span style="color:#999;font-style:italic">// defer 不会执行
</span><span style="color:#999;font-style:italic"></span>			fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;goroutine ending&#34;</span>) <span style="color:#999;font-style:italic">// 不会输出
</span><span style="color:#999;font-style:italic"></span>		}()

		<span style="color:#6ab825;font-weight:bold">for</span> v := <span style="color:#6ab825;font-weight:bold">range</span> ch {
			fmt.<span style="color:#447fcf">Println</span>(v)
		}

		fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;range broken&#34;</span>) <span style="color:#999;font-style:italic">// 执行不到这里
</span><span style="color:#999;font-style:italic"></span>	}()
	
	time.<span style="color:#447fcf">Sleep</span>(time.Second) <span style="color:#999;font-style:italic">// 假设主程序 1 秒后退出
</span><span style="color:#999;font-style:italic"></span>}

<span style="color:#999;font-style:italic">// $ go run main.go
</span><span style="color:#999;font-style:italic">// 没有任何输出，goroutine 泄漏
</span></code></pre></div><h4 id="发送通道为-nil">发送通道为 nil</h4>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {
	<span style="color:#6ab825;font-weight:bold">var</span> ch <span style="color:#6ab825;font-weight:bold">chan</span> <span style="color:#6ab825;font-weight:bold">bool</span>

	<span style="color:#6ab825;font-weight:bold">go</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
		<span style="color:#6ab825;font-weight:bold">defer</span> <span style="color:#6ab825;font-weight:bold">func</span>() { <span style="color:#999;font-style:italic">// defer 不会执行
</span><span style="color:#999;font-style:italic"></span>			fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;goroutine ending&#34;</span>) <span style="color:#999;font-style:italic">// 不会输出
</span><span style="color:#999;font-style:italic"></span>		}()

		ch &lt;- <span style="color:#6ab825;font-weight:bold">true</span>

		fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;range broken&#34;</span>) <span style="color:#999;font-style:italic">// 执行不到这里
</span><span style="color:#999;font-style:italic"></span>	}()

	time.<span style="color:#447fcf">Sleep</span>(time.Second) <span style="color:#999;font-style:italic">// 假设主程序 1 秒后退出
</span><span style="color:#999;font-style:italic"></span>}

<span style="color:#999;font-style:italic">// $ go run main.go
</span><span style="color:#999;font-style:italic">// 没有任何输出，goroutine 泄漏
</span></code></pre></div><h3 id="遍历未关闭通道">遍历未关闭通道</h3>
<p>遍历 <code>无缓冲 (阻塞) 并且未关闭</code> 的通道时，如果通道一直未关闭， 将会永久阻塞，造成 <code>goroutine 泄漏</code>。</p>
<p>遍历 <code>缓冲 (非阻塞) 并且未关闭</code> 的通道时，将通道内的所有缓存数据接收完毕后，如果通道一直未关闭，将会永久阻塞，造成 <code>goroutine 泄漏</code>。</p>
<blockquote>
<p>最佳实践:</p>
<ol>
<li>确保 <code>通道</code> 可以正常关闭</li>
<li>确保 <code>goroutine</code> 可以正常退出</li>
</ol>
</blockquote>
<h4 id="遍历无缓冲并且未关闭的通道">遍历无缓冲并且未关闭的通道</h4>
<p><strong>错误的做法</strong></p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {
	ch := <span style="color:#24909d">make</span>(<span style="color:#6ab825;font-weight:bold">chan</span> <span style="color:#6ab825;font-weight:bold">bool</span>)

	<span style="color:#6ab825;font-weight:bold">go</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
		<span style="color:#6ab825;font-weight:bold">defer</span> <span style="color:#6ab825;font-weight:bold">func</span>() { <span style="color:#999;font-style:italic">// defer 不会执行
</span><span style="color:#999;font-style:italic"></span>			fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;goroutine ending&#34;</span>) <span style="color:#999;font-style:italic">// 不会输出
</span><span style="color:#999;font-style:italic"></span>		}()

		<span style="color:#6ab825;font-weight:bold">for</span> v := <span style="color:#6ab825;font-weight:bold">range</span> ch {
			fmt.<span style="color:#447fcf">Println</span>(v)
			<span style="color:#6ab825;font-weight:bold">break</span>
		}

		fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;range broken&#34;</span>) <span style="color:#999;font-style:italic">// 执行不到这里
</span><span style="color:#999;font-style:italic"></span>	}()

	time.<span style="color:#447fcf">Sleep</span>(time.Second) <span style="color:#999;font-style:italic">// 假设主程序 1 秒后退出
</span><span style="color:#999;font-style:italic"></span>}

<span style="color:#999;font-style:italic">// $ go run main.go
</span><span style="color:#999;font-style:italic">// 没有任何输出，goroutine 泄漏
</span></code></pre></div><p><strong>正确的做法</strong></p>
<p>参照最佳实践，对代码进行以下调整: 在 <code>goroutine</code> 外部关闭通道，防止 <code>goroutine</code> 内部遍历陷入无限阻塞。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {
	ch := <span style="color:#24909d">make</span>(<span style="color:#6ab825;font-weight:bold">chan</span> <span style="color:#6ab825;font-weight:bold">bool</span>)

	<span style="color:#6ab825;font-weight:bold">go</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
		<span style="color:#6ab825;font-weight:bold">defer</span> <span style="color:#6ab825;font-weight:bold">func</span>() { <span style="color:#999;font-style:italic">// defer 正常执行
</span><span style="color:#999;font-style:italic"></span>			fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;goroutine ending&#34;</span>) <span style="color:#999;font-style:italic">// 正常输出
</span><span style="color:#999;font-style:italic"></span>		}()

		<span style="color:#6ab825;font-weight:bold">for</span> v := <span style="color:#6ab825;font-weight:bold">range</span> ch { <span style="color:#999;font-style:italic">// 外部关闭通道后，for 循环结束
</span><span style="color:#999;font-style:italic"></span>			fmt.<span style="color:#447fcf">Println</span>(v) <span style="color:#999;font-style:italic">// 不会输出
</span><span style="color:#999;font-style:italic"></span>		}

		fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;range broken&#34;</span>) <span style="color:#999;font-style:italic">// 可以执行到这里
</span><span style="color:#999;font-style:italic"></span>	}()

	<span style="color:#24909d">close</span>(ch) <span style="color:#999;font-style:italic">// 关闭通道，内存遍历循环立即结束
</span><span style="color:#999;font-style:italic"></span>
	time.<span style="color:#447fcf">Sleep</span>(time.Second) <span style="color:#999;font-style:italic">// 假设主程序 1 秒后退出
</span><span style="color:#999;font-style:italic"></span>}

<span style="color:#999;font-style:italic">// $ go run main.go
</span><span style="color:#999;font-style:italic">// 输出如下
</span><span style="color:#999;font-style:italic"></span><span style="color:#999;font-style:italic">/**
</span><span style="color:#999;font-style:italic">  range broken
</span><span style="color:#999;font-style:italic">  goroutine ending
</span><span style="color:#999;font-style:italic">*/</span>
</code></pre></div><h4 id="遍历缓冲并且未关闭的通道">遍历缓冲并且未关闭的通道</h4>
<p><strong>错误的做法</strong></p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {
	ch := <span style="color:#24909d">make</span>(<span style="color:#6ab825;font-weight:bold">chan</span> <span style="color:#6ab825;font-weight:bold">bool</span>, <span style="color:#3677a9">3</span>)

	<span style="color:#6ab825;font-weight:bold">go</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
		<span style="color:#6ab825;font-weight:bold">defer</span> <span style="color:#6ab825;font-weight:bold">func</span>() { <span style="color:#999;font-style:italic">// defer 不会执行
</span><span style="color:#999;font-style:italic"></span>			fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;goroutine ending&#34;</span>) <span style="color:#999;font-style:italic">// 不会输出
</span><span style="color:#999;font-style:italic"></span>		}()

		<span style="color:#6ab825;font-weight:bold">for</span> v := <span style="color:#6ab825;font-weight:bold">range</span> ch {
			fmt.<span style="color:#447fcf">Println</span>(v)
		}

		fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;range broken&#34;</span>) <span style="color:#999;font-style:italic">// 执行不到这里
</span><span style="color:#999;font-style:italic"></span>	}()

	ch &lt;- <span style="color:#6ab825;font-weight:bold">true</span>
	ch &lt;- <span style="color:#6ab825;font-weight:bold">false</span>
	ch &lt;- <span style="color:#6ab825;font-weight:bold">true</span>

	time.<span style="color:#447fcf">Sleep</span>(time.Second) <span style="color:#999;font-style:italic">// 假设主程序 1 秒后退出
</span><span style="color:#999;font-style:italic"></span>}

<span style="color:#999;font-style:italic">// $ go run main.go
</span><span style="color:#999;font-style:italic">// 输出如下
</span><span style="color:#999;font-style:italic"></span><span style="color:#999;font-style:italic">/**
</span><span style="color:#999;font-style:italic">  true
</span><span style="color:#999;font-style:italic">  false
</span><span style="color:#999;font-style:italic">  true
</span><span style="color:#999;font-style:italic">  // 接收完缓冲区的 3 个值后, 后面不再有任何输出，goroutine 泄漏
</span><span style="color:#999;font-style:italic">*/</span>
</code></pre></div><p><strong>正确的做法</strong></p>
<p>参照最佳实践，对代码进行以下调整: 在 <code>goroutine</code> 外部关闭通道，防止 <code>goroutine</code> 内部遍历陷入无限阻塞。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {
	ch := <span style="color:#24909d">make</span>(<span style="color:#6ab825;font-weight:bold">chan</span> <span style="color:#6ab825;font-weight:bold">bool</span>)

	<span style="color:#6ab825;font-weight:bold">go</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
		<span style="color:#6ab825;font-weight:bold">defer</span> <span style="color:#6ab825;font-weight:bold">func</span>() { <span style="color:#999;font-style:italic">// defer 正常执行
</span><span style="color:#999;font-style:italic"></span>			fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;goroutine ending&#34;</span>) <span style="color:#999;font-style:italic">// 正常输出
</span><span style="color:#999;font-style:italic"></span>		}()

		<span style="color:#6ab825;font-weight:bold">for</span> v := <span style="color:#6ab825;font-weight:bold">range</span> ch { <span style="color:#999;font-style:italic">// 外部关闭通道后，for 循环结束
</span><span style="color:#999;font-style:italic"></span>			fmt.<span style="color:#447fcf">Println</span>(v) <span style="color:#999;font-style:italic">// 不会输出
</span><span style="color:#999;font-style:italic"></span>		}

		fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;range broken&#34;</span>) <span style="color:#999;font-style:italic">// 可以执行到这里
</span><span style="color:#999;font-style:italic"></span>	}()

	<span style="color:#24909d">close</span>(ch) <span style="color:#999;font-style:italic">// 关闭通道，内存遍历循环立即结束
</span><span style="color:#999;font-style:italic"></span>
	time.<span style="color:#447fcf">Sleep</span>(time.Second) <span style="color:#999;font-style:italic">// 假设主程序 1 秒后退出
</span><span style="color:#999;font-style:italic"></span>}

<span style="color:#999;font-style:italic">// $ go run main.go
</span><span style="color:#999;font-style:italic">// 输出如下
</span><span style="color:#999;font-style:italic"></span><span style="color:#999;font-style:italic">/**
</span><span style="color:#999;font-style:italic">  true
</span><span style="color:#999;font-style:italic">  false
</span><span style="color:#999;font-style:italic">  true
</span><span style="color:#999;font-style:italic">  range broken
</span><span style="color:#999;font-style:italic">  goroutine ending
</span><span style="color:#999;font-style:italic">*/</span>
</code></pre></div><h3 id="发送接收-不同步">发送/接收 不同步</h3>
<h4 id="只有发送者没有接收者">只有发送者，没有接收者</h4>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {
	ch := <span style="color:#24909d">make</span>(<span style="color:#6ab825;font-weight:bold">chan</span> <span style="color:#6ab825;font-weight:bold">bool</span>)

	<span style="color:#6ab825;font-weight:bold">go</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
		ch &lt;- <span style="color:#6ab825;font-weight:bold">true</span>
	}()
}
</code></pre></div><h4 id="只有接收者没有发送者">只有接收者，没有发送者</h4>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {
	ch := <span style="color:#24909d">make</span>(<span style="color:#6ab825;font-weight:bold">chan</span> <span style="color:#6ab825;font-weight:bold">bool</span>)

	<span style="color:#6ab825;font-weight:bold">go</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
		&lt;-ch
	}()
}
</code></pre></div><h3 id="资源无法释放">资源无法释放</h3>
<p>如果 <code>goroutine</code> 内的引用的资源长时间无法被释放，也会导致 <code>goroutine 泄漏</code>，典型的场景如 <code>加锁/解锁 未同步、网络访问超时、写入大文件、数据库读写产生死锁</code> 等。</p>
<h4 id="互斥锁">互斥锁</h4>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {
	<span style="color:#6ab825;font-weight:bold">var</span> mu sync.Mutex

	<span style="color:#6ab825;font-weight:bold">go</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
		mu.<span style="color:#447fcf">Lock</span>()
	}()
	
	time.<span style="color:#447fcf">Sleep</span>(time.Second)

	<span style="color:#6ab825;font-weight:bold">go</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
		mu.<span style="color:#447fcf">Lock</span>()
	}()
}
</code></pre></div><p>上述代码中，第一个 <code>goroutine</code> 加锁后并没有对应的解锁操作，导致第二个 <code>goroutine</code> 阻塞在加锁操作，发生泄漏。</p>
<p><strong>通用的的工程实践是: 加锁操作完成后使用 <code>defer</code> 注册对应的解锁操作</strong>。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {
	<span style="color:#6ab825;font-weight:bold">var</span> mu sync.Mutex

	<span style="color:#6ab825;font-weight:bold">go</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
		mu.<span style="color:#447fcf">Lock</span>()
		<span style="color:#6ab825;font-weight:bold">defer</span> mu.<span style="color:#447fcf">Unlock</span>()
	}()

	time.<span style="color:#447fcf">Sleep</span>(time.Second)

	<span style="color:#6ab825;font-weight:bold">go</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
		mu.<span style="color:#447fcf">Lock</span>()
		<span style="color:#6ab825;font-weight:bold">defer</span> mu.<span style="color:#447fcf">Unlock</span>()
	}()
}
</code></pre></div><h4 id="标准库-httpclient">标准库 http.Client</h4>
<p>标准库中的 <code>http.Client</code> 对象默认没有超时时间限制，如果我们直接调用的情况下，很可能发生死锁:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">http.<span style="color:#447fcf">Get</span>(<span style="color:#ed9d13">&#34;https://go.dev&#34;</span>)
</code></pre></div><p>正确的调用方法是: 创建对象时就设置超时时间:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">client := http.Client{
    Timeout: <span style="color:#3677a9">3</span> * time.Second,
}
client.<span style="color:#447fcf">Get</span>(<span style="color:#ed9d13">&#34;https://go.dev&#34;</span>)
</code></pre></div><h3 id="main-函数">main 函数</h3>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {
    <span style="color:#6ab825;font-weight:bold">go</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
        time.<span style="color:#447fcf">Sleep</span>(<span style="color:#3677a9">100</span> * time.Millisecond) <span style="color:#999;font-style:italic">// 模拟耗时操作
</span><span style="color:#999;font-style:italic"></span>    }()
}
</code></pre></div><p><code>main</code> 函数结束时不会考虑当前是否还有 <code>goroutine</code> 正在执行，上面的代码中， <code>main</code> 函数退出后，<code>goroutine</code> 发生泄漏。</p>
<p><strong>通用的的工程实践是: 使用同步原语保证 <code>main</code> 程序结束前所有 <code>goroutine</code> 正常退出</strong>。</p>
<h3 id="osexit-方法">os.Exit 方法</h3>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {
	<span style="color:#6ab825;font-weight:bold">go</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
		time.<span style="color:#447fcf">Sleep</span>(<span style="color:#3677a9">1</span> * time.Second) <span style="color:#999;font-style:italic">// 模拟耗时操作
</span><span style="color:#999;font-style:italic"></span>	}()

	<span style="color:#6ab825;font-weight:bold">go</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
		os.<span style="color:#447fcf">Exit</span>(<span style="color:#3677a9">1</span>)
	}()

	time.<span style="color:#447fcf">Sleep</span>(<span style="color:#3677a9">100</span> * time.Millisecond)
}
</code></pre></div><p><code>os.Exit</code> 方法会直接结束程序，不会考虑当前是否还有 <code>goroutine</code> 正在执行，所以调用前要考虑后台运行的 <code>goroutine</code> 情况。</p>
<h2 id="最佳实践">最佳实践</h2>
<p>通过上面的这些例子，我们可以看到 <code>goroutine 泄漏</code> 的大部分场景是因为对 <code>channel</code> 的错误使用而导致的。</p>
<p>针对上面的问题，我们来总结一下 <code>goroutine</code> 的应用最佳实践。</p>
<h3 id="异步调用方法的选择权交给调用方">异步调用方法的选择权交给调用方</h3>
<ul>
<li>调用方可能并不知道方法内部使用了 <code>goroutine</code>, 所以是否需要异步由调用方来决定</li>
<li>对于异步调用的方法，要设置自动退出机制，比如 <code>信号</code>, <code>超时控制</code> 等</li>
</ul>
<h3 id="启动一个-goroutine-时">启动一个 goroutine 时</h3>
<ul>
<li>永远不要启动无法控制退出的 <code>goroutine</code></li>
<li>永远不要启动无法确定何时退出的 <code>goroutine</code></li>
<li>启动 <code>goroutine</code> 时实现 <code>panic recovery</code> 机制，避免服务内部错误导致的不可用</li>
<li>尽量避免在请求中直接启动 <code>goroutine</code>, 应该通过类似 <code>生产者/消费者</code> 模式处理，可以避免流量突增时创建大量 <code>goroutine</code> 导致的 <code>OOM</code></li>
<li>将 <code>goroutine</code> 设计为只能通过 <code>channel</code> 通信退出</li>
</ul>
<h3 id="为什么-goroutine-不能被-kill-">为什么 goroutine 不能被 kill ?</h3>
<p><code>kill</code> 一个 <code>goroutine</code> 在底层设计上存在很多挑战，例如:</p>
<ul>
<li>当前 goroutine 持有的资源如何处理？</li>
<li>堆栈如何处理？</li>
<li>defer 语句还需要执行么？</li>
<li>如果允许 defer 语句执行，但是 defer 语句可能阻塞 goroutine 退出 (形成死循环)，这种场景如何处理？</li>
</ul>
<h2 id="goroutine-泄漏检测">goroutine 泄漏检测</h2>
<p>针对上面提到的各种问题，是否可以实现一个 <code>goroutine 泄漏检测</code> 功能，如果可以的话，如何实现这个功能呢？</p>
<p>如果手动从零开始实现一个 <code>goroutine 泄漏检测</code> 功能，最简单直观的办法是抓取多次 <code>stacktrace</code>，解析出所有的 <code>goroutine ID</code> 对比差异，最终多出来的部分就是泄漏的 <code>goroutine</code>。</p>
<p>开源的组件会如何实现这个功能呢？我们找一个成熟的开源组件一起来学习下，毕竟站在巨人的肩膀上可以看的更远。</p>
<h2 id="goleak-组件">goleak 组件</h2>
<p>笔者选择由 <code>Uber</code> 开源的 <a href="https://github.com/uber-go/goleak">goleak</a> 作为研究 <code>goroutine 泄漏检测</code> 代码实现，版本为 <code>v1.2.1</code>。</p>
<h3 id="示例代码">示例代码</h3>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">package</span> main

<span style="color:#6ab825;font-weight:bold">import</span> (
	<span style="color:#ed9d13">&#34;testing&#34;</span>

	<span style="color:#ed9d13">&#34;go.uber.org/goleak&#34;</span>
)

<span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">TestGoroutineLeak</span>(t *testing.T) {
	<span style="color:#6ab825;font-weight:bold">defer</span> goleak.<span style="color:#447fcf">VerifyNone</span>(t)

	ch := <span style="color:#24909d">make</span>(<span style="color:#6ab825;font-weight:bold">chan</span> <span style="color:#6ab825;font-weight:bold">int</span>)

	<span style="color:#6ab825;font-weight:bold">go</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
		_ = &lt;-ch                                      <span style="color:#999;font-style:italic">// goroutine 阻塞造成的泄漏
</span><span style="color:#999;font-style:italic"></span>		t.<span style="color:#447fcf">Error</span>(<span style="color:#ed9d13">&#34;It&#39;s not going to be executed here&#34;</span>) <span style="color:#999;font-style:italic">// 代码不会执行到这里
</span><span style="color:#999;font-style:italic"></span>	}()
}
</code></pre></div><p>测试失败，输出泄漏的 <code>goroutine</code> 信息:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ go <span style="color:#24909d">test</span> -v -count=<span style="color:#3677a9">1</span> -run=<span style="color:#ed9d13">&#39;TestGoroutineLeak&#39;</span> .

<span style="color:#999;font-style:italic"># 输出如下</span>
=== RUN   TestGoroutineLeak
    main_test.go:18: found unexpected goroutines:
        [Goroutine <span style="color:#3677a9">21</span> in state chan receive, with test.TestGoroutineLeak.func1 on top of the stack:
        goroutine <span style="color:#3677a9">21</span> [chan receive]:
        ...
        ...
--- FAIL: TestGoroutineLeak (0.47s)
FAIL
</code></pre></div><h2 id="goleak-源代码">goleak 源代码</h2>
<h3 id="配置对象">配置对象</h3>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#999;font-style:italic">// 默认检测次数为 20 次
</span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">const</span> _defaultRetries = <span style="color:#3677a9">20</span>

<span style="color:#6ab825;font-weight:bold">type</span> opts <span style="color:#6ab825;font-weight:bold">struct</span> {
	filters    []<span style="color:#6ab825;font-weight:bold">func</span>(stack.Stack) <span style="color:#6ab825;font-weight:bold">bool</span> <span style="color:#999;font-style:italic">// 过滤函数 (用来自定义过滤 goroutine)
</span><span style="color:#999;font-style:italic"></span>	maxRetries <span style="color:#6ab825;font-weight:bold">int</span>                      <span style="color:#999;font-style:italic">// 最大检测次数
</span><span style="color:#999;font-style:italic"></span>	maxSleep   time.Duration            <span style="color:#999;font-style:italic">// 最长休眠时间 (默认 100 ms)
</span><span style="color:#999;font-style:italic"></span>	cleanup    <span style="color:#6ab825;font-weight:bold">func</span>(<span style="color:#6ab825;font-weight:bold">int</span>)                <span style="color:#999;font-style:italic">// 清理函数 (检测结束时调用)
</span><span style="color:#999;font-style:italic"></span>}
</code></pre></div><h3 id="创建检测配置对象">创建检测配置对象</h3>
<p><code>buildOpts</code> 函数通过经典的 <code>FUNCTIONAL OPTIONS</code> 模式创建一个 <code>检测对象</code>。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">buildOpts</span>(options ...Option) *opts {
	opts := &amp;opts{
		maxRetries: _defaultRetries,        <span style="color:#999;font-style:italic">// 默认最大检测次数 20 次
</span><span style="color:#999;font-style:italic"></span>		maxSleep:   <span style="color:#3677a9">100</span> * time.Millisecond, <span style="color:#999;font-style:italic">// 默认最长休眠时间 100 ms
</span><span style="color:#999;font-style:italic"></span>	}
	
	<span style="color:#999;font-style:italic">// 过滤掉 4 种调用栈信息
</span><span style="color:#999;font-style:italic"></span>	opts.filters = <span style="color:#24909d">append</span>(opts.filters,
		isTestStack,
		isSyscallStack,
		isStdLibStack,
		isTraceStack,
	)
	<span style="color:#6ab825;font-weight:bold">for</span> _, option := <span style="color:#6ab825;font-weight:bold">range</span> options {
		option.<span style="color:#447fcf">apply</span>(opts)
	}
	<span style="color:#6ab825;font-weight:bold">return</span> opts
}
</code></pre></div><p><img src="https://dbwu.tech/images/goleak_opts.png" alt="配置对象"></p>
<h3 id="检测单个测试用例">检测单个测试用例</h3>
<p><code>VerifyNone</code> 函数检测单个测试用例是否发生 <code>goroutine</code> 泄漏，常规用法是在测试用例函数中注册 <code>defer</code> 并调用检测函数，如 <code>defer VerifyNone(t)</code>。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">VerifyNone</span>(t TestingT, options ...Option) {
    <span style="color:#999;font-style:italic">// 创建检测配置对象
</span><span style="color:#999;font-style:italic"></span>	opts := <span style="color:#447fcf">buildOpts</span>(options...)             
	<span style="color:#6ab825;font-weight:bold">var</span> cleanup <span style="color:#6ab825;font-weight:bold">func</span>(<span style="color:#6ab825;font-weight:bold">int</span>)
    <span style="color:#999;font-style:italic">// 重置清理函数
</span><span style="color:#999;font-style:italic"></span>	cleanup, opts.cleanup = opts.cleanup, <span style="color:#6ab825;font-weight:bold">nil</span> 

	...

	<span style="color:#6ab825;font-weight:bold">if</span> err := <span style="color:#447fcf">Find</span>(opts); err != <span style="color:#6ab825;font-weight:bold">nil</span> {
        <span style="color:#999;font-style:italic">// 如果检测到 goroutine 泄漏, 直接报错
</span><span style="color:#999;font-style:italic"></span>		t.<span style="color:#447fcf">Error</span>(err)    
	}

	<span style="color:#6ab825;font-weight:bold">if</span> cleanup != <span style="color:#6ab825;font-weight:bold">nil</span> {
        <span style="color:#999;font-style:italic">// 如果没有检测到 goroutine 泄漏, 执行清理函数
</span><span style="color:#999;font-style:italic"></span>		<span style="color:#447fcf">cleanup</span>(<span style="color:#3677a9">0</span>)  
	}
}
</code></pre></div><h3 id="检测-goroutine-泄漏">检测 goroutine 泄漏</h3>
<p><code>Find</code> 函数根据配置信息，查找泄漏的 <code>goroutine</code> 并返回对应的错误信息。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">Find</span>(options ...Option) <span style="color:#6ab825;font-weight:bold">error</span> {
	<span style="color:#999;font-style:italic">// 当前执行检测的 goroutine ID
</span><span style="color:#999;font-style:italic"></span>	cur := stack.<span style="color:#447fcf">Current</span>().<span style="color:#447fcf">ID</span>()

    <span style="color:#999;font-style:italic">// 创建检测配置对象
</span><span style="color:#999;font-style:italic"></span>	opts := <span style="color:#447fcf">buildOpts</span>(options...)   

	...
	
	<span style="color:#6ab825;font-weight:bold">var</span> stacks []stack.Stack
	retry := <span style="color:#6ab825;font-weight:bold">true</span>
	<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#3677a9">0</span>; retry; i++ {
		<span style="color:#999;font-style:italic">// 获取所有 goroutine
</span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 然后过滤掉当前执行检测的 goroutine 和符合过滤条件的 goroutine
</span><span style="color:#999;font-style:italic"></span>		stacks = <span style="color:#447fcf">filterStacks</span>(stack.<span style="color:#447fcf">All</span>(), cur, opts)

		<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#24909d">len</span>(stacks) == <span style="color:#3677a9">0</span> {
			<span style="color:#999;font-style:italic">// 如果没有 goroutine 了
</span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 说明所有的 goroutine 均已正常退出，直接返回即可
</span><span style="color:#999;font-style:italic"></span>			<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">nil</span>
		}
		
		<span style="color:#999;font-style:italic">// 如果还有运行中的 goroutine，则休眠一会，继续检测
</span><span style="color:#999;font-style:italic"></span>		retry = opts.<span style="color:#447fcf">retry</span>(i)
	}

	<span style="color:#999;font-style:italic">// 代码执行到这里
</span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 说明还有 goroutine 未退出，返回对应的 goroutine 信息
</span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">return</span> fmt.<span style="color:#447fcf">Errorf</span>(<span style="color:#ed9d13">&#34;found unexpected goroutines:\n%s&#34;</span>, stacks)
}
</code></pre></div><h3 id="goroutine-过滤">goroutine 过滤</h3>
<p><code>filterStacks</code> 函数过滤掉符合条件的 <code>goroutine</code> 。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">filterStacks</span>(stacks []stack.Stack, skipID <span style="color:#6ab825;font-weight:bold">int</span>, opts *opts) []stack.Stack {
	<span style="color:#999;font-style:italic">// 高性能 Tips: 切片数据复用
</span><span style="color:#999;font-style:italic"></span>	filtered := stacks[:<span style="color:#3677a9">0</span>]
	<span style="color:#6ab825;font-weight:bold">for</span> _, stack := <span style="color:#6ab825;font-weight:bold">range</span> stacks {
		<span style="color:#999;font-style:italic">// 过滤掉当前执行检测的 goroutine
</span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> stack.<span style="color:#447fcf">ID</span>() == skipID {
			<span style="color:#6ab825;font-weight:bold">continue</span>
		}
		<span style="color:#999;font-style:italic">// 过滤掉符合配置中过滤函数的 goroutine
</span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> opts.<span style="color:#447fcf">filter</span>(stack) {
			<span style="color:#6ab825;font-weight:bold">continue</span>
		}
		filtered = <span style="color:#24909d">append</span>(filtered, stack)
	}
	<span style="color:#6ab825;font-weight:bold">return</span> filtered
}
</code></pre></div><h2 id="小结">小结</h2>
<p>通过对源代码的分析，我们可以得出 <code>goleak</code> 组件的实现原理: <strong>定时获取所有 <code>goroutine</code> 并且进行过滤，达到最大检测次数后，最终过滤剩下的 <code>goroutine</code> 就被判定为泄漏</strong>。</p>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://github.com/uber-go/goleak">uber-go/goleak</a></li>
<li><a href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html">Goroutine Leaks - The Forgotten Sender</a></li>
<li><a href="https://github.com/golang/go/issues/32610">is it possible to a goroutine immediately stop another goroutine? </a></li>
</ul>
<h2 id="扩展阅读">扩展阅读</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/HdSIC93HMbqvbQisCr186Q">从真实事故出发：golang 内存问题排查指北</a></li>
</ul>


</article>

<article>
    <img src="https://dbwu.tech/images/wechat.png">
</article>

<article>
    <h3>转载申请</h3>

    <p>
        本作品采用 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> 进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，商业转载请联系作者获得授权。
    </p>
</article>

<section class="post-nav">
    <ul>
        <li>
        
            <a href="https://dbwu.tech/posts/golang_timer/"><i class="fa fa-chevron-circle-left"></i> time/Timer Code Review</a>
        
        </li>
        <li>
        
            <a href="https://dbwu.tech/posts/golang_netpoll/">Go netpoll Code Review <i class="fa fa-chevron-circle-right"></i> </a>
        
        </li>
    </ul>
</section>
  
    
    
  


<script src="https://giscus.app/client.js"
        data-repo="duanbiaowu/dbwu.tech"
        data-repo-id="R_kgDOIkkjjw"
        data-category="Announcements"
        data-category-id="DIC_kwDOIkkjj84CV78j"
        data-mapping="specific"
        data-term="goroutine 泄漏与检测"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous" async>
</script>




</main>
    <footer>
        <ul>
            <li>
                <h6><a href="mailto:codean.net@gmail.com">codean.net@gmail.com</a> | 
                    <img src="https://dbwu.tech/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" />
                    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61011302001681" target="_blank">陕公网安备 61011302001681 号</a> |
                    <a href="https://beian.miit.gov.cn" target="_blank">陕ICP备2023004378号-1</a> |
                    Rendered by <a href="https://themes.gohugo.io" title="Hugo" target="_blank">Hugo</a>
                </h6>
            </li>
            
            
        </ul>
    </footer>
</div>
<script src="https://dbwu.tech/js/scripts.js"></script>


</body>

</html>

