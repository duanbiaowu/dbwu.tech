<!doctype html>

<html lang="en">

<head>
  <title>Go channel 的 15 条规则和底层实现 - 蛮荆</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="Go 语言中 channel 发送、接收、关闭规则都有哪些？底层又是如何实现的呢？" />
<meta name="author" content="" />
<link rel="shortcut icon" href="https://dbwu.tech/favicon.ico" type="image/x-icon" /><meta property="og:title" content="Go channel 的 15 条规则和底层实现" />
<meta property="og:description" content="Go 语言中 channel 发送、接收、关闭规则都有哪些？底层又是如何实现的呢？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dbwu.tech/posts/golang_channel/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-08T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-06-08T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go channel 的 15 条规则和底层实现"/>
<meta name="twitter:description" content="Go 语言中 channel 发送、接收、关闭规则都有哪些？底层又是如何实现的呢？"/>

<meta name="generator" content="Hugo 0.113.0">
    
    <script src="https://dbwu.tech/js/mathjax-config.js" defer></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CZMGTTFLNY"></script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3261056100776781" crossorigin="anonymous"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-CZMGTTFLNY');
  </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>


  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/normalize.min.css" />
  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/all.min.css" />
  
    
    <link href="//fonts.googleapis.com/css?family=Staatliches" rel="stylesheet">
  
  
  <link rel="stylesheet" type="text/css" href="https://dbwu.tech/css/styles-light.css" />
  </head>

<body>
  <div id="container">
    <header>
      
      <h1>
        <a href="https://dbwu.tech/">蛮荆</a>
      </h1>

      <ul id="social-media">
      </ul>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="active" href="https://dbwu.tech/posts/">
                <i class="fa-li fa  fa-lg"></i><span>归档</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/tags/">
                <i class="fa-li fa  fa-lg"></i><span>标签</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://github.com/duanbiaowu">
                <i class="fa-li fa  fa-lg"></i><span>Github</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/index.xml">
                <i class="fa-li fa  fa-lg"></i><span>RSS</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<article>

    <h1>Go channel 的 15 条规则和底层实现</h1>

    
      
<p>
    <span>2023-06-08</span>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/golang">Golang</a>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">并发编程</a>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/go-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Go 源码分析</a>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/%E8%AF%BB%E4%BB%A3%E7%A0%81">读代码</a>
    
</p>

    

    
      

    

    <h2 id="概述">概述</h2>
<p>下面表格中的内容是 Go 语言中 <code>channel</code> 数据类型的使用规则，相信读者已经可以熟练掌握，本文主要分析 <code>channel</code> 的内部实现中的数据结构和算法，所以相关的基础概念会直接跳过，
希望读者阅读完本文后，可以深入理解表格中的各类规则，从应用层代码到底层实现，能够知其然并知其所以然。</p>
<h3 id="操作规则">操作规则</h3>
<table>
<thead>
<tr>
<th style="text-align:center">操作     </th>
<th style="text-align:center">nil     </th>
<th style="text-align:left">已关闭 channel</th>
<th style="text-align:left">未关闭有缓冲区的 channel</th>
<th style="text-align:left">未关闭无缓冲区的 channel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">关闭</td>
<td style="text-align:center">panic</td>
<td style="text-align:left">panic</td>
<td style="text-align:left">成功关闭，然后可以读取缓冲区的值，读取完之后，继续读取到的是 channel 类型的默认值</td>
<td style="text-align:left">成功关闭，之后读取到的是 channel 类型的默认值</td>
</tr>
<tr>
<td style="text-align:center">接收</td>
<td style="text-align:center">阻塞</td>
<td style="text-align:left">不阻塞，读取到的是 channel 类型的默认值</td>
<td style="text-align:left">不阻塞，正常读取值</td>
<td style="text-align:left">阻塞</td>
</tr>
<tr>
<td style="text-align:center">发送</td>
<td style="text-align:center">阻塞</td>
<td style="text-align:left">panic</td>
<td style="text-align:left">不阻塞，正常写入值</td>
<td style="text-align:left">阻塞</td>
</tr>
</tbody>
</table>
<h3 id="编译规则">编译规则</h3>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">接收</td>
<td style="text-align:left">只写 channel</td>
<td style="text-align:left">编译错误</td>
</tr>
<tr>
<td style="text-align:left">发送</td>
<td style="text-align:left">只读 channel</td>
<td style="text-align:left">编译错误</td>
</tr>
<tr>
<td style="text-align:left">关闭</td>
<td style="text-align:left">只读 channel</td>
<td style="text-align:left">编译错误</td>
</tr>
</tbody>
</table>
<p><code>channel</code> 的内部实现文件路径为 <code>$GOROOT/src/runtime/chan.go</code>，笔者的 Go 版本为 <code>go1.19 linux/amd64</code>。</p>
<h2 id="几个常量">几个常量</h2>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">const</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 内存对齐的最大值，这个等于 64 位 CPU 下的 cacheline 的大小
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	maxAlign  = <span style="color:#3677a9">8</span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 计算 unsafe.Sizeof(hchan{})  最接近的 8 的倍数
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	hchanSize = unsafe.<span style="color:#447fcf">Sizeof</span>(hchan{}) + <span style="color:#24909d">uintptr</span>(-<span style="color:#24909d">int</span>(unsafe.<span style="color:#447fcf">Sizeof</span>(hchan{}))&amp;(maxAlign-<span style="color:#3677a9">1</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 是否开启 debug 模式
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	debugChan = <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><h2 id="hchan-对象">hchan 对象</h2>
<p><code>hchan</code> 对象表示运行时的 <code>channel</code>。</p>
<p>对于无缓冲 <code>channel</code> 来说，发送队列和接收队列至少有一个为空，一个无缓冲 <code>channel</code> 和一个阻塞在该 <code>channel</code> 上面的 <code>goroutine</code>，使用 <code>select</code> 语句发送和接收。</p>
<p>对于有缓冲 <code>channel</code> 来说，<code>qcount &gt; 0</code> 意味着接收队列为空，<code>qcount &lt; dataqsiz</code> 意味着发送队列为空。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">type</span> hchan <span style="color:#6ab825;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	qcount   <span style="color:#6ab825;font-weight:bold">uint</span>           <span style="color:#999;font-style:italic">// channel 元素数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	dataqsiz <span style="color:#6ab825;font-weight:bold">uint</span>           <span style="color:#999;font-style:italic">// channel 缓冲区环形队列长度
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	buf      unsafe.Pointer <span style="color:#999;font-style:italic">// 指向缓冲区的底层数组 (针对有缓冲的 channel)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	elemsize <span style="color:#6ab825;font-weight:bold">uint16</span>         <span style="color:#999;font-style:italic">// channel 元素大小
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	closed   <span style="color:#6ab825;font-weight:bold">uint32</span>         <span style="color:#999;font-style:italic">// 是否关闭
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	elemtype *_type         <span style="color:#999;font-style:italic">// channel 元素类型
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	sendx    <span style="color:#6ab825;font-weight:bold">uint</span>           <span style="color:#999;font-style:italic">// 当前已发送元素在队列中的索引
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	recvx    <span style="color:#6ab825;font-weight:bold">uint</span>           <span style="color:#999;font-style:italic">// 当前已接收元素在队列中的索引
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	recvq    waitq          <span style="color:#999;font-style:italic">// 接收 goroutine 队列 (数据结构是链表)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	sendq    waitq          <span style="color:#999;font-style:italic">// 发送 goroutine 队列 (数据结构是链表)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// lock 保护结构体中的所有字段，以及 sudogs 对象中被当前 channel 阻塞的几个字段
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 不要在持有锁时修改另一个 goroutine 的状态（特别是没有进入 ready 状态的 goroutine）
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 因为这会导致栈收缩而发生死锁
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	lock mutex
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/hchan.png" alt="channel 运行时结构体"></p>
<p>上面的图片展示了一个典型的 <code>channel</code> 数据结构图，其中各元素表示为:</p>
<ul>
<li>缓冲区环形队列长度为 8, 也就是最多可以存放 8 个数据</li>
<li>发送索引指向 7，接收索引指向 0，说明当前缓存队列已满，无法再放入数据了，此时新的发送/接收 <code>goroutine</code> 会进入发送/接收队列</li>
<li>发送队列中有 3 个 <code>goroutine</code> 等待发送</li>
<li>接收队列中有 5 个 <code>goroutine</code> 等待接收</li>
</ul>
<h2 id="waitq-对象">waitq 对象</h2>
<p><code>waitq</code> 对象表示因为 <code>channel</code> 缓冲区空间不足而陷入等待的 <code>goroutine</code> 发送/接收队列, 数据结构是双向链表，其中头节点和尾节点都是 <code>sudog</code> 对象，
<code>sudog</code> 对象的字段和具体作用在之前的 <code>GMP 调度器 - 数据结构</code> 一文中已经讲过，这里不再赘述。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">type</span> waitq <span style="color:#6ab825;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	first *sudog
</span></span><span style="display:flex;"><span>	last  *sudog
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>读者可以停下来思考一个问题: 同一个 goroutine 有可能同时出现在发送队列和接收队列吗？为什么？</p>
</blockquote>
<h2 id="创建-channel">创建 channel</h2>
<p>编译器会将应用层代码中的 <code>make(chan type, N)</code> 语句转换为 <code>makechan</code> 函数调用。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">makechan</span>(t *chantype, size <span style="color:#6ab825;font-weight:bold">int</span>) *hchan {
</span></span><span style="display:flex;"><span>	elem := t.elem
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 由编译器检查保证元素大小不能大于等于 64K
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> elem.size &gt;= <span style="color:#3677a9">1</span>&lt;&lt;<span style="color:#3677a9">16</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#447fcf">throw</span>(<span style="color:#ed9d13">&#34;makechan: invalid channel element type&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 检测 hchan 结构体大小是否是 maxAlign 的整数倍
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 并且元素的对齐单位不能超过最大对齐单位
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> hchanSize%maxAlign != <span style="color:#3677a9">0</span> || elem.align &gt; maxAlign {
</span></span><span style="display:flex;"><span>		<span style="color:#447fcf">throw</span>(<span style="color:#ed9d13">&#34;makechan: bad alignment&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 检测内存是否超过限制
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	mem, overflow := math.<span style="color:#447fcf">MulUintptr</span>(elem.size, <span style="color:#24909d">uintptr</span>(size))
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#24909d">panic</span>(<span style="color:#447fcf">plainError</span>(<span style="color:#ed9d13">&#34;makechan: size out of range&#34;</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 当存储在 buf 中的元素不包含指针时，可以消除 GC 扫描
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">var</span> c *hchan
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">switch</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">case</span> mem == <span style="color:#3677a9">0</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 如果是无缓冲 channel
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 仅为 hchan 分配内存空间
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		c = (*hchan)(<span style="color:#447fcf">mallocgc</span>(hchanSize, <span style="color:#6ab825;font-weight:bold">nil</span>, <span style="color:#6ab825;font-weight:bold">true</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// data race detector 使用当前作为检测点进行同步
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		c.buf = c.<span style="color:#447fcf">raceaddr</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">case</span> elem.ptrdata == <span style="color:#3677a9">0</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 如果 channel 中的元素不包含指针
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 为 hchan 结构体和 buf 字段分配一段连续的内存空间
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		c = (*hchan)(<span style="color:#447fcf">mallocgc</span>(hchanSize+mem, <span style="color:#6ab825;font-weight:bold">nil</span>, <span style="color:#6ab825;font-weight:bold">true</span>))
</span></span><span style="display:flex;"><span>		c.buf = <span style="color:#447fcf">add</span>(unsafe.<span style="color:#447fcf">Pointer</span>(c), hchanSize)
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">default</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 如果 channel 中的元素包含指针
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 分别为 hchan 结构体和 buf 字段单独分配内存空间
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		c = <span style="color:#24909d">new</span>(hchan)
</span></span><span style="display:flex;"><span>		c.buf = <span style="color:#447fcf">mallocgc</span>(mem, elem, <span style="color:#6ab825;font-weight:bold">true</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 设置 channel 元素大小
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	c.elemsize = <span style="color:#24909d">uint16</span>(elem.size)
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 设置 channel 元素类型
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	c.elemtype = elem
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 设置 channel 缓冲区长度
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	c.dataqsiz = <span style="color:#24909d">uint</span>(size)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> debugChan {
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 如果开启了 debug 模式
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 打印初始化信息
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#24909d">print</span>(<span style="color:#ed9d13">&#34;makechan: chan=&#34;</span>, c, <span style="color:#ed9d13">&#34;; elemsize=&#34;</span>, elem.size, <span style="color:#ed9d13">&#34;; dataqsiz=&#34;</span>, size, <span style="color:#ed9d13">&#34;\n&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> c
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="发送数据">发送数据</h2>
<h3 id="chansend-方法">chansend 方法</h3>
<p>编译器会将应用层代码中的 <code>c &lt;- x</code> 语句转换为 <code>chansend1</code> 函数调用。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">//go:nosplit
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">chansend1</span>(c *hchan, elem unsafe.Pointer) {
</span></span><span style="display:flex;"><span>	<span style="color:#447fcf">chansend</span>(c, elem, <span style="color:#6ab825;font-weight:bold">true</span>, <span style="color:#447fcf">getcallerpc</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 编译器将
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//	select {
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//	case c &lt;- v:
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//		... foo
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//	default:
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//		... bar
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//	}
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 转换为
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//	if selectnbsend(c, v) {
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//		... foo
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//	} else {
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//		... bar
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//	}
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">selectnbsend</span>(c *hchan, elem unsafe.Pointer) (selected <span style="color:#6ab825;font-weight:bold">bool</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#447fcf">chansend</span>(c, elem, <span style="color:#6ab825;font-weight:bold">false</span>, <span style="color:#447fcf">getcallerpc</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>chansend1</code> 和 <code>selectnbsend</code> 函数内部调用的都是 <code>chansend</code> 函数, <code>chansend</code> 函数向 <code>channel</code> 发送数据，并且返回是否发送成功。</p>
<p><code>chansend</code> 函数内部的 <code>channel</code> 处理逻辑分为两种:</p>
<ol>
<li><strong>阻塞发送</strong></li>
<li><strong>非阻塞发送</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">chansend</span>(c *hchan, ep unsafe.Pointer, block <span style="color:#6ab825;font-weight:bold">bool</span>, callerpc <span style="color:#6ab825;font-weight:bold">uintptr</span>) <span style="color:#6ab825;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// channel == nil
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 例如 
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">//  var a chan int
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">//  a &lt;- 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> c == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> !block {
</span></span><span style="display:flex;"><span>            <span style="color:#999;font-style:italic">// 非阻塞模式下直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// nil channel 发送数据会永久阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 挂起当前 goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#447fcf">gopark</span>(<span style="color:#6ab825;font-weight:bold">nil</span>, <span style="color:#6ab825;font-weight:bold">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span style="color:#3677a9">2</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#447fcf">throw</span>(<span style="color:#ed9d13">&#34;unreachable&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// channel 非阻塞且未关闭
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 并且缓冲区已满，直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span> 	<span style="color:#6ab825;font-weight:bold">if</span> !block &amp;&amp; c.closed == <span style="color:#3677a9">0</span> &amp;&amp; <span style="color:#447fcf">full</span>(c) {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 加锁 (注意后续代码中不同条件下的解锁处理细节)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">lock</span>(&amp;c.lock)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// channel 已经关闭，抛出 panic
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> c.closed != <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#447fcf">unlock</span>(&amp;c.lock)
</span></span><span style="display:flex;"><span>		<span style="color:#24909d">panic</span>(<span style="color:#447fcf">plainError</span>(<span style="color:#ed9d13">&#34;send on closed channel&#34;</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 如果存在等待接收的 goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 将数据发送给等待接收的 goroutine 后，直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> sg := c.recvq.<span style="color:#447fcf">dequeue</span>(); sg != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 将数据发送给队列第一个 goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 将数据直接传递给 goroutine，绕过 channel 缓冲区 (类似零拷贝的设计理念)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 详情见: send 函数
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#447fcf">send</span>(c, sg, ep, <span style="color:#6ab825;font-weight:bold">func</span>() { <span style="color:#447fcf">unlock</span>(&amp;c.lock) }, <span style="color:#3677a9">3</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// qcount 是队列当前元素数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// dataqsiz 是队列总长度
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 当前元素数量小于队列总长度时，说明还有空闲空间可供使用
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> c.qcount &lt; c.dataqsiz {
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 缓冲区未满，还有可用空间
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 获取下一个可以存放数据的地址 (缓冲区槽位)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		qp := <span style="color:#447fcf">chanbuf</span>(c, c.sendx)
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 将发送的数据拷贝到缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#447fcf">typedmemmove</span>(c.elemtype, qp, ep)    
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 发送索引 + 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		c.sendx++                           
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 环形队列，当发送索引等于队列长度时，索引重置为 0
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> c.sendx == c.dataqsiz {          
</span></span><span style="display:flex;"><span>			c.sendx = <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 缓冲区元素数量 + 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		c.qcount++                     
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 解锁
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#447fcf">unlock</span>(&amp;c.lock)                      
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 队列没有空闲空间可供使用
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> !block {
</span></span><span style="display:flex;"><span>		<span style="color:#447fcf">unlock</span>(&amp;c.lock)
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// --------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 接下来的流程针对的是阻塞的情况
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// --------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 获取当前发送数据的 goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 然后绑定到一个 sudog 结构体 (包装为运行时表示) 
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	gp := <span style="color:#447fcf">getg</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 获取 sudog 结构体
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 并且设置相关字段 (包括当前的 channel，是否是 select 等)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	mysg := <span style="color:#447fcf">acquireSudog</span>()
</span></span><span style="display:flex;"><span>	mysg.g = gp
</span></span><span style="display:flex;"><span>	mysg.isSelect = <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>	mysg.c = c
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 将 sudog 放入发送队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	c.sendq.<span style="color:#447fcf">enqueue</span>(mysg) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 挂起当前 goroutine, 进入休眠 (等待接收)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">gopark</span>(chanparkcommit, unsafe.<span style="color:#447fcf">Pointer</span>(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span style="color:#3677a9">2</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 确保发送的值一直处于有效状态，直到接收方将其复制出来
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// sudog 有一个指向栈对象的指针，保持发送的数据处于活跃状态，避免被 GC
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">KeepAlive</span>(ep)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 取消 sudog 和 channel 绑定关系
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	mysg.c = <span style="color:#6ab825;font-weight:bold">nil</span>        
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 释放 sudog
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">releaseSudog</span>(mysg)   
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> closed {         
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// goroutine 被唤醒后发现 channel 已关闭, 抛出 panic
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> c.closed == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#447fcf">throw</span>(<span style="color:#ed9d13">&#34;chansend: spurious wakeup&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span> 		<span style="color:#24909d">panic</span>(<span style="color:#447fcf">plainError</span>(<span style="color:#ed9d13">&#34;send on closed channel&#34;</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="send-函数">send 函数</h3>
<p><code>send</code> 函数用于处理 <code>channel</code> 数据的发送操作，函数会调用 <code>sendDirect</code> 直接将发送方的数据复制到接收方，或将等待接收的 <code>goroutine</code> 唤醒。</p>
<ul>
<li>参数 <code>sg</code> 表示接收方 <code>goroutine</code></li>
<li>参数 <code>ep</code> 表示要发送的数据</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">send</span>(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span style="color:#6ab825;font-weight:bold">func</span>(), skip <span style="color:#6ab825;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> sg.elem != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 直接拷贝数据
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#447fcf">sendDirect</span>(c.elemtype, sg, ep)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 调用 goready 函数将接收方 goroutine 唤醒并标记为可运行状态
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 并把其放入发送方所在处理器 P 的 runnext 字段等待执行
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// runnext 字段表示最高优先级的 goroutine (GMP 调度器一文中讲过)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">goready</span>(gp, skip+<span style="color:#3677a9">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="senddirect-函数">sendDirect 函数</h3>
<p><code>sendDirect</code> 函数用于 <code>channel</code> 具体的发送数据操作，将发送方 <code>goroutine</code> 的数据直接写入到接收方 <code>goroutine</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">sendDirect</span>(t *_type, sg *sudog, src unsafe.Pointer) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="阻塞发送">阻塞发送</h3>
<p><code>channel</code> 阻塞发送时，将 <code>sudog</code> 结构体放入发送队列:</p>
<p><img src="https://dbwu.tech/images/channelsend.png" alt="channel 阻塞发送示例图"></p>
<h3 id="非阻塞发送">非阻塞发送</h3>
<p><code>channel</code> 非阻塞发送时，分为两种情况:</p>
<ol>
<li>缓冲区未满，直接将数据存入缓冲区</li>
<li>缓冲区已满，将 <code>sudog</code> 结构体放入发送队列</li>
</ol>
<p><img src="https://dbwu.tech/images/channelsend2.png" alt="channel 非阻塞发送情况一示例图"></p>
<p><img src="https://dbwu.tech/images/channelsend3.png" alt="channel 非阻塞发送情况二示例图"></p>
<h3 id="小结">小结</h3>
<p><strong>channel 发送数据的条件分支</strong>:</p>
<ol>
<li>如果 <code>channel == nil</code>, 非阻塞模式直接返回，阻塞模式，休眠当前 <code>goroutine</code></li>
<li>如果 <code>channel</code> 为非阻塞模式并且 <code>channel</code> 未关闭，同时缓冲区已满，直接返回</li>
<li>如果 <code>channel</code> 已经关闭，发生 <code>panic</code></li>
<li>如果 <code>channel</code> 接收队列不为空, 出队第一个元素作为接收方 <code>goroutine</code>，将数据发送给接收方 <code>goroutine</code> 后，直接返回</li>
<li>如果 <code>channel</code> 缓冲区未满，将数据存入缓冲区，直接返回</li>
<li>如果以上条件都不满足，就获取一个新的 <code>sudog</code> 结构体并放入 <code>channel</code> 的发送队列，同时挂起当前发送数据的 <code>goroutine</code>, 进入休眠 (等待接收方接收数据)</li>
</ol>
<h2 id="接收数据">接收数据</h2>
<p>编译器会将应用层代码中的 <code>&lt;- ch</code> 语句转换为 <code>chanrecv1</code> 函数调用。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">//go:nosplit
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">chanrecv1</span>(c *hchan, elem unsafe.Pointer) {
</span></span><span style="display:flex;"><span>	<span style="color:#447fcf">chanrecv</span>(c, elem, <span style="color:#6ab825;font-weight:bold">true</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编译器会将应用层代码中的 <code>x, ok &lt;- ch</code> 语句转换为 <code>chanrecv2</code> 函数调用。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">//go:nosplit
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">chanrecv2</span>(c *hchan, elem unsafe.Pointer) (received <span style="color:#6ab825;font-weight:bold">bool</span>) {
</span></span><span style="display:flex;"><span>	_, received = <span style="color:#447fcf">chanrecv</span>(c, elem, <span style="color:#6ab825;font-weight:bold">true</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 编译器将
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//	select {
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//	case v, ok = &lt;-c:
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//		... foo
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//	default:
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//		... bar
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//	}
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 转换为
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//	if selected, ok = selectnbrecv(&amp;v, c); selected {
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//		... foo
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//	} else {
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//		... bar
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//	}
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">selectnbrecv</span>(elem unsafe.Pointer, c *hchan) (selected, received <span style="color:#6ab825;font-weight:bold">bool</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#447fcf">chanrecv</span>(c, elem, <span style="color:#6ab825;font-weight:bold">false</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>chanrecv1</code> 和 <code>chanrecv2</code> 以及 <code>selectnbrecv</code> 函数内部调用的都是 <code>chanrecv</code> 函数。</p>
<p><code>chanrecv</code> 函数用于在 <code>channel</code> 上接收数据并将接收到的数据写入参数 <code>ep</code> (ep 可以设置为 nil, 这种情况下接收到的数据将会被忽略)，并有两个返回值:</p>
<ul>
<li><code>selected</code> 用于在 <code>select{}</code> 语句中表示是否会选中该分支</li>
<li><code>received</code> 表示是否接收到了数据</li>
</ul>
<p>根据参数的不同返回不同的值:</p>
<ul>
<li>如果 <code>block == false</code> 并且没有数据可用，返回 false, false</li>
<li>如果 <code>channel</code> 已经关闭，返回数据的零值和 false</li>
<li>如果上述两种条件都不满足（说明有数据可用并且 channel 未关闭），将数据赋值给参数 *ep 然后返回 true, true</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">chanrecv</span>(c *hchan, ep unsafe.Pointer, block <span style="color:#6ab825;font-weight:bold">bool</span>) (selected, received <span style="color:#6ab825;font-weight:bold">bool</span>) {
</span></span><span style="display:flex;"><span> 	<span style="color:#6ab825;font-weight:bold">if</span> c == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> !block {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 非阻塞的情况下，直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 非阻塞出现在 select{} + default 场景
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 在 nil channel 上进行接收操作，会永久阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#447fcf">gopark</span>(<span style="color:#6ab825;font-weight:bold">nil</span>, <span style="color:#6ab825;font-weight:bold">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span style="color:#3677a9">2</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#447fcf">throw</span>(<span style="color:#ed9d13">&#34;unreachable&#34;</span>) <span style="color:#999;font-style:italic">// 疑问：这行代码能执行到吗？
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 非阻塞模式并且接收数据操作会阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// empty 函数返回 true 的情况:
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">//    1. 无缓冲 channel 并且没有发送方正在阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">//    2. 有缓冲 channel 并且缓冲区没有数据
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span> 	<span style="color:#6ab825;font-weight:bold">if</span> !block &amp;&amp; <span style="color:#447fcf">empty</span>(c) {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 接下来再判断 channel 是否已经关闭
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> atomic.<span style="color:#447fcf">Load</span>(&amp;c.closed) == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 如果是未关闭的 channel, 非阻塞且没有可接收数据的情况下，直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 因为 channel 关闭后就无法再打开
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 所以只要 channel 未关闭，上述方法都是原子操作 (看到的结果都是一样的)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 执行到这里，说明 channel 已经关闭
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span> 		<span style="color:#999;font-style:italic">// channel 关闭后就无法再打开
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 重新检查 channel 是否存在等待接收的数据
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#447fcf">empty</span>(c) {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 没有任何等待接收的数据
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#6ab825;font-weight:bold">if</span> ep != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#447fcf">typedmemclr</span>(c.elemtype, ep) <span style="color:#999;font-style:italic">// 清理 ep 指针中的数据
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">true</span>, <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	 
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 加锁 (注意后续代码中不同条件下的解锁处理细节)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">lock</span>(&amp;c.lock)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> c.closed != <span style="color:#3677a9">0</span> {      <span style="color:#999;font-style:italic">// channel 已经关闭
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> c.qcount == <span style="color:#3677a9">0</span> {  <span style="color:#999;font-style:italic">// 缓冲区也没有数据了
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#447fcf">unlock</span>(&amp;c.lock) <span style="color:#999;font-style:italic">// 解锁
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#6ab825;font-weight:bold">if</span> ep != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#447fcf">typedmemclr</span>(c.elemtype, ep) <span style="color:#999;font-style:italic">// 清理 ep 指针中的数据
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">true</span>, <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 先检测发送的队列是否不为空
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 不为空说明有阻塞在等待发送的 goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> sg := c.sendq.<span style="color:#447fcf">dequeue</span>(); sg != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 出队发送队列第一个 goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 如果缓冲区还有剩余的可用空间，直接从发送 goroutine 接收数据
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 否则，从接收队列头部的 goroutine 开始接收数据，并将数据添加到发送队列尾部的 goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#447fcf">recv</span>(c, sg, ep, <span style="color:#6ab825;font-weight:bold">func</span>() { <span style="color:#447fcf">unlock</span>(&amp;c.lock) }, <span style="color:#3677a9">3</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">true</span>, <span style="color:#6ab825;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 如果 channel 缓冲区还有数据
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> c.qcount &gt; <span style="color:#3677a9">0</span> {               
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 获取 channel 接收地址
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		qp := <span style="color:#447fcf">chanbuf</span>(c, c.recvx)   
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> ep != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#999;font-style:italic">// 直接拷贝数据到接收地址
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#447fcf">typedmemmove</span>(c.elemtype, ep, qp)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 清除缓冲区数据
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#447fcf">typedmemclr</span>(c.elemtype, qp) 
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 接收索引 + 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		c.recvx++
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 环形队列，当索引等于队列长度时，索引重置为 0
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> c.recvx == c.dataqsiz {  
</span></span><span style="display:flex;"><span>			c.recvx = <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 缓冲区元素数量 - 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		c.qcount--
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 解锁
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#447fcf">unlock</span>(&amp;c.lock)             
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">true</span>, <span style="color:#6ab825;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 如果是非阻塞并且无数据可接收
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> !block {
</span></span><span style="display:flex;"><span>		<span style="color:#447fcf">unlock</span>(&amp;c.lock)
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>, <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// --------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// 接下来的流程针对的是阻塞的情况
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// --------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 获取当前发送数据的 goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// 然后绑定到一个 sudog 结构体 (包装为运行时表示)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	gp := <span style="color:#447fcf">getg</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 获取 sudog 结构体
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 并且设置相关数据 (包括当前的 channel，是否是 select 等)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	mysg := <span style="color:#447fcf">acquireSudog</span>()
</span></span><span style="display:flex;"><span>	mysg.g = gp
</span></span><span style="display:flex;"><span>	mysg.isSelect = <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>	mysg.c = c
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 将 sudog 放入接收队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	c.recvq.<span style="color:#447fcf">enqueue</span>(mysg)   
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 挂起当前 goroutine, 进入休眠 (等待发送方发送数据)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">gopark</span>(chanparkcommit, unsafe.<span style="color:#447fcf">Pointer</span>(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span style="color:#3677a9">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 取消 sudog 和 channel 绑定关系
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    mysg.c = <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 释放 sudog
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#447fcf">releaseSudog</span>(mysg)  
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">true</span>, success
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="recv-函数">recv 函数</h3>
<p><code>recv</code> 函数用于处理 <code>channel</code> 的数据接收操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">recv</span>(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span style="color:#6ab825;font-weight:bold">func</span>(), skip <span style="color:#6ab825;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 无缓冲 channel
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> c.dataqsiz == <span style="color:#3677a9">0</span> {    
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> ep != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 直接从发送方拷贝数据
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#447fcf">recvDirect</span>(c.elemtype, sg, ep)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 获取缓冲区首元素
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		qp := <span style="color:#447fcf">chanbuf</span>(c, c.recvx)               
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> ep != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#999;font-style:italic">// 从缓冲区拷贝数据到接收方
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#447fcf">typedmemmove</span>(c.elemtype, ep, qp)    
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 从发送方拷贝数据到缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#447fcf">typedmemmove</span>(c.elemtype, qp, sg.elem)   
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 接收索引 + 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		c.recvx++
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 环形队列，当索引等于队列长度时，索引重置为 0
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> c.recvx == c.dataqsiz {              
</span></span><span style="display:flex;"><span>			c.recvx = <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 除了更新接收索引外，还要更新发送索引 (赋值为更新后的接收索引值)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 这样下次写入发送数据时，才能保证写入位置正确
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		c.sendx = c.recvx
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 调用 goready 函数将接收方 goroutine 唤醒并标记为可运行状态
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// 并把其放入接收方所在处理器 P 的 runnext 字段等待执行
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">goready</span>(gp, skip+<span style="color:#3677a9">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="recvdirect-函数">recvDirect 函数</h3>
<p><code>recvDirect</code> 函数和 <code>sendDirect</code> 函数作用一致，这里不再赘述。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">recvDirect</span>(t *_type, sg *sudog, dst unsafe.Pointer) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="阻塞接收">阻塞接收</h3>
<p><img src="https://dbwu.tech/images/channelrecv.png" alt="channel 阻塞接收示例图"></p>
<h3 id="非阻塞接收">非阻塞接收</h3>
<p><code>channel</code> 非阻塞接收时，分为两种情况:</p>
<ol>
<li>缓冲区不为空，直接从缓冲区读取数据</li>
<li>缓冲区为空，将 <code>sudog</code> 结构体放入接收队列</li>
</ol>
<p><img src="https://dbwu.tech/images/channelrecv2.png" alt="channel 非阻塞发送情况一示例图"></p>
<p><img src="https://dbwu.tech/images/channelrecv3.png" alt="channel 非阻塞发送情况二示例图"></p>
<h3 id="小结-1">小结</h3>
<p><strong>channel 接收数据的条件分支</strong>:</p>
<ol>
<li>如果 <code>channel == nil</code>, 非阻塞模式直接返回，阻塞模式，休眠当前 <code>goroutine</code></li>
<li>如果 <code>channel</code> 已经关闭或者缓冲区没有等待接收的数据，直接返回</li>
<li>如果 <code>channel</code> 发送队列不为空, 出队第一个元素作为发送方 <code>goroutine</code>，将数据发送给接收方 <code>goroutine</code> 后，直接返回</li>
<li>如果 <code>channel</code> 缓冲区有数据，直接从缓冲区读取数据</li>
<li>如果以上条件都不满足，就获取一个新的 <code>sudog</code> 结构体并放入 <code>channel</code> 的接收队列，同时挂起当前发送数据的 <code>goroutine</code>, 进入休眠 (等待发送方发送数据)</li>
</ol>
<h2 id="关闭-channel">关闭 channel</h2>
<p>编译器会将应用层代码中的 <code>clsoe(channel name)</code> 语句转换为 <code>closechan</code> 函数调用。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">closechan</span>(c *hchan) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 关闭一个 nil channel, 抛出 panic
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> c == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#24909d">panic</span>(<span style="color:#447fcf">plainError</span>(<span style="color:#ed9d13">&#34;close of nil channel&#34;</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 加锁，这个锁的粒度比较大
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 会持续到释放完所有的 sudog 才解锁
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">lock</span>(&amp;c.lock)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 关闭一个已经关闭的 channel, 抛出 panic
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> c.closed != <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#447fcf">unlock</span>(&amp;c.lock)
</span></span><span style="display:flex;"><span>		<span style="color:#24909d">panic</span>(<span style="color:#447fcf">plainError</span>(<span style="color:#ed9d13">&#34;close of closed channel&#34;</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 设置 channel 状态为已关闭
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	c.closed = <span style="color:#3677a9">1</span>    
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// goroutine 列表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 用于存放发送+接收队列中的所有 goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">var</span> glist gList
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 将接收队列中所有 goroutine 加入 gList 列表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>		sg := c.recvq.<span style="color:#447fcf">dequeue</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 出队的 sudog 为 nil
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 说明接收队列为空，直接跳出循环
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> sg == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 将 sg 对应的 goroutine 添加到 glist 列表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		glist.<span style="color:#447fcf">push</span>(gp)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 将发送队列中所有 goroutine 加入 gList 列表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 当然，因为 channel 已经关闭，所以这些 goroutine 被唤醒后发生数据时会直接 panic
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>		sg := c.sendq.<span style="color:#447fcf">dequeue</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 出队的 sudog 为 nil
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 说明发送队列为空，直接跳出循环
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> sg == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 将 sg 对应的 goroutine 添加到 glist 列表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		glist.<span style="color:#447fcf">push</span>(gp)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 解锁
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">unlock</span>(&amp;c.lock) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 将出队的所有 goroutine 设置为可运行状态
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> !glist.<span style="color:#447fcf">empty</span>() {
</span></span><span style="display:flex;"><span>		gp := glist.<span style="color:#447fcf">pop</span>()
</span></span><span style="display:flex;"><span>		gp.schedlink = <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>		<span style="color:#447fcf">goready</span>(gp, <span style="color:#3677a9">3</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="示意图">示意图</h3>
<p>这里需要注意的是: <code>gList</code> 是一个栈数据结构 (后进先出)，所以调用 <code>glist.pop</code> 方法时，首先出队的是发送队列的最后一个 <code>goroutine</code>,
最后出队的是接收队列的第一个 <code>goroutine</code> (图中两条青色的线条)，虽然顺序相反，但是数据的发送/接收不会受到影响。</p>
<p><img src="https://dbwu.tech/images/channelclose.png" alt="channel 关闭"></p>
<h2 id="辅助函数">辅助函数</h2>
<h3 id="empty">empty</h3>
<p><code>empty</code> 函数检测从 <code>channel</code> 读取数据是否会阻塞 (也就是检测 <code>channel</code> 缓冲区是否为空)，主要分为两种情况:</p>
<ol>
<li>如果 <code>channel</code> 没有缓冲区，查看是否存在发送数据 <code>goroutine</code></li>
<li>如果 <code>channel</code> 有缓冲区，检查元素数量是否等于 0</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">empty</span>(c *hchan) <span style="color:#6ab825;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> c.dataqsiz == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> atomic.<span style="color:#447fcf">Loadp</span>(unsafe.<span style="color:#447fcf">Pointer</span>(&amp;c.sendq.first)) == <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> atomic.<span style="color:#447fcf">Loaduint</span>(&amp;c.qcount) == <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="chanbuf">chanbuf</h3>
<p><code>chanbuf</code> 函数用于获取缓冲区下一个地址 (缓冲区槽位)，<code>chanbuf(c, i)</code> 表示指向缓冲区中第 i 个槽位的指针。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">chanbuf</span>(c *hchan, i <span style="color:#6ab825;font-weight:bold">uint</span>) unsafe.Pointer {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#447fcf">add</span>(c.buf, <span style="color:#24909d">uintptr</span>(i)*<span style="color:#24909d">uintptr</span>(c.elemsize))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="full">full</h3>
<p><code>full</code> 函数检测 <code>channel</code> 缓冲区是否已满，主要分为两种情况:</p>
<ol>
<li>如果 <code>channel</code> 没有缓冲区，查看是否存在接收者</li>
<li>如果 <code>channel</code> 有缓冲区, 比较元素数量和缓冲区长度是否一致</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">full</span>(c *hchan) <span style="color:#6ab825;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> c.dataqsiz == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> c.recvq.first == <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> c.qcount == c.dataqsiz
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="enqueue">enqueue</h3>
<p><code>enqueue</code> 方法用于将 <code>goroutine</code> 放入 <code>channel</code> 的发送/接收队列 (入队操作)，内部实现就是链表操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (q *waitq) <span style="color:#447fcf">enqueue</span>(sgp *sudog) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="dequeue">dequeue</h3>
<p><code>dequeue</code> 方法用于出队 <code>channel</code> 的发送/接收队列的一个元素 (出队操作)，内部实现就是链表操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (q *waitq) <span style="color:#447fcf">dequeue</span>() *sudog {
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="faq">FAQ</h2>
<h3 id="close-channel-设计理念">close channel 设计理念</h3>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">closechan</span>(c *hchan) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 关闭一个 nil channel, 抛出 panic
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> c == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#24909d">panic</span>(<span style="color:#447fcf">plainError</span>(<span style="color:#ed9d13">&#34;close of nil channel&#34;</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><p>为什么关闭一个已经关闭的 <code>channel</code> 会 <code>panic</code> ?</p>
<p>官方这样设计的初衷，应该是希望开发者不要依赖于 <code>close</code> 函数，而是要求开发者通过合理设计 <code>goroutine + channel</code> 工作流来提高程序的健壮性。</p>
<h3 id="如何检测-channel-是否已关闭">如何检测 channel 是否已关闭</h3>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">import</span> (
</span></span><span style="display:flex;"><span>   <span style="color:#ed9d13">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#ed9d13">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {
</span></span><span style="display:flex;"><span>   ch := <span style="color:#24909d">make</span>(<span style="color:#6ab825;font-weight:bold">chan</span> <span style="color:#6ab825;font-weight:bold">int</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#6ab825;font-weight:bold">go</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#6ab825;font-weight:bold">if</span> val, ok := &lt;-ch; !ok {
</span></span><span style="display:flex;"><span>         fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;channel closed&#34;</span>)
</span></span><span style="display:flex;"><span>      } <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>         fmt.<span style="color:#447fcf">Printf</span>(<span style="color:#ed9d13">&#34;val = %d&#34;</span>, val)
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>   }()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   ch &lt;- <span style="color:#3677a9">1024</span>
</span></span><span style="display:flex;"><span>   <span style="color:#24909d">close</span>(ch)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   time.<span style="color:#447fcf">Sleep</span>(time.Second)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="如何实现健壮的-channel-close-方法">如何实现健壮的 channel close 方法</h3>
<p>关闭一个已经关闭的 channel 会 panic, 实现一个方法，可以让调用方无需考虑边界情况，直接调用即可。</p>
<p>下面的代码只是作为技术解决方案探究，没有任何实际意义 (不要应用在任何业务中)。</p>
<h4 id="1-recover">1. recover</h4>
<p>通过 recover 函数捕获 panic, 可以保证关闭一个已经关闭的 channel 报错不会导致程序终止。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#ed9d13">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">defer</span> <span style="color:#6ab825;font-weight:bold">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> err := <span style="color:#24909d">recover</span>(); err != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			fmt.<span style="color:#447fcf">Printf</span>(<span style="color:#ed9d13">&#34;recover err: %v\n&#34;</span>, err)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ch := <span style="color:#24909d">make</span>(<span style="color:#6ab825;font-weight:bold">chan</span> <span style="color:#6ab825;font-weight:bold">int</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#24909d">close</span>(ch)
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 关闭一个已经关闭的 channel
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#24909d">close</span>(ch)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="2-synconce">2. sync.Once</h4>
<p>通过 sync.Once 方法保证 close(channel) 只会被调用一次。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#ed9d13">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">type</span> myChan <span style="color:#6ab825;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	ch   <span style="color:#6ab825;font-weight:bold">chan</span> <span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>	once sync.Once
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (c *myChan) <span style="color:#24909d">close</span>() {
</span></span><span style="display:flex;"><span>	c.once.<span style="color:#447fcf">Do</span>(<span style="color:#6ab825;font-weight:bold">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#24909d">close</span>(c.ch)
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {
</span></span><span style="display:flex;"><span>	ch := &amp;myChan{
</span></span><span style="display:flex;"><span>		ch: <span style="color:#24909d">make</span>(<span style="color:#6ab825;font-weight:bold">chan</span> <span style="color:#6ab825;font-weight:bold">int</span>),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	ch.<span style="color:#24909d">close</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 关闭一个已经关闭的 channel
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	ch.<span style="color:#24909d">close</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3-atomiccas">3. atomic.CAS</h4>
<p>通过 atomic.CAS 方法保证 close(channel) 只会被调用一次。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#ed9d13">&#34;sync/atomic&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">type</span> myChan <span style="color:#6ab825;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	ch     <span style="color:#6ab825;font-weight:bold">chan</span> <span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>	closed <span style="color:#6ab825;font-weight:bold">int32</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (c *myChan) <span style="color:#24909d">close</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> atomic.<span style="color:#447fcf">CompareAndSwapInt32</span>(&amp;c.closed, <span style="color:#3677a9">0</span>, <span style="color:#3677a9">1</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#24909d">close</span>(c.ch)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {
</span></span><span style="display:flex;"><span>	ch := &amp;myChan{
</span></span><span style="display:flex;"><span>		ch: <span style="color:#24909d">make</span>(<span style="color:#6ab825;font-weight:bold">chan</span> <span style="color:#6ab825;font-weight:bold">int</span>),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	ch.<span style="color:#24909d">close</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 关闭一个已经关闭的 channel
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	ch.<span style="color:#24909d">close</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="4-contextcontext">4. context.Context</h4>
<p>通过 context.Context 保证 close(channel) 的操作顺序同步。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#ed9d13">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">type</span> myChan <span style="color:#6ab825;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	ch     <span style="color:#6ab825;font-weight:bold">chan</span> <span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>	ctx    context.Context
</span></span><span style="display:flex;"><span>	cancel context.CancelFunc
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> (c *myChan) <span style="color:#24909d">close</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">select</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">case</span> &lt;-c.ctx.<span style="color:#447fcf">Done</span>():
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">default</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#24909d">close</span>(c.ch)
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 事件同步
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		c.<span style="color:#447fcf">cancel</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {
</span></span><span style="display:flex;"><span>	ctx, cancel := context.<span style="color:#447fcf">WithCancel</span>(context.<span style="color:#447fcf">Background</span>())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ch := &amp;myChan{
</span></span><span style="display:flex;"><span>		ch:     <span style="color:#24909d">make</span>(<span style="color:#6ab825;font-weight:bold">chan</span> <span style="color:#6ab825;font-weight:bold">int</span>),
</span></span><span style="display:flex;"><span>		ctx:    ctx,
</span></span><span style="display:flex;"><span>		cancel: cancel,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ch.<span style="color:#24909d">close</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 关闭一个已经关闭的 channel
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	ch.<span style="color:#24909d">close</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="channel-最佳实践">channel 最佳实践</h3>
<ol>
<li>channel 类型作为参数时，指定操作类型 (读/写)</li>
<li>使用 <code>select + default</code> 处理多个 <code>channel</code> 轮询场景</li>
<li>永远不要在读取方向关闭 <code>channel</code>, 只在写入端关闭 channel</li>
<li>不要依赖任何应用层实现的 <code>channel</code> 关闭检测方法函数，应该将 <code>channel</code> 的读写操作进行分离 (通过不同的 <code>goroutine</code>)，并实现只在一个写入端关闭 channel</li>
<li>使用 <code>context.Context</code> 控制 <code>channel</code> 的生命周期</li>
<li>充分考虑缓冲和非缓冲 <code>channel</code> 的使用场景
<ul>
<li>无缓冲 <code>channel</code> 提供了阻塞机制，虽然避免了数据竞态，但是当数据较多时降低了性能，而且可能引发死锁</li>
<li>缓冲 <code>channel</code> 虽然避免了阻塞，但是有潜在的数据竞态，而且需要考虑缓冲区大小，设计不合理容易浪费资源</li>
</ul>
</li>
</ol>
<h3 id="channel-和锁如何选择">channel 和锁如何选择？</h3>
<blockquote>
<p>当你发现使用锁使程序变得复杂时，可以试试使用 channel 会不会使程序变得简单。</p>
</blockquote>
<h4 id="锁的使用场景">锁的使用场景</h4>
<ul>
<li>访问共享数据结构中的缓存信息</li>
<li>保存应用程序上下文和状态信息</li>
<li>保护某个结构内部状态和完整性</li>
<li>高性能要求的临界区代码</li>
</ul>
<h4 id="channel-的使用场景">channel 的使用场景</h4>
<ul>
<li>线程 (goroutine) 通信</li>
<li>并发通信</li>
<li>异步操作</li>
<li>任务分发</li>
<li>传递数据所有权</li>
<li>数据逻辑组合 (如 Pipeline, FanIn FanOut 等并发模式)</li>
</ul>
<p>官方给出的建议是除了特殊的、底层的应用程序外，其他情况最好使用 <code>channel</code> 或其他同步原语来完成 (<del>但是从大多数开源组件实现代码来看，并没有遵守官方的建议</del>)。</p>
<h2 id="小结-2">小结</h2>
<p>本文着重介绍了 <code>channel</code> 的运行时数据结构和常见的三个操作 (发送数据、接收数据、关闭 channel) 对应的底层算法实现，标准库中 <code>channel</code> 文件源代码有将近 900 行，
但是核心在于 <code>hchan</code> 结构体以及围绕该结构体实现的各个函数方法，重点是 <code>hchan</code> 结构体中的 <code>环形队列</code>、<code>发送/接收索引</code>, <code>发送/接收链表</code> 字段，
理解了这 3 个字段对应的数据结构和算法，<code>channel</code> 的设计与实现也就完全理解了。</p>
<h2 id="扩展阅读">扩展阅读</h2>
<ul>
<li><a href="https://dbwu.tech/posts/golang_gmp/">GMP 调度器</a></li>
<li><a href="https://dbwu.tech/posts/golang_hacking/">Go 标准库中的 runtime.Hacking.md</a></li>
</ul>


</article>

<article>
    <img src="https://dbwu.tech/images/wechat.png">
</article>

<article>
    <h3>转载申请</h3>

    <p>
        本作品采用 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> 进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，商业转载请联系作者获得授权。
    </p>
</article>

<section class="post-nav">
    <ul>
        <li>
        
            <a href="https://dbwu.tech/posts/linux_everything_is_a_file/"><i class="fa fa-chevron-circle-left"></i> 为什么 Linux “一切皆文件”</a>
        
        </li>
        <li>
        
            <a href="https://dbwu.tech/posts/golang_gmp/">GMP Scheduler Code Reading <i class="fa fa-chevron-circle-right"></i> </a>
        
        </li>
    </ul>
</section>
  
    
    
  


<script src="https://giscus.app/client.js"
        data-repo="duanbiaowu/dbwu.tech"
        data-repo-id="R_kgDOIkkjjw"
        data-category="Announcements"
        data-category-id="DIC_kwDOIkkjj84CV78j"
        data-mapping="specific"
        data-term="Go channel 的 15 条规则和底层实现"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous" async>
</script>




</main>
    <footer>
        <ul>
            <li>
                <h6><a href="mailto:codean.net@gmail.com">codean.net@gmail.com</a> | 
                    <img src="https://dbwu.tech/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" />
                    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61011302001681" target="_blank">陕公网安备 61011302001681 号</a> |
                    <a href="https://beian.miit.gov.cn" target="_blank">陕ICP备2023004378号-1</a> |
                    Rendered by <a href="https://themes.gohugo.io" title="Hugo" target="_blank">Hugo</a>
                </h6>
            </li>
            
            
        </ul>
    </footer>
</div>
<script src="https://dbwu.tech/js/scripts.js"></script>


</body>

</html>

