<!doctype html>

<html lang="en">

<head>
  <title>LeetCode Binary Search Tree 刷题模板 - 蛮荆</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="" />
<meta name="author" content="" />
<link rel="shortcut icon" href="https://dbwu.tech/favicon.ico" type="image/x-icon" /><meta property="og:title" content="LeetCode Binary Search Tree 刷题模板" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dbwu.tech/posts/algorithm/leetcode_binary_search_tree_pattern/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-25T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-05-25T00:00:00+00:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode Binary Search Tree 刷题模板"/>
<meta name="twitter:description" content=""/>

<meta name="generator" content="Hugo 0.120.3">
    
    <script src="https://dbwu.tech/js/mathjax-config.js" defer></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CZMGTTFLNY"></script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3261056100776781" crossorigin="anonymous"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-CZMGTTFLNY');
  </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>


  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/normalize.min.css" />
  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/all.min.css" />
  
    
    <link href="//fonts.googleapis.com/css?family=Staatliches" rel="stylesheet">
  
  
  <link rel="stylesheet" type="text/css" href="https://dbwu.tech/css/styles-light.css" />
  </head>

<body>
  <div id="container">
    <header>
      
      <h1>
        <a href="https://dbwu.tech/">蛮荆</a>
      </h1>

      <ul id="social-media">
      </ul>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="active" href="https://dbwu.tech/posts/">
                <i class="fa-li fa  fa-lg"></i><span>归档</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/tags/">
                <i class="fa-li fa  fa-lg"></i><span>标签</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://github.com/duanbiaowu">
                <i class="fa-li fa  fa-lg"></i><span>Github</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/index.xml">
                <i class="fa-li fa  fa-lg"></i><span>RSS</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<article>

    <h1>LeetCode Binary Search Tree 刷题模板</h1>

    
      
<p>
    <span>2022-05-25</span>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/%E7%AE%97%E6%B3%95">算法</a>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/leetcode">LeetCode</a>
    
</p>

    

    
      

    

    <h2 id="-概述">📖 概述</h2>
<blockquote>
<p>在计算机科学中，二叉搜索树（BST）也称为有序或排序二叉树，其中每个节点的值必须大于（或等于）其左子树中的任何值，同时小于（或等于）其右子树中的任何值。</p>
</blockquote>
<p><img src="https://dbwu.tech/images/algorithm/bst.png" alt="二叉搜索树示例"></p>
<p>按照二叉搜索树的定义，使用 中序遍历 来访问树的各个节点，最终可以得到一个有序的数组。</p>
<p><img src="https://dbwu.tech/images/algorithm/bst_mid_order.png" alt="二叉搜索树转换为有序数组"></p>
<h3 id="刷题模板">刷题模板</h3>
<p>LeetCode 中的二叉搜索树相关题目相对都比较简单，<strong>核心的解题思路就是充分利用二叉搜索树的有序性来完成对应的逻辑</strong>，这里直接给出一份基础模板代码，作用是通过中序遍历的方式来获取二叉搜索树的所有节点值 (已排序)，读者可以在此模板代码上，根据不同的题来完成具体的逻辑部分代码，达到快速刷题的效果。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 通过中序遍历获取二叉搜索树的所有节点值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">inorderTraversal</span>(root *TreeNode) []<span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">var</span> res []<span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">var</span> stack []*TreeNode
</span></span><span style="display:flex;"><span>	node := root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> node != <span style="color:#6ab825;font-weight:bold">nil</span> || <span style="color:#24909d">len</span>(stack) &gt; <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">for</span> node != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			stack = <span style="color:#24909d">append</span>(stack, node)
</span></span><span style="display:flex;"><span>			node = node.Left
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		node = stack[<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>		stack = stack[:<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		res = <span style="color:#24909d">append</span>(res, node.Val)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		node = node.Right
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> res
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>二叉树的脚手架代码可以使用之前 <a href="#%E8%A1%A5%E5%85%85%E8%BF%9E%E6%8E%A5">二叉树刷题模板中的脚手架代码</a> 来辅助刷题和调试代码。</p>
<hr>
<h2 id="-典型题目">💡 典型题目</h2>
<p>二叉搜索树中序遍历得到的值序列是递增有序的，因此这类问题的解决步骤一般是 <strong>中序遍历 + 具体处理逻辑</strong>，只要得到中序遍历后的值序列 (利用前文中提到的模板)，就可以在此基础上快速解题。</p>
<h3 id="1-二叉搜索树的最小绝对差">1. 二叉搜索树的最小绝对差</h3>
<p>给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。</p>
<p><img src="https://dbwu.tech/images/algorithm/bst1.jpg" alt="图片来源: https://leetcode.cn/"></p>
<p>如图所示的二叉搜索树的最小差值为 1 (2 - 1 = 1)。</p>
<p>快速套解题模板:</p>
<ol>
<li>最小绝对差来自于 离得最近的两个数</li>
<li>使用中序遍历获得二叉搜索树排序后的所有节点值</li>
<li>遍历所有节点值，挨个计算两个数之间的差值，同时更新这个过程中的最小差值</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">getMinimumDifference</span>(root *TreeNode) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	vals := <span style="color:#447fcf">inorderTraversal</span>(root)
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#24909d">len</span>(vals) == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> -<span style="color:#3677a9">1</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 最小差值初始化为一个超大数
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	minDiff := math.MaxInt64
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#3677a9">1</span>; i &lt; <span style="color:#24909d">len</span>(vals); i++ {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 比较两个数的同时，更新最小差值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		minDiff = <span style="color:#24909d">min</span>(minDiff, vals[i]-vals[i-<span style="color:#3677a9">1</span>])
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> minDiff
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 使用中序遍历获得二叉搜索树排序后的所有节点值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 这里直接使用前文 刷题模板中 提供的方法
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 为了节省篇幅、折叠方法的具体实现
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">inorderTraversal</span>(root *TreeNode) []<span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/getMinimumDifference.png" alt="二叉搜索树的最小绝对差 - 代码执行"></p>
<h3 id="2--二叉搜索树中第-k-小的元素">2.  二叉搜索树中第 K 小的元素</h3>
<p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p>
<p><img src="https://dbwu.tech/images/algorithm/kthtree2.jpg" alt="图片来源: https://leetcode.cn/"></p>
<p>当 <code>k = 3</code> 时，最小的元素等于 3，数组排序后为 [1, 2, 3, 4, 5, 6]。</p>
<p>快速套解题模板:</p>
<ol>
<li>使用中序遍历获得二叉搜索树排序后的所有节点值</li>
<li>获取第 k 个数字</li>
</ol>
<p>这道题套上模板之后，简直就是送分题。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">kthSmallest</span>(root *TreeNode, k <span style="color:#6ab825;font-weight:bold">int</span>) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>    nums := <span style="color:#447fcf">inorderTraversal</span>(root)
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span> nums[k-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 使用中序遍历获得二叉搜索树排序后的所有节点值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 这里直接使用前文 刷题模板中 提供的方法
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 为了节省篇幅、折叠方法的具体实现
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">inorderTraversal</span>(root *TreeNode) []<span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/kthSmallest.png" alt="二叉搜索树中第 K 小的元素 - 执行过程"></p>
<h4 id="继续优化">继续优化</h4>
<p>上面的题解代码快速地解决了问题，因为仅仅在模板代码的基础上加了两行代码，但其实方法内部有额外的空间消耗，例如二叉搜索树有很多节点，但是这时参数 <code>k</code> 的值很小，上面的方法依然会遍历整棵二叉树才可以。</p>
<p>根据搜索二叉树的性质，当寻找第 <code>k</code> 个较小元素时，只需要使用中序遍历 (也就是按照节点值大小顺序遍历)，遍历到第 <code>k</code> 的元素时，直接返回，这时就可以直接在模板代码的基础上进行修改。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 优化题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 只需要在模板代码基础上修改即可
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">kthSmallest</span>(root *TreeNode, k <span style="color:#6ab825;font-weight:bold">int</span>) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">var</span> stack []*TreeNode
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 中序遍历顺序 
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 1. 左子树
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 2. 根节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 3. 右子树
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 1. 左子树
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">for</span> root != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			stack = <span style="color:#24909d">append</span>(stack, root)
</span></span><span style="display:flex;"><span>			root = root.Left
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 2. 根节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		root = stack[<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>		stack = stack[:<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 每遍历一个数字时，将 k 减去 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 作用: 累加器
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		k--
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> k == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 当 k 等于 0 的时候
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 当前节点值就是整棵搜索二叉树中第 k 小的元素
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#6ab825;font-weight:bold">return</span> root.Val
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 右子树
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		root = root.Right
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/kthSmallest2.png" alt="二叉搜索树中第 K 小的元素 (优化后) - 执行过程"></p>
<h3 id="3-将有序数组转换为二叉搜索树">3. 将有序数组转换为二叉搜索树</h3>
<p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 二叉搜索树。</p>
<p>解题思路:</p>
<p>这道题不需要查找求值，而是要构建二叉搜索树，所以前文中的刷题模板代码这里用不到。不过没关系，题目中给出的是已经排序完成的数组，根据二叉搜索树的性质，我们很容易通过分治 (递归) 的思路来解题:</p>
<ol>
<li>将数组以中间的元素为基准，将数组分成 3 个部分: 左半部分、中间元素、右半部分</li>
<li>取出数组的中间元素作为根节点的值</li>
<li>将左半部分作为根节点的左子树 (递归调用)</li>
<li>将右半部分作为根节点的右子树 (递归调用)</li>
<li>返回根节点</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">sortedArrayToBST</span>(nums []<span style="color:#6ab825;font-weight:bold">int</span>) *TreeNode {
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#447fcf">build</span>(nums, <span style="color:#3677a9">0</span>, <span style="color:#24909d">len</span>(nums)-<span style="color:#3677a9">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">build</span>(nums []<span style="color:#6ab825;font-weight:bold">int</span>, left, right <span style="color:#6ab825;font-weight:bold">int</span>) *TreeNode {
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">if</span> left &gt; right {
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 将数组以中间的元素为基准，将数组分成 3 个部分: 左半部分、中间元素、右半部分
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    mid := left + (right-left) &gt;&gt; <span style="color:#3677a9">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 取出数组的中间元素作为根节点的值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    root := &amp;TreeNode{Val: nums[mid]}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 将左半部分作为根节点的左子树 (递归调用)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    root.Left = <span style="color:#447fcf">build</span>(nums, left, mid-<span style="color:#3677a9">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 将右半部分作为根节点的右子树 (递归调用)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    root.Right = <span style="color:#447fcf">build</span>(nums, mid+<span style="color:#3677a9">1</span>, right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span> root
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/sortedArrayToBST.png" alt="将有序数组转换为二叉搜索树 - 执行过程"></p>
<hr>
<h2 id="-陷阱题">💡 陷阱题</h2>
<h3 id="1-验证二叉搜索树">1. 验证二叉搜索树</h3>
<p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p><img src="https://dbwu.tech/images/algorithm/bst1.jpg" alt="图片来源: https://leetcode.cn/"></p>
<p>如图所示的二叉树 是 二叉搜索树。</p>
<p><img src="https://dbwu.tech/images/algorithm/tree2.jpg" alt="图片来源: https://leetcode.cn/"></p>
<p>如图所示的二叉树 不是 二叉搜索树。</p>
<p>根据二叉搜索树的特征，出于直觉，我们很容易写出下面的递归代码:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">isValidBST</span>(root *TreeNode) <span style="color:#6ab825;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 如果根节点的值小于等于左节点的值, 不符合二叉搜索树规则
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> root.Left != <span style="color:#6ab825;font-weight:bold">nil</span> &amp;&amp; root.Val &lt;= root.Left.Val {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 如果根节点的值大于等于右节点的值, 不符合二叉搜索树规则
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> root.Right != <span style="color:#6ab825;font-weight:bold">nil</span> &amp;&amp; root.Val &gt;= root.Right.Val {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 递归判断左节点和右节点是否为二叉搜索树
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#447fcf">isValidBST</span>(root.Left) &amp;&amp; <span style="color:#447fcf">isValidBST</span>(root.Right)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>这里有个陷阱</strong>: 我们认为只要左右节点符合二叉搜索树特征，递归下去就可以判断整棵树是否符合二叉搜索树特征，但是 <strong>问题的根源在于</strong> 我们需要确认的不止是左右两个节点，而是左右两棵子树，所以上面的代码在这个测试用例中就会返回错误的结果。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>      <span style="color:#3677a9">5</span>
</span></span><span style="display:flex;"><span>     / <span style="color:#ed9d13">\
</span></span></span><span style="display:flex;"><span><span style="color:#ed9d13"></span>    <span style="color:#3677a9">4</span>   <span style="color:#3677a9">6</span>
</span></span><span style="display:flex;"><span>	   / <span style="color:#ed9d13">\
</span></span></span><span style="display:flex;"><span><span style="color:#ed9d13"></span>	  <span style="color:#3677a9">3</span>   <span style="color:#3677a9">7</span>
</span></span></code></pre></div><p>上图所示的二叉树并不是二叉搜索树，但是代码依然会返回 true, 原因就在于代码只是检测了右节点和其两个子节点是否为二叉搜索树，但是并未检测整个右子树是否为二叉搜索树。</p>
<p>现在刚才的代码基础上进行修正，具体来说：</p>
<ul>
<li>递归判断左子树时，除了判断 “当前节点值” 是否小于等于左节点值，<strong>还需要判断左子树中所有节点值是否小于整个树的根节点值</strong></li>
<li>递归判断右子树时，除了判断 “当前节点值” 是否大于等于右节点值，<strong>还需要判断右子树中所有节点值是否大于整个树的根节点值</strong></li>
</ul>
<p>修正后的方法每次递归时需要两个基准边界值 <code>(low, hi)</code> 作为参数，当前节点的值必须 <code>大于 low 并且小于 hi </code>, 这样才符合二叉搜索树的特征，同时在向树的深层递归时更新 <code>(low, hi)</code> 参数值，具体来说:</p>
<ul>
<li>递归判断左子树时，low 值保持不变，hi 值变为当前节点的值 (也就是说左节点及其子树中的所有节点值，都不能大于当前节点值)</li>
<li>递归判断左子树时，hi 值保持不变，low 值变为当前节点的值 (也就是说右节点及其子树中的所有节点值，都不能小于当前节点值)</li>
</ul>
<p>为了可以 LeetCode 官方提供的函数原型上正常提交 AC，这里单独写一个方法作为 “辅助方法”，然后在原型方法中调用即可，最终修正后的代码如下。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">isValidBST</span>(root *TreeNode) <span style="color:#6ab825;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 使用 64 位最小值和最大值来模拟 (low, hi) 左右边界值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#447fcf">helper</span>(root, math.MinInt64, math.MaxInt64)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">helper</span>(root *TreeNode, low, hi <span style="color:#6ab825;font-weight:bold">int</span>) <span style="color:#6ab825;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 题目要求:
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 节点的左子树只包含小于当前节点的数
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 节点的右子树只包含大于当前节点的数
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> root.Val &lt;= low || root.Val &gt;= hi {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#447fcf">helper</span>(root.Left, low, root.Val) &amp;&amp; <span style="color:#447fcf">helper</span>(root.Right, root.Val, hi)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/isValidBST.png" alt="验证二叉搜索树 - 执行过程"></p>


</article>

<article>
    <img src="https://dbwu.tech/images/wechat.png">
</article>

<article>
    <h3>转载申请</h3>

    <p>
        本作品采用 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> 进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，商业转载请联系作者获得授权。
    </p>
</article>

<section class="post-nav">
    <ul>
        <li>
        
            <a href="https://dbwu.tech/posts/algorithm/leetcode_topological_sorting_pattern/"><i class="fa fa-chevron-circle-left"></i> LeetCode 拓扑排序 刷题模板</a>
        
        </li>
        <li>
        
            <a href="https://dbwu.tech/posts/algorithm/leetcode_backtrack_pattern/">LeetCode 回溯 刷题模板 <i class="fa fa-chevron-circle-right"></i> </a>
        
        </li>
    </ul>
</section>
  
    
    
  


<script src="https://giscus.app/client.js"
        data-repo="duanbiaowu/dbwu.tech"
        data-repo-id="R_kgDOIkkjjw"
        data-category="Announcements"
        data-category-id="DIC_kwDOIkkjj84CV78j"
        data-mapping="specific"
        data-term="LeetCode Binary Search Tree 刷题模板"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous" async>
</script>




</main>
    <footer>
        <ul>
            <li>
                <h6><a href="mailto:codean.net@gmail.com">codean.net@gmail.com</a> | 
                    <img src="https://dbwu.tech/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" />
                    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61011302001681" target="_blank">陕公网安备 61011302001681 号</a> |
                    <a href="https://beian.miit.gov.cn" target="_blank">陕ICP备2023004378号-1</a> |
                    Rendered by <a href="https://themes.gohugo.io" title="Hugo" target="_blank">Hugo</a>
                </h6>
            </li>
            
            
        </ul>
    </footer>
</div>
<script src="https://dbwu.tech/js/scripts.js"></script>


</body>

</html>

