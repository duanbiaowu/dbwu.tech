<!doctype html>

<html lang="en">

<head>
  <title>LeetCode 回溯 刷题模板 - 蛮荆</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="" />
<meta name="author" content="" />
<link rel="shortcut icon" href="https://dbwu.tech/favicon.ico" type="image/x-icon" /><meta property="og:title" content="LeetCode 回溯 刷题模板" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dbwu.tech/posts/algorithm/leetcode_backtrack_pattern/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-30T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-05-30T00:00:00+00:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode 回溯 刷题模板"/>
<meta name="twitter:description" content=""/>

<meta name="generator" content="Hugo 0.120.3">
    
    <script src="https://dbwu.tech/js/mathjax-config.js" defer></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CZMGTTFLNY"></script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3261056100776781" crossorigin="anonymous"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-CZMGTTFLNY');
  </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>


  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/normalize.min.css" />
  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/all.min.css" />
  
    
    <link href="//fonts.googleapis.com/css?family=Staatliches" rel="stylesheet">
  
  
  <link rel="stylesheet" type="text/css" href="https://dbwu.tech/css/styles-light.css" />
  </head>

<body>
  <div id="container">
    <header>
      
      <h1>
        <a href="https://dbwu.tech/">蛮荆</a>
      </h1>

      <ul id="social-media">
      </ul>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="active" href="https://dbwu.tech/posts/">
                <i class="fa-li fa  fa-lg"></i><span>归档</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/tags/">
                <i class="fa-li fa  fa-lg"></i><span>标签</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://github.com/duanbiaowu">
                <i class="fa-li fa  fa-lg"></i><span>Github</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/index.xml">
                <i class="fa-li fa  fa-lg"></i><span>RSS</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<article>

    <h1>LeetCode 回溯 刷题模板</h1>

    
      
<p>
    <span>2022-05-30</span>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/%E7%AE%97%E6%B3%95">算法</a>
    
</p>

    

    
      

    

    <h2 id="-概述">📖 概述</h2>
<blockquote>
<p>回溯 (Backtracking) 算法是一类用于寻找某些计算问题（尤其是约束满足问题）的解决方案，通过逐步构建解决方案的候选方案 (路径)，并在确定候选方案无法完成某个目标时立即放弃该候选方案（“回溯”）。</p>
</blockquote>
<p><strong>回溯算法通常采用递归方式实现</strong>，在尝试每一种可能的问题解时，都会进入下一层递归，直到知道问题解或者确定当前路径无解，然后回溯到上一层，尝试更多可能的解。</p>
<p><strong>回溯算法的本质是暴力穷举</strong>，假设问题的规模为 n, 解空间的大小为 m，回溯算法的时间复杂度通常可以表示为 O(m^n)。虽然某些场景下可以通过剪枝来进行优化，减少搜索空间，降低时间复杂度，但是 “最坏” 情况下回溯算法往往是指数级别的。</p>
<p>通过回溯算法解决数独问题的过程示例。</p>
<p><img src="https://dbwu.tech/images/algorithm/Sudoku_solved_by_bactracking.gif" alt="图片来源: https://en.wikipedia.org/wiki/Backtracking"></p>
<h3 id="难点">难点</h3>
<p>回溯算法通常采用递归方式实现，在每一个递归过程中都要考虑多个选择，并不断进行递归调用，整个算法的控制流程会变得庞大复杂。此外，回溯算法涉及到对状态空间的搜索和维护，不同类型的问题有不同的解题思路和技巧，并没有像链表、二叉树等数据结构有固定的算法，因此解决回溯类算法时需要对问题本身进行抽象。</p>
<p>两个重要部分:</p>
<ol>
<li><strong>递归函数</strong>: 尝试每一种可能的解，递归搜索解空间</li>
<li><strong>状态管理</strong>: 递归过程中，需要对状态进行管理，包括判断当前路径是否有效、选择新的当前路径、剪枝、回溯等操作</li>
</ol>
<p>初学者面对回溯算法时，往往觉得难以理解和无从下手，主要原因在于: <strong>对递归思想的理解和运用，以及对回溯过程中的状态空间搜索和剪枝策略的定义</strong>。</p>
<p><img src="https://dbwu.tech/images/algorithm/0_vuA8uW0sqyX9who6.png" alt="采用回溯 ABC 三个字母的组合"></p>
<h3 id="算法步骤">算法步骤</h3>
<ol>
<li>检测: 判断当前路径是否已经符合条件，如果已经符合条件，<strong>将当前路径添加到结果集中 (查找结果是什么，终止条件就是什么)</strong>，终止当前递归，回溯到上一步</li>
<li>选择: 选择一个元素，<strong>形成新的当前路径</strong> (候选方案)，尝试将问题分解为子问题</li>
<li>剪枝: 根据问题的限制条件，<strong>判断当前路径是否有效</strong>，如果当前路径无效，终止当前递归，回溯到上一步</li>
<li>递归: 进入下一层递归，<strong>传入参数为当前路径和其他变量</strong>，继续解决子问题</li>
<li>回溯: 如果当前路径无解，回溯到上一步，<strong>撤销当前的选择</strong>，尝试更多其他解</li>
</ol>
<p>对应的伪代码如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">Solution</span>(问题参数) {
</span></span><span style="display:flex;"><span>    初始化结果集 result
</span></span><span style="display:flex;"><span>    初始化当前路径 path
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#447fcf">backtrack</span>(问题参数, path, result)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    返回结果集 result
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">backtrack</span>(问题参数, path, result) {
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">if</span> 判断当前路径是否已经符合条件 {
</span></span><span style="display:flex;"><span>        将当前路径加入结果集 result
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">for</span> each 可选选择 in 候选集 {
</span></span><span style="display:flex;"><span>        选择: 将当前选择加入路径 path, 形成新的当前路径
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		剪枝: 结束当前递归<span style="color:#a61717;background-color:#e3d2d2">，</span>回溯到上一步
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> 当前路径无效 {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">return</span> 
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		递归: 进入下一层递归
</span></span><span style="display:flex;"><span>        <span style="color:#447fcf">backtrack</span>(更新后的问题参数, path, result)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        回溯: 撤销选择<span style="color:#a61717;background-color:#e3d2d2">，</span>将当前选择从路径 path 中移除
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="leetcode-刷题模板">LeetCode 刷题模板</h3>
<p>笔者根据 LeetCode 中的回溯相关算法题，整理了一个通用刷题模板。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">Solution</span>(list []T) [][]T {
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 初始化结果集
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">var</span> result [][]T
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 初始化当前路径
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">var</span> path []T
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 回溯
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#447fcf">backtrack</span>(list, &amp;path, &amp;result)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 返回结果集
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">return</span> result
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">backtrack</span>(list []T, path *[]T, result *[][]T) {
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 判断当前路径是否满足条件
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">if</span> 满足结束条件 {
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 将当前路径加入结果集
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        *result = <span style="color:#24909d">append</span>(*result, <span style="color:#24909d">append</span>([]T{}, path...))
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 遍历所有可能的选择
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">for</span> _, 可选选择 := <span style="color:#6ab825;font-weight:bold">range</span> 候选集 {
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 做出选择，形成新的当前路径
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        path = <span style="color:#24909d">append</span>(path, 可选选择)
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 继续向下搜索
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        <span style="color:#447fcf">backtrack</span>(list, path, result)
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 撤销选择
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        path = path[:<span style="color:#24909d">len</span>(path)-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="-典型题目-图">💡 典型题目 (图)</h2>
<h3 id="1-电话号码的字母组合">1. 电话号码的字母组合</h3>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://dbwu.tech/images/algorithm/200px-telephone-keypad2svg.png" alt="图片来源: https://leetcode.cn/"></p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#999;font-style:italic"># 示例来自: https://leetcode.cn/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 1：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：digits = <span style="color:#ed9d13">&#34;23&#34;</span>
</span></span><span style="display:flex;"><span>输出：[<span style="color:#ed9d13">&#34;ad&#34;</span>,<span style="color:#ed9d13">&#34;ae&#34;</span>,<span style="color:#ed9d13">&#34;af&#34;</span>,<span style="color:#ed9d13">&#34;bd&#34;</span>,<span style="color:#ed9d13">&#34;be&#34;</span>,<span style="color:#ed9d13">&#34;bf&#34;</span>,<span style="color:#ed9d13">&#34;cd&#34;</span>,<span style="color:#ed9d13">&#34;ce&#34;</span>,<span style="color:#ed9d13">&#34;cf&#34;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 2：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：digits = <span style="color:#ed9d13">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>输出：[]
</span></span></code></pre></div><p><strong>解题思路:</strong></p>
<ol>
<li>将电话键的数字和对应的字母形成一个映射 Map, 便于查找和组合</li>
<li>检测: 判断当前路径是否已经符合条件，也就是判断 <strong>当前路径的长度是否等于数字串的长度</strong></li>
<li>选择: 遍历当前数字对应的字母列表，<strong>将当前字符添加到 当前路径 中，形成新的当前路径</strong></li>
<li>剪枝: 因为题目要求找到所有的字母组合，所以不存在剪枝策略</li>
<li>递归: 将当前路径的长度加一，进入下一层递归</li>
<li>回溯: 选择当前字母列表的下一个字符，回溯到上一步，尝试更多其他组合</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">var</span> letterArray = []<span style="color:#6ab825;font-weight:bold">string</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#ed9d13">&#34;abc&#34;</span>,  <span style="color:#999;font-style:italic">//2
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#ed9d13">&#34;def&#34;</span>,  <span style="color:#999;font-style:italic">//3
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#ed9d13">&#34;ghi&#34;</span>,  <span style="color:#999;font-style:italic">//4
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#ed9d13">&#34;jkl&#34;</span>,  <span style="color:#999;font-style:italic">//5
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#ed9d13">&#34;mno&#34;</span>,  <span style="color:#999;font-style:italic">//6
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#ed9d13">&#34;pqrs&#34;</span>, <span style="color:#999;font-style:italic">//7
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#ed9d13">&#34;tuv&#34;</span>,  <span style="color:#999;font-style:italic">//8
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#ed9d13">&#34;wxyz&#34;</span>, <span style="color:#999;font-style:italic">//9
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">letterCombinations</span>(digits <span style="color:#6ab825;font-weight:bold">string</span>) []<span style="color:#6ab825;font-weight:bold">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#24909d">len</span>(digits) == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> []<span style="color:#6ab825;font-weight:bold">string</span>{}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">var</span> res []<span style="color:#6ab825;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">var</span> str <span style="color:#6ab825;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#447fcf">backtrack</span>(digits, &amp;res, str, <span style="color:#3677a9">0</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> res
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">backtrack</span>(digits <span style="color:#6ab825;font-weight:bold">string</span>, res *[]<span style="color:#6ab825;font-weight:bold">string</span>, str <span style="color:#6ab825;font-weight:bold">string</span>, begin <span style="color:#6ab825;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 如果当前路径的长度是否等于数字串的长度
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// 正好满足一个组合，将当前路径加入到结果集中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> begin == <span style="color:#24909d">len</span>(digits) {
</span></span><span style="display:flex;"><span>		*res = <span style="color:#24909d">append</span>(*res, str)
</span></span><span style="display:flex;"><span>	} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 获取当前数字对应的字符列表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        <span style="color:#999;font-style:italic">// 如数字 2 对应的 {a, b, c}
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		strMap := letterArray[digits[begin]-<span style="color:#ed9d13">&#39;2&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#6ab825;font-weight:bold">range</span> strMap {
</span></span><span style="display:flex;"><span>            <span style="color:#999;font-style:italic">// 将当前字符添加到 当前路径 中，形成新的当前路径
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>            <span style="color:#999;font-style:italic">// 将当前路径的长度 + 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>            <span style="color:#999;font-style:italic">// 进入下一层递归
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#447fcf">backtrack</span>(digits, res, str+<span style="color:#24909d">string</span>(strMap[i]), begin+<span style="color:#3677a9">1</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/letterCombinations.png" alt="电话号码的字母组合 - 执行过程"></p>
<h3 id="2-全排列">2. 全排列</h3>
<p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#999;font-style:italic"># 示例来自: https://leetcode.cn/</span>
</span></span><span style="display:flex;"><span>示例 1：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：nums = [1,2,3]
</span></span><span style="display:flex;"><span>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 2：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：nums = [0,1]
</span></span><span style="display:flex;"><span>输出：[[0,1],[1,0]]
</span></span></code></pre></div><p><strong>解题思路:</strong></p>
<ol>
<li>检测: 判断当前路径是否已经符合条件，也就是判断 <strong>当前路径的长度是否等于参数数组的长度</strong></li>
<li>选择: 遍历数组，<strong>将当前元素添加到 当前路径 中，形成新的当前路径，同时将当前元素标记为已访问</strong> (当前元素已经存在于 当前路径 中)</li>
<li>剪枝: 如果当前元素已访问，直接跳过</li>
<li>递归: 进入下一层递归</li>
<li>回溯: <strong>将当前元素标记为未访问，同时从当前路径中删除当前元素</strong>，回溯到上一步，回溯尝试更多其他组合</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">permute</span>(nums []<span style="color:#6ab825;font-weight:bold">int</span>) [][]<span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">var</span> res [][]<span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">var</span> path []<span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 初始化一个数组作为 Map
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// 用来标记递归过程中已经存在于 “当前路径” 中的元素索引
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// 避免单个元素被重复使用多次
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// 例如正常情况下，[1, 2, 3] [1, 3, 2] 都会正常组合
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// 但是 [1, 1, 1], [2, 2, 2] 属于元素重复使用，不能算作组合
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">var</span> visited = <span style="color:#24909d">make</span>([]<span style="color:#6ab825;font-weight:bold">bool</span>, <span style="color:#24909d">len</span>(nums))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#447fcf">backtrack</span>(nums, &amp;path, &amp;visited, &amp;res)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> res
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">backtrack</span>(nums []<span style="color:#6ab825;font-weight:bold">int</span>, path *[]<span style="color:#6ab825;font-weight:bold">int</span>, visited *[]<span style="color:#6ab825;font-weight:bold">bool</span>, res *[][]<span style="color:#6ab825;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 当前路径的长度是否等于参数数组的长度
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// 正好满足一个组合，将当前路径加入到结果集中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#24909d">len</span>(*path) == <span style="color:#24909d">len</span>(nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 注意这里要拷贝当前路径中的元素
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        <span style="color:#999;font-style:italic">// 因为当前路径变量 path 会在递归过程中发生变化
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		row := <span style="color:#24909d">make</span>([]<span style="color:#6ab825;font-weight:bold">int</span>, <span style="color:#24909d">len</span>(nums))
</span></span><span style="display:flex;"><span>		<span style="color:#24909d">copy</span>(row, *path)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 将拷贝后的路径添加到结果集中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		*res = <span style="color:#24909d">append</span>(*res, row)
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 遍历数组，执行递归 + 回溯操作
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> i, v := <span style="color:#6ab825;font-weight:bold">range</span> nums {
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 剪枝策略
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        <span style="color:#999;font-style:italic">// 如果当前元素未访问
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> !(*visited)[i] {
</span></span><span style="display:flex;"><span>            <span style="color:#999;font-style:italic">// 将当前元素添加到 当前路径 中，形成新的当前路径
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			(*visited)[i] = <span style="color:#6ab825;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>            <span style="color:#999;font-style:italic">// 将当前元素标记为已访问
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			*path = <span style="color:#24909d">append</span>(*path, v)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#999;font-style:italic">// 进入下一层递归
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#447fcf">backtrack</span>(nums, path, visited, res)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#999;font-style:italic">// 将当前元素标记为未访问
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			(*visited)[i] = <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>            <span style="color:#999;font-style:italic">// 从当前路径中删除当前元素
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>            <span style="color:#999;font-style:italic">// 回溯到上一步，尝试更多可能的解
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			*path = (*path)[:<span style="color:#24909d">len</span>(*path)-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/permute.png" alt="全排列 - 执行过程"></p>
<h3 id="3-组合总和">3. 组合总和</h3>
<p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#999;font-style:italic"># 示例来自: https://leetcode.cn/</span>
</span></span><span style="display:flex;"><span>示例 1：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：candidates = [2,3,6,7], <span style="color:#40ffff">target</span> = <span style="color:#3677a9">7</span>
</span></span><span style="display:flex;"><span>输出：[[2,2,3],[7]]
</span></span><span style="display:flex;"><span>解释：
</span></span><span style="display:flex;"><span><span style="color:#3677a9">2</span> 和 <span style="color:#3677a9">3</span> 可以形成一组候选，2 + <span style="color:#3677a9">2</span> + <span style="color:#40ffff">3</span> = <span style="color:#3677a9">7</span> 。注意 <span style="color:#3677a9">2</span> 可以使用多次。
</span></span><span style="display:flex;"><span><span style="color:#3677a9">7</span> 也是一个候选， <span style="color:#40ffff">7</span> = <span style="color:#3677a9">7</span> 。
</span></span><span style="display:flex;"><span>仅有这两种组合。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 2：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入: <span style="color:#40ffff">candidates</span> = [2,3,5], <span style="color:#40ffff">target</span> = <span style="color:#3677a9">8</span>
</span></span><span style="display:flex;"><span>输出: [[2,2,2,2],[2,3,3],[3,5]]
</span></span></code></pre></div><p><strong>解题思路:</strong></p>
<ol>
<li>检测: 判断当前路径是否已经符合条件，也就是判断 <strong>当前查找目标值等于 0</strong></li>
<li>选择: 从指定的起始位置开始遍历数组，<strong>将当前元素添加到 当前路径 中，形成新的当前路径</strong></li>
<li>剪枝: 如果当前元素大于目标值，直接跳过</li>
<li>递归: <strong>将查找目标值减去当前元素</strong>，进入下一层递归</li>
<li>回溯: <strong>当前路径中删除当前元素</strong>，回溯到上一步，回溯尝试更多其他组合</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">combinationSum</span>(candidates []<span style="color:#6ab825;font-weight:bold">int</span>, target <span style="color:#6ab825;font-weight:bold">int</span>) [][]<span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#24909d">len</span>(candidates) == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">var</span> path []<span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">var</span> res [][]<span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 为了在递归过程中优化剪枝
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 提前对数组进行排序
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	sort.<span style="color:#447fcf">Ints</span>(candidates)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#447fcf">backtrack</span>(candidates, target, <span style="color:#3677a9">0</span>, &amp;path, &amp;res)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> res
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">backtrack</span>(candidates []<span style="color:#6ab825;font-weight:bold">int</span>, target, begin <span style="color:#6ab825;font-weight:bold">int</span>, path *[]<span style="color:#6ab825;font-weight:bold">int</span>, res *[][]<span style="color:#6ab825;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 如果当前查找目标值等于 0
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 正好满足一个组合，将当前路径加入到结果集中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> target == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 这里使用了另外一种语法来实现追加功能
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		*res = <span style="color:#24909d">append</span>(*res, <span style="color:#24909d">append</span>([]<span style="color:#6ab825;font-weight:bold">int</span>{}, *path...))
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> i := begin; i &lt; <span style="color:#24909d">len</span>(candidates); i++ {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 剪枝 (前提：已排序)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 数组排序之后
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 如果当前元素大于目标值，那么当前元素之后的所有元素都不可能出现有效的组合了
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 例如数组排序之后为 [2,3,6,7], target = 5
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 那么当前元素遍历到 6 时，就可以直接剪枝了
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> candidates[i] &gt; target {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 将当前元素添加到 当前路径 中，形成新的当前路径
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		*path = <span style="color:#24909d">append</span>(*path, candidates[i])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// candidates 中的 同一个 数字可以 无限制重复被选取
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// i 作为起点，查找 target-candidates[i]
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 指定起始位置为当前位置
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#447fcf">backtrack</span>(candidates, target-candidates[i], i, path, res)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 从当前路径中删除当前元素
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 回溯到上一步，尝试更多可能的解
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		*path = (*path)[:<span style="color:#24909d">len</span>(*path)-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/combinationSum.png" alt="组合总和 - 执行过程"></p>


</article>

<article>
    <img src="https://dbwu.tech/images/wechat.png">
</article>

<article>
    <h3>转载申请</h3>

    <p>
        本作品采用 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> 进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，商业转载请联系作者获得授权。
    </p>
</article>

<section class="post-nav">
    <ul>
        <li>
        
            <a href="https://dbwu.tech/posts/algorithm/leetcode_binary_search_tree_pattern/"><i class="fa fa-chevron-circle-left"></i> LeetCode Binary Search Tree 刷题模板</a>
        
        </li>
        <li>
        
            <a href="https://dbwu.tech/posts/algorithm/dynamic_programming/">动态规划简明教程 - 1 <i class="fa fa-chevron-circle-right"></i> </a>
        
        </li>
    </ul>
</section>
  
    
    
  


<script src="https://giscus.app/client.js"
        data-repo="duanbiaowu/dbwu.tech"
        data-repo-id="R_kgDOIkkjjw"
        data-category="Announcements"
        data-category-id="DIC_kwDOIkkjj84CV78j"
        data-mapping="specific"
        data-term="LeetCode 回溯 刷题模板"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous" async>
</script>




</main>
    <footer>
        <ul>
            <li>
                <h6><a href="mailto:codean.net@gmail.com">codean.net@gmail.com</a> | 
                    <img src="https://dbwu.tech/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" />
                    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61011302001681" target="_blank">陕公网安备 61011302001681 号</a> |
                    <a href="https://beian.miit.gov.cn" target="_blank">陕ICP备2023004378号-1</a> |
                    Rendered by <a href="https://themes.gohugo.io" title="Hugo" target="_blank">Hugo</a>
                </h6>
            </li>
            
            
        </ul>
    </footer>
</div>
<script src="https://dbwu.tech/js/scripts.js"></script>


</body>

</html>

