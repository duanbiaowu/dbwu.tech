<!doctype html>

<html lang="en">

<head>
  <title>LeetCode Binary Tree 刷题模板 - 蛮荆</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="" />
<meta name="author" content="" />
<link rel="shortcut icon" href="https://dbwu.tech/favicon.ico" type="image/x-icon" /><meta property="og:title" content="LeetCode Binary Tree 刷题模板" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dbwu.tech/posts/algorithm/leetcode_binary_tree_pattern/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-18T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-05-18T00:00:00+00:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode Binary Tree 刷题模板"/>
<meta name="twitter:description" content=""/>

<meta name="generator" content="Hugo 0.120.3">
    
    <script src="https://dbwu.tech/js/mathjax-config.js" defer></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CZMGTTFLNY"></script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3261056100776781" crossorigin="anonymous"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-CZMGTTFLNY');
  </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>


  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/normalize.min.css" />
  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/all.min.css" />
  
    
    <link href="//fonts.googleapis.com/css?family=Staatliches" rel="stylesheet">
  
  
  <link rel="stylesheet" type="text/css" href="https://dbwu.tech/css/styles-light.css" />
  </head>

<body>
  <div id="container">
    <header>
      
      <h1>
        <a href="https://dbwu.tech/">蛮荆</a>
      </h1>

      <ul id="social-media">
      </ul>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="active" href="https://dbwu.tech/posts/">
                <i class="fa-li fa  fa-lg"></i><span>归档</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/tags/">
                <i class="fa-li fa  fa-lg"></i><span>标签</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://github.com/duanbiaowu">
                <i class="fa-li fa  fa-lg"></i><span>Github</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/index.xml">
                <i class="fa-li fa  fa-lg"></i><span>RSS</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<article>

    <h1>LeetCode Binary Tree 刷题模板</h1>

    
      
<p>
    <span>2022-05-18</span>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/%E7%AE%97%E6%B3%95">算法</a>
    
</p>

    

    
      

    

    <h2 id="-基础知识">📖 基础知识</h2>
<blockquote>
<p>在计算机科学中，二叉树是一种树形数据结构，其中每个节点最多有两个子节点，称为左子节点和右子节点。</p>
</blockquote>
<h3 id="前序-先序-遍历">前序 (先序) 遍历</h3>
<p>先访问根节点，然后 (递归) 前序遍历左子树，最后 (递归) 前序遍历右子树。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 简单递归版本
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">preOrderTraversal</span>(root *TreeNode) {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> root != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 先访问根节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		fmt.<span style="color:#447fcf">Println</span>(root.Val)
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 然后 (递归) 前序遍历左子树
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#447fcf">preOrderTraversal</span>(root.Left)
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 最后 (递归) 前序遍历右子树
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#447fcf">preOrderTraversal</span>(root.Right)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/preOrderTraversal.png" alt="二叉树前序遍历示例"></p>
<h3 id="中序遍历">中序遍历</h3>
<p>先 (递归) 中序遍历左子树，然后访问根节点，最后 (递归) 中序遍历右子树。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 简单递归版本
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">inOrderTraversal</span>(root *TreeNode) {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> root != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 先 (递归) 中序遍历左子树
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#447fcf">inOrderTraversal</span>(root.Left)
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 然后访问根节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		fmt.<span style="color:#447fcf">Println</span>(root.Val)
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 最后 (递归) 中序遍历右子树
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#447fcf">inOrderTraversal</span>(root.Right)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/inOrderTraversal2.png" alt="二叉树中序遍历示例"></p>
<h3 id="后序遍历">后序遍历</h3>
<p>先 (递归) 后序遍历左子树，然后 (递归) 后序遍历右子树，最后访问根节点。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 简单递归版本
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">postOrderTraversal</span>(root *TreeNode) {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> root != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 先 (递归) 后序遍历左子树
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#447fcf">postOrderTraversal</span>(root.Left)
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 然后 (递归) 后序遍历右子树
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#447fcf">postOrderTraversal</span>(root.Right)
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 最后访问根节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		fmt.<span style="color:#447fcf">Println</span>(root.Val)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/postOrderTraversal.png" alt="二叉树后序遍历示例"></p>
<hr>
<h2 id="-刷题脚手架">🛠️ 刷题脚手架</h2>
<p>笔者根据 LeetCode 官方提供的 二叉树 数据结构，提供了两个简单的脚手架函数，用于快速生成测试和调试代码。</p>
<ol>
<li>根据数组生成对应的二叉树结构，可以省去很多的重复性代码</li>
<li>打印指定二叉树，可以非常直观地看到当前二叉树的树形结构和各个节点的数据</li>
</ol>
<p>因为二叉树相关的大部分题目都需要使用到递归，代码陷入递归后就会比较抽象，无法更加直观地了解当前程序执行状态，这时候就可以使用脚手架代码，打印出每次递归执行后的二叉树的树形结构和节点数据。</p>
<p>例如下边就是一个二叉树的打印后显示，可以根据输出的字符，非常直观地看到二叉树的结构和节点数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>        <span style="color:#3677a9">1</span>   
</span></span><span style="display:flex;"><span>       / <span style="color:#ed9d13">\ </span> 
</span></span><span style="display:flex;"><span>      <span style="color:#3677a9">2</span>   <span style="color:#3677a9">3</span>   
</span></span><span style="display:flex;"><span>         / <span style="color:#ed9d13">\ </span> 
</span></span><span style="display:flex;"><span>        <span style="color:#3677a9">4</span>   <span style="color:#3677a9">5</span>   
</span></span><span style="display:flex;"><span>       / <span style="color:#ed9d13">\ </span> 
</span></span><span style="display:flex;"><span>      <span style="color:#3677a9">6</span>   <span style="color:#3677a9">7</span>   
</span></span></code></pre></div><h3 id="根据数组-切片-生成二叉树">根据数组 (切片) 生成二叉树</h3>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// Tree 节点表示
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">type</span> TreeNode <span style="color:#6ab825;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	Val   <span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>	Left  *TreeNode
</span></span><span style="display:flex;"><span>	Right *TreeNode
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 使用 math.MinInt64 来表示 NULL 节点的值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">var</span> NULL = math.MinInt64
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">GenerateTreeNodesBySlice</span>(nums []<span style="color:#6ab825;font-weight:bold">int</span>) *TreeNode {
</span></span><span style="display:flex;"><span>	n := <span style="color:#24909d">len</span>(nums)
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> n == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	root := &amp;TreeNode{Val: nums[<span style="color:#3677a9">0</span>]}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	queue := <span style="color:#24909d">make</span>([]*TreeNode, <span style="color:#3677a9">1</span>, n&gt;&gt;<span style="color:#3677a9">1</span>+<span style="color:#3677a9">1</span>)
</span></span><span style="display:flex;"><span>	queue[<span style="color:#3677a9">0</span>] = root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> top, index := <span style="color:#3677a9">0</span>, <span style="color:#3677a9">1</span>; index &lt; n; index++ {
</span></span><span style="display:flex;"><span>		node := queue[top]
</span></span><span style="display:flex;"><span>		top++
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> nums[index] != NULL {
</span></span><span style="display:flex;"><span>			node.Left = &amp;TreeNode{Val: nums[index]}
</span></span><span style="display:flex;"><span>			queue = <span style="color:#24909d">append</span>(queue, node.Left)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		index++
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> index &lt; n &amp;&amp; nums[index] != NULL {
</span></span><span style="display:flex;"><span>			node.Right = &amp;TreeNode{Val: nums[index]}
</span></span><span style="display:flex;"><span>			queue = <span style="color:#24909d">append</span>(queue, node.Right)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> root
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>GenerateTreeNodesBySlice</code> 方法用于将指定的切片转换为对应的二叉树结构，注意<strong>切片中的数据顺序和二叉树的层级遍历顺序是一致的</strong>，这样调用起来更简单，例如按照如下的参数进行调用:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>root := <span style="color:#447fcf">GenerateTreeNodesBySlice</span>([]<span style="color:#6ab825;font-weight:bold">int</span>{<span style="color:#3677a9">1</span>, <span style="color:#3677a9">2</span>, <span style="color:#3677a9">3</span>, NULL, NULL, <span style="color:#3677a9">4</span>, <span style="color:#3677a9">5</span>, NULL, NULL, <span style="color:#3677a9">6</span>, <span style="color:#3677a9">7</span>})
</span></span></code></pre></div><p>那么将会生成如下图片所示的二叉树:</p>
<p><img src="https://dbwu.tech/images/algorithm/treenode.png" alt="二叉树示例"></p>
<h3 id="打印二叉树">打印二叉树</h3>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">DumpTree</span>(root *TreeNode) {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 保存需要打印的数字列表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	levelRows := <span style="color:#24909d">make</span>([][]<span style="color:#6ab825;font-weight:bold">int</span>, <span style="color:#3677a9">0</span>)
</span></span><span style="display:flex;"><span>	levelRows = <span style="color:#24909d">append</span>(levelRows, []<span style="color:#6ab825;font-weight:bold">int</span>{root.Val})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 使用 BFS 逐层组装数据
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	queue := []*TreeNode{root}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> <span style="color:#24909d">len</span>(queue) &gt; <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		length := <span style="color:#24909d">len</span>(queue)
</span></span><span style="display:flex;"><span>		row := []<span style="color:#6ab825;font-weight:bold">int</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 从上一层数据中先填充当前层 NULL 数据
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#24909d">len</span>(levelRows) &gt; <span style="color:#3677a9">1</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">for</span> _, val := <span style="color:#6ab825;font-weight:bold">range</span> levelRows[<span style="color:#24909d">len</span>(levelRows)-<span style="color:#3677a9">1</span>] {
</span></span><span style="display:flex;"><span>				<span style="color:#6ab825;font-weight:bold">if</span> val != NULL {
</span></span><span style="display:flex;"><span>					<span style="color:#6ab825;font-weight:bold">break</span>
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#999;font-style:italic">// 上一层的 NULL 节点对应当前层的两个 NULL 子节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>				row = <span style="color:#24909d">append</span>(row, NULL)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#3677a9">0</span>; i &lt; length; i++ {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> queue[i].Left != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>				queue = <span style="color:#24909d">append</span>(queue, queue[i].Left)
</span></span><span style="display:flex;"><span>				row = <span style="color:#24909d">append</span>(row, queue[i].Left.Val)
</span></span><span style="display:flex;"><span>			} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>				row = <span style="color:#24909d">append</span>(row, NULL)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> queue[i].Right != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>				queue = <span style="color:#24909d">append</span>(queue, queue[i].Right)
</span></span><span style="display:flex;"><span>				row = <span style="color:#24909d">append</span>(row, queue[i].Right.Val)
</span></span><span style="display:flex;"><span>			} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>				row = <span style="color:#24909d">append</span>(row, NULL)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		levelRows = <span style="color:#24909d">append</span>(levelRows, row)
</span></span><span style="display:flex;"><span>		queue = queue[length:]
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#447fcf">dumpTreeFormat</span>(levelRows)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">dumpTreeFormat</span>(valList [][]<span style="color:#6ab825;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 打印树形结构
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	width := <span style="color:#24909d">len</span>(valList)
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#6ab825;font-weight:bold">range</span> valList {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 填充左侧空格
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">for</span> j := <span style="color:#3677a9">0</span>; j &lt; width-i-<span style="color:#3677a9">1</span>; j++ {
</span></span><span style="display:flex;"><span>			fmt.<span style="color:#447fcf">Printf</span>(<span style="color:#ed9d13">&#34;  &#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 从第二层开始
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 需要填充上下连接符
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> i &gt; <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">for</span> j := <span style="color:#6ab825;font-weight:bold">range</span> valList[i] {
</span></span><span style="display:flex;"><span>				<span style="color:#6ab825;font-weight:bold">if</span> valList[i][j] == NULL {
</span></span><span style="display:flex;"><span>					fmt.<span style="color:#447fcf">Printf</span>(<span style="color:#ed9d13">&#34;  &#34;</span>)
</span></span><span style="display:flex;"><span>				} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#6ab825;font-weight:bold">if</span> j&amp;<span style="color:#3677a9">1</span> == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>						fmt.<span style="color:#447fcf">Printf</span>(<span style="color:#ed9d13">&#34; / &#34;</span>)
</span></span><span style="display:flex;"><span>					} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>						fmt.<span style="color:#447fcf">Printf</span>(<span style="color:#ed9d13">&#34;\\  &#34;</span>)
</span></span><span style="display:flex;"><span>					}
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			fmt.<span style="color:#447fcf">Println</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 填充下一行数字的左侧空格
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#6ab825;font-weight:bold">for</span> j := <span style="color:#3677a9">0</span>; j &lt; width-i-<span style="color:#3677a9">1</span>; j++ {
</span></span><span style="display:flex;"><span>				fmt.<span style="color:#447fcf">Printf</span>(<span style="color:#ed9d13">&#34;  &#34;</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 填充数字
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">for</span> j := <span style="color:#6ab825;font-weight:bold">range</span> valList[i] {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> valList[i][j] == NULL {
</span></span><span style="display:flex;"><span>				fmt.<span style="color:#447fcf">Printf</span>(<span style="color:#ed9d13">&#34;  &#34;</span>)
</span></span><span style="display:flex;"><span>			} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>				fmt.<span style="color:#447fcf">Printf</span>(<span style="color:#ed9d13">&#34;%d   &#34;</span>, valList[i][j])
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		fmt.<span style="color:#447fcf">Println</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>DumpTree</code> 方法打印指定的二叉树结构，注意<strong>切片中的数据顺序和二叉树的层级遍历顺序是一致的</strong>，这样调用起来更简单，例如按照如下的参数进行调用:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>root := <span style="color:#447fcf">GenerateTreeNodesBySlice</span>([]<span style="color:#6ab825;font-weight:bold">int</span>{<span style="color:#3677a9">1</span>, <span style="color:#3677a9">2</span>, <span style="color:#3677a9">3</span>, NULL, NULL, <span style="color:#3677a9">4</span>, <span style="color:#3677a9">5</span>, NULL, NULL, <span style="color:#3677a9">6</span>, <span style="color:#3677a9">7</span>})
</span></span><span style="display:flex;"><span><span style="color:#447fcf">DumpTree</span>(root)
</span></span></code></pre></div><p>将会打印出如下所示的二叉树结构:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#3677a9">1</span>   
</span></span><span style="display:flex;"><span>       / <span style="color:#ed9d13">\ </span> 
</span></span><span style="display:flex;"><span>      <span style="color:#3677a9">2</span>   <span style="color:#3677a9">3</span>   
</span></span><span style="display:flex;"><span>         / <span style="color:#ed9d13">\ </span> 
</span></span><span style="display:flex;"><span>        <span style="color:#3677a9">4</span>   <span style="color:#3677a9">5</span>   
</span></span><span style="display:flex;"><span>           / <span style="color:#ed9d13">\ </span> 
</span></span><span style="display:flex;"><span>          <span style="color:#3677a9">6</span>   <span style="color:#3677a9">7</span> 
</span></span></code></pre></div><hr>
<h2 id="-典型题目-构建二叉树">💡 典型题目 (构建二叉树)</h2>
<p>前文中提到了二叉树的前序 (先序)、中序、后序遍历方式和对应的实现代码 (递归版本)，LeetCode 中有专门针对这个知识点的题目，即根据某种遍历结果来反向构建对应的二叉树。</p>
<p>想要解决此类题目，必须对前序、中序、后序遍历三种遍历方式聊熟于心。</p>
<h3 id="1-从前序与中序遍历序列构造二叉树">1. 从前序与中序遍历序列构造二叉树</h3>
<p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>输入: <span style="color:#40ffff">preorder</span> = [3,9,20,15,7], <span style="color:#40ffff">inorder</span> = [9,3,15,20,7]
</span></span><span style="display:flex;"><span>输出如下所示的二叉树结构
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/tree.jpg" alt="图片来源: https://leetcode.cn/"></p>
<p><strong>解题思路:</strong></p>
<ol>
<li>根据题目给出的两种遍历方式计算出根节点，<strong>前序遍历数组的第一个元素就是根节点</strong></li>
<li>找到 <strong>中序遍历数组中根节点的值对应的索引</strong>，并根据索引将数组分成两个部分，左半部分就是左子树的所有节点值，右半部分就是右子树的所有节点值</li>
<li>递归数组左半部分，<strong>并将返回值赋值给 根节点的左节点</strong></li>
<li>递归数组右半部分，<strong>并将返回值赋值给 根节点的右节点</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">buildTree</span>(preorder []<span style="color:#6ab825;font-weight:bold">int</span>, inorder []<span style="color:#6ab825;font-weight:bold">int</span>) *TreeNode {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#24909d">len</span>(preorder) == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 前序遍历数组的第一个元素就是根节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	root := &amp;TreeNode{Val: preorder[<span style="color:#3677a9">0</span>]}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#6ab825;font-weight:bold">range</span> inorder {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 找到中序遍历数组中根节点的值对应的索引
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 并根据索引将数组分成两个部分
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> inorder[i] == root.Val {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 左半部分就是左子树的所有节点值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			root.Left = <span style="color:#447fcf">buildTree</span>(preorder[<span style="color:#3677a9">1</span>:i+<span style="color:#3677a9">1</span>], inorder[:i])
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 右半部分就是右子树的所有节点值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			root.Right = <span style="color:#447fcf">buildTree</span>(preorder[i+<span style="color:#3677a9">1</span>:], inorder[i+<span style="color:#3677a9">1</span>:])
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> root
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/buildTree.png" alt="从前序与中序遍历序列构造二叉树 - 代码执行过程"></p>
<h3 id="2-从中序与后序遍历序列构造二叉树">2. 从中序与后序遍历序列构造二叉树</h3>
<p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>输入: <span style="color:#40ffff">inorder</span> = [9,3,15,20,7], <span style="color:#40ffff">postorder</span> = [9,15,7,20,3]
</span></span><span style="display:flex;"><span>输出如下所示的二叉树结构
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/tree.jpg" alt="图片来源: https://leetcode.cn/"></p>
<p><strong>解题思路:</strong></p>
<ol>
<li>根据题目给出的两种遍历方式计算出根节点，<strong>后序遍历数组的最后一个元素就是根节点</strong></li>
<li>找到 <strong>中序遍历数组中根节点的值对应的索引</strong>，并根据索引将数组分成两个部分，左半部分就是左子树的所有节点值，右半部分就是右子树的所有节点值</li>
<li>递归数组左半部分，<strong>并将返回值赋值给 根节点的左节点</strong></li>
<li>递归数组右半部分，<strong>并将返回值赋值给 根节点的右节点</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">buildTree</span>(inorder []<span style="color:#6ab825;font-weight:bold">int</span>, postorder []<span style="color:#6ab825;font-weight:bold">int</span>) *TreeNode {
</span></span><span style="display:flex;"><span>	n := <span style="color:#24909d">len</span>(postorder)
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> n == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 后序遍历数组的最后一个元素就是根节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	root := &amp;TreeNode{Val: postorder[n-<span style="color:#3677a9">1</span>]}
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 删除最后一个元素 (因为已使用)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	postorder = postorder[:n-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#6ab825;font-weight:bold">range</span> inorder {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 找到中序遍历数组中根节点的值对应的索引
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 并根据索引将数组分成两个部分
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> inorder[i] == root.Val {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 左半部分就是左子树的所有节点值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			root.Left = <span style="color:#447fcf">buildTree</span>(inorder[:i], postorder[:i])
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 右半部分就是右子树的所有节点值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			root.Right = <span style="color:#447fcf">buildTree</span>(inorder[i+<span style="color:#3677a9">1</span>:], postorder[i:])
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> root
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/buildTree2.png" alt="从中序与后序遍历序列构造二叉树 - 代码执行过程"></p>
<h3 id="-思考题">🤔 思考题</h3>
<p>根据先序遍历和后序遍历顺序是否可以确定出二叉树的结构？为什么？</p>
<p><strong>根据先序和后序遍历的结果无法唯一确定二叉树</strong>，因为先序遍历和后序遍历序列无法提供足够的信息来唯一确定一棵二叉树。</p>
<p>具体来说:</p>
<ol>
<li>如果只给出先序遍历序列，无法确定左右子树的分界线</li>
<li>如果只给出后序遍历序列，同样无法确定左右子树的分界线</li>
<li>如果同时给出先序遍历和后序遍历序列，依然无法唯一确定二叉树的结构。因为在这种情况下，可以构造出多个不同的二叉树，它们具有相同的先序和后序遍历序列。</li>
</ol>
<p>举个例子:</p>
<p>下面同时给出了先序遍历和后序遍历序列的结果，但是该结果可以对应多棵二叉树结构。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#999;font-style:italic"># 先序遍历结果</span>
</span></span><span style="display:flex;"><span><span style="color:#40ffff">preorder</span> =  [1, 2, 3]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"># 后序遍历结果</span>
</span></span><span style="display:flex;"><span><span style="color:#40ffff">postorder</span> = [3, 2, 1]
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/buildTree3.png" alt="不同的二叉树，拥有相同的遍历结果"></p>
<blockquote>
<p>当二叉树的节点存在单个叶子节点的时候，无法唯一确定二叉树的结构。</p>
</blockquote>
<hr>
<h2 id="-分治算法">📖 分治算法</h2>
<blockquote>
<p>在计算机科学中，分治法是一种很重要的算法，字面上的解释是 “分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题&hellip; 直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p>
</blockquote>
<p>分治算法是很多高效算法的实现基础，例如排序算法中的快速排序和归并排序、傅立叶变换 (快速傅立叶变换) 等。</p>
<p><img src="https://dbwu.tech/images/algorithm/Merge_sort_algorithm_diagram.svg.png" alt="分治算法 - 归并排序 - 代码执行过程"></p>
<p>分治算法会将原问题不断拆分为子问题，然后循环往复，这 <strong>和递归的过程很像</strong>，事实上，大多数分治算法的实现都是递归，虽然使用迭代方法也可以实现对应的版本，但是代码量相比递归版本要多出很多，而且没有明显的性能优势。</p>
<p>二叉树的特征为每个节点有左右两颗子树，非常适合用分治算法进行遍历和求解相关操作，事实上，前文中提到的二叉树的三种遍历方式 (前序、中序、后序)，均是使用分治 (递归) 实现的，从最终的实现代码来看，分治算法非常容易理解而且代码量很少、可读性很高。</p>
<h3 id="刷题模板">刷题模板</h3>
<p><strong>解题思路:</strong></p>
<ol>
<li>识别递归边界</li>
<li>递归左子树计算出结果</li>
<li>递归右子树计算出结果</li>
<li>每个递归内部：对左子数的结果和右子树的结果进行计算并返回，或执行某些具体的操作</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// LeetCode 二叉树刷题模板代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">Solution</span>(root *TreeNode) {
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 终止条件
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#447fcf">divideConquer</span>(root)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 分治递归处理左右子树
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">divideConquer</span>(root *TreeNode) {
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 终止条件
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 处理空节点的情况
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 返回空值或特定值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		... 
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">return</span> 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 递归左子树
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    leftResult := <span style="color:#447fcf">divideConquer</span>(root.Left)
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 递归右子树
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    rightResult := <span style="color:#447fcf">divideConquer</span>(root.Right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 处理递归后的左右子树结果
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	... 
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>只要将解题思路分析清楚，然后确认好递归退出边界，填充具体的处理逻辑，大部分的二叉树题都在 10 行代码左右。</p>
<hr>
<h2 id="-典型题目-分治">💡 典型题目 (分治)</h2>
<h3 id="1-相同的树">1. 相同的树</h3>
<p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p><img src="https://dbwu.tech/images/algorithm/same-tree-1.jpeg" alt="图片来源: https://leetcode.cn/"></p>
<p>如图所示的两棵二叉树是相同的。</p>
<p><img src="https://dbwu.tech/images/algorithm/same-tree-2.jpeg" alt="图片来源: https://leetcode.cn/"></p>
<p>如图所示的两棵二叉树不相同。</p>
<p><strong>解题思路:</strong></p>
<ol>
<li>识别递归边界: 左子树和右子树对应的任意两个节点不相同 (值不相等或者任一节点为 nil), 直接返回 false</li>
<li>递归判断两棵树的左子树是否相同</li>
<li>递归判断两棵树的右子树是否相同</li>
<li>如果左子数和右子树都相等，返回 true, 否则返回 false</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">isSameTree</span>(p *TreeNode, q *TreeNode) <span style="color:#6ab825;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">if</span> p == <span style="color:#6ab825;font-weight:bold">nil</span> &amp;&amp; q == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">if</span> p == <span style="color:#6ab825;font-weight:bold">nil</span> || q == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span> p.Val == q.Val &amp;&amp; <span style="color:#447fcf">isSameTree</span>(p.Left, q.Left) &amp;&amp; <span style="color:#447fcf">isSameTree</span>(p.Right, q.Right)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/isSameTree.png" alt="比较相同的树 - 代码执行过程"></p>
<h3 id="2-翻转二叉树">2. 翻转二叉树</h3>
<p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p>
<p><img src="https://dbwu.tech/images/algorithm/invert1-tree.jpg" alt="图片来源: https://leetcode.cn/"></p>
<blockquote>
<p>Homebrew（简称brew）是一个用于在 macOS 和 Linux 上安装软件包的包管理器，其作者去 Google 面试时，因为写不出来这道翻转二叉树算法题而遭到了拒绝。这本是一个面试官放水，求职者水过的喜剧片，却被主角来了一个神转折。</p>
</blockquote>
<p><img src="https://dbwu.tech/images/algorithm/brew.png" alt="brew 作者被 Google 拒绝"></p>
<p><strong>解题思路:</strong></p>
<ol>
<li>识别递归边界: 如果节点为 nil, 直接返回</li>
<li>交换当前节点的左右两个子节点</li>
<li>递归翻转左子树</li>
<li>递归翻转右子树</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">invertTree</span>(root *TreeNode) *TreeNode {
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">return</span> root
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 交换当前节点的左右两个子节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    root.Left, root.Right = root.Right, root.Left
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 递归翻转左子树
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#447fcf">invertTree</span>(root.Left)
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 递归翻转右子树
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#447fcf">invertTree</span>(root.Right)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span> root
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/invertTree.png" alt="翻转二叉树 - 代码执行过程"></p>
<h3 id="3-对称二叉树">3. 对称二叉树</h3>
<p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
<p>下面是一个典型的对称二叉树示例。</p>
<p><img src="https://dbwu.tech/images/algorithm/1698026966-JDYPDU-image.png" alt="图片来源: https://leetcode.cn/"></p>
<p><strong>解题思路:</strong></p>
<ol>
<li>识别递归边界: 如果 左子树的右节点 和 右子树的左节点 不相同，或者 左子树的左节点 和 右子树的右节点 不相同， (值不相等或者任一节点为 nil), 直接返回 false</li>
<li>递归检测 左子树的右节点 和 右子树的左节点 是否为镜像 (对称)</li>
<li>递归检测 左子树的左节点 和 右子树的右节点 是否为镜像 (对称)</li>
<li>如果两个节点的值相等，返回 true, 否则返回 false</li>
</ol>
<p>和前面两个题稍微有点区别，因为在递归中单次需要判断的两个节点，分别位于左子树和右子树上，需要这里单独设计了一个辅助函数，函数的原型参数为设计为两个节点， 这样就可以传入 [左子树的右节点] + [右子树的左节点] 和 [左子树的左节点] + [右子树的右节点] 两种组合。</p>
<p>那么 root 这个特殊的单独节点如何处理呢？我们可以想象 root 节点还有<strong>一个虚拟的父节点</strong>，这个虚拟的父节点有左右两个子节点全部指向的是 root 节点，所以只需要将 root 作为辅助函数的参数传入两次即可，这样当辅助函数第一次进入递归调用时，就从 root 节点的下一层节点开始检测 (也就是整颗树的第二层)。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">isSymmetric</span>(root *TreeNode) <span style="color:#6ab825;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#447fcf">isMirror</span>(root, root)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 辅助函数
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">isMirror</span>(p, q *TreeNode) <span style="color:#6ab825;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> p == <span style="color:#6ab825;font-weight:bold">nil</span> &amp;&amp; q == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> p == <span style="color:#6ab825;font-weight:bold">nil</span> || q == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> p.Val == q.Val &amp;&amp; <span style="color:#447fcf">isMirror</span>(p.Left, q.Right) &amp;&amp; <span style="color:#447fcf">isMirror</span>(p.Right, q.Left)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/isSymmetric.png" alt="对称二叉树 - 代码执行过程"></p>
<h3 id="4-路径总和">4. 路径总和</h3>
<p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p>
<p><img src="https://dbwu.tech/images/algorithm/pathsum1.jpg" alt="图片来源: https://leetcode.cn/"></p>
<p>当 <code>targetSum = 22</code> 时返回 true, 因为 5 + 4 + 11 + 2 = 22。</p>
<p><strong>解题思路:</strong></p>
<ol>
<li>识别递归边界: 如果节点为 nil, 直接返回 false, 如果左子树和右子树都为 nil, 直接判断并返回目标路径和是否等于当前节点值</li>
<li>在目标路径和基础上减去当前节点的值，得到剩余路径总和，递归计算左子树中是否存在 剩余的路径总和</li>
<li>在目标路径和基础上减去当前节点的值，得到剩余路径总和，递归计算右子树中是否存在 剩余的路径总和</li>
<li>只要左右子树中任一存在路径和，返回 true, 否则返回 false</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">hasPathSum</span>(root *TreeNode, targetSum <span style="color:#6ab825;font-weight:bold">int</span>) <span style="color:#6ab825;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> root.Left == <span style="color:#6ab825;font-weight:bold">nil</span> &amp;&amp; root.Right == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> root.Val == targetSum
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 递归计算左右子树中是否存在剩余路径总和
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#447fcf">hasPathSum</span>(root.Left, targetSum-root.Val) || <span style="color:#447fcf">hasPathSum</span>(root.Right, targetSum-root.Val)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/hasPathSum.png" alt="路径总和 - 代码执行过程"></p>
<h3 id="5-二叉树的最近公共祖先">5. 二叉树的最近公共祖先</h3>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p><img src="https://dbwu.tech/images/algorithm/binarytree.png" alt="图片来源: https://leetcode.cn/"></p>
<p>如图所示，节点 5 和节点 1 的最近公共祖先是节点 3，节点 5 和节点 4 的最近公共祖先是节点 5 (因为根据定义最近公共祖先节点可以为节点本身)。</p>
<p><strong>解题思路:</strong></p>
<ol>
<li>识别递归边界: 如果当前节点为 nil, 或者当前节点本身就是 p 节点或者 q 节点其中一个, 直接返回当前节点</li>
<li>递归计算左子树中 p 节点和 q 节点的公共祖先节点，记为 left</li>
<li>递归计算右子树的 p 节点和 q 节点的公共祖先节点, 记为 right</li>
<li>根据 left 和 right 的值，有可以分为 4 种情况
<ul>
<li>如果 left 和 right 都不等于 nil, <strong>说明 p 节点和 q 节点分布在左子树和右子树中</strong>，那么两者的公共节点就是 root 节点</li>
<li>如果 left 不等于 nil 但是 right 等于 nil, <strong>说明 p 节点和 q 节点都在左子树中</strong>，那么两者的公共节点就是 left 节点</li>
<li>如果 left 等于 nil 但是 right 不等于 nil, <strong>说明 p 节点和 q 节点都在右子树中</strong>，那么两者的公共节点就是 right 节点</li>
<li>如果 left 和 right 都等于 nil, <strong>说明 p 节点和 q 节点至少有一个节点不存在树中</strong>，那么两者的公共节点就是 right 节点，这种情况可能会出现在递归的子树中，例如 p 节点和 q 节点位于树的深层，而 root 节点位于树的浅层 (例如上图中在左子树中查找节点 1 和 8 时，<code>lowestCommonAncestor(5, 1, 8)</code>)</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">lowestCommonAncestor</span>(root, p, q *TreeNode) *TreeNode {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> || p == root || q == root {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> root
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	left := <span style="color:#447fcf">lowestCommonAncestor</span>(root.Left, p, q)
</span></span><span style="display:flex;"><span>	right := <span style="color:#447fcf">lowestCommonAncestor</span>(root.Right, p, q)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 根据 left 和 right 的值，有可以分为 4 种情况
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> left != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> right != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 情况 1 
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#6ab825;font-weight:bold">return</span> root
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 情况 2
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">return</span> left
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 情况 3, 4
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">return</span> right
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/lowestCommonAncestor.png" alt="二叉树的最近公共祖先 - 代码执行过程"></p>
<h3 id="6-二叉树展开为链表">6. 二叉树展开为链表</h3>
<p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>
<p>下面是一个二叉树展开为链表的示例。</p>
<p><img src="https://dbwu.tech/images/algorithm/flaten.jpg" alt="图片来源: https://leetcode.cn/"></p>
<p><strong>解题思路:</strong></p>
<ol>
<li>识别递归边界: 如果节点为 nil, 直接返回</li>
<li>将右子树 (递归) 展开成链表</li>
<li>将左子树 (递归) 展开成链表</li>
<li>在单个递归过程中，将当前 root 节点进行展开:
<ul>
<li>将 root 节点的 Right 节点暂存起来 (tmp 节点)</li>
<li>将 root 节点的 Right 设置为 Left 节点</li>
<li>将 root 节点的 Left 节点设置为 nil</li>
<li>将现在的 Right 节点 (原来的 Left 节点) 连接到 原来的 Right 节点 (tmp 节点)</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">flatten</span>(root *TreeNode)  {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>	}   
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#447fcf">flatten</span>(root.Left)
</span></span><span style="display:flex;"><span>	<span style="color:#447fcf">flatten</span>(root.Right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tmp := root.Right
</span></span><span style="display:flex;"><span>	root.Right = root.Left
</span></span><span style="display:flex;"><span>	root.Left = <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> root.Right != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		root = root.Right
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	root.Right = tmp
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/flatten.png" alt="二叉树展开为链表 - 代码执行过程"></p>
<hr>


</article>

<article>
    <img src="https://dbwu.tech/images/wechat.png">
</article>

<article>
    <h3>转载申请</h3>

    <p>
        本作品采用 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> 进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，商业转载请联系作者获得授权。
    </p>
</article>

<section class="post-nav">
    <ul>
        <li>
        
            <a href="https://dbwu.tech/posts/algorithm/leetcode_sliding_window_pattern/"><i class="fa fa-chevron-circle-left"></i> LeetCode Sliding Window 刷题模板</a>
        
        </li>
        <li>
        
            <a href="https://dbwu.tech/posts/network/vlan/">为什么需要 VLAN 网络 <i class="fa fa-chevron-circle-right"></i> </a>
        
        </li>
    </ul>
</section>
  
    
    
  


<script src="https://giscus.app/client.js"
        data-repo="duanbiaowu/dbwu.tech"
        data-repo-id="R_kgDOIkkjjw"
        data-category="Announcements"
        data-category-id="DIC_kwDOIkkjj84CV78j"
        data-mapping="specific"
        data-term="LeetCode Binary Tree 刷题模板"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous" async>
</script>




</main>
    <footer>
        <ul>
            <li>
                <h6><a href="mailto:codean.net@gmail.com">codean.net@gmail.com</a> | 
                    <img src="https://dbwu.tech/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" />
                    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61011302001681" target="_blank">陕公网安备 61011302001681 号</a> |
                    <a href="https://beian.miit.gov.cn" target="_blank">陕ICP备2023004378号-1</a> |
                    Rendered by <a href="https://themes.gohugo.io" title="Hugo" target="_blank">Hugo</a>
                </h6>
            </li>
            
            
        </ul>
    </footer>
</div>
<script src="https://dbwu.tech/js/scripts.js"></script>


</body>

</html>

