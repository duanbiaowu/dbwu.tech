<!doctype html>

<html lang="en">

<head>
  <title>动态规划简明教程 - 2 - 蛮荆</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="" />
<meta name="author" content="" />
<link rel="shortcut icon" href="https://dbwu.tech/favicon.ico" type="image/x-icon" /><meta property="og:title" content="动态规划简明教程 - 2" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dbwu.tech/posts/algorithm/dynamic_programming_2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-09T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-06-09T00:00:00+00:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="动态规划简明教程 - 2"/>
<meta name="twitter:description" content=""/>

<meta name="generator" content="Hugo 0.120.3">
    
    <script src="https://dbwu.tech/js/mathjax-config.js" defer></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CZMGTTFLNY"></script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3261056100776781" crossorigin="anonymous"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-CZMGTTFLNY');
  </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>


  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/normalize.min.css" />
  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/all.min.css" />
  
    
    <link href="//fonts.googleapis.com/css?family=Staatliches" rel="stylesheet">
  
  
  <link rel="stylesheet" type="text/css" href="https://dbwu.tech/css/styles-light.css" />
  </head>

<body>
  <div id="container">
    <header>
      
      <h1>
        <a href="https://dbwu.tech/">蛮荆</a>
      </h1>

      <ul id="social-media">
      </ul>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="active" href="https://dbwu.tech/posts/">
                <i class="fa-li fa  fa-lg"></i><span>归档</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/tags/">
                <i class="fa-li fa  fa-lg"></i><span>标签</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://github.com/duanbiaowu">
                <i class="fa-li fa  fa-lg"></i><span>Github</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/index.xml">
                <i class="fa-li fa  fa-lg"></i><span>RSS</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<article>

    <h1>动态规划简明教程 - 2</h1>

    
      
<p>
    <span>2022-06-09</span>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/%E7%AE%97%E6%B3%95">算法</a>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/leetcode">LeetCode</a>
    
</p>

    

    
      

    

    <h2 id="-打家劫舍">❓ 打家劫舍</h2>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#999;font-style:italic"># 示例来自: https://leetcode.cn/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 1：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：[1,2,3,1]
</span></span><span style="display:flex;"><span>输出：4
</span></span><span style="display:flex;"><span>解释：偷窃 <span style="color:#3677a9">1</span> 号房屋 (<span style="color:#40ffff">金额</span> = 1) ，然后偷窃 <span style="color:#3677a9">3</span> 号房屋 (<span style="color:#40ffff">金额</span> = 3)。
</span></span><span style="display:flex;"><span>     <span style="color:#40ffff">偷窃到的最高金额</span> = <span style="color:#3677a9">1</span> + <span style="color:#40ffff">3</span> = <span style="color:#3677a9">4</span> 。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 2：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：[2,7,9,3,1]
</span></span><span style="display:flex;"><span>输出：12
</span></span><span style="display:flex;"><span>解释：偷窃 <span style="color:#3677a9">1</span> 号房屋 (<span style="color:#40ffff">金额</span> = 2), 偷窃 <span style="color:#3677a9">3</span> 号房屋 (<span style="color:#40ffff">金额</span> = 9)，接着偷窃 <span style="color:#3677a9">5</span> 号房屋 (<span style="color:#40ffff">金额</span> = 1)。
</span></span><span style="display:flex;"><span>     <span style="color:#40ffff">偷窃到的最高金额</span> = <span style="color:#3677a9">2</span> + <span style="color:#3677a9">9</span> + <span style="color:#40ffff">1</span> = <span style="color:#3677a9">12</span> 。
</span></span></code></pre></div><h2 id="-解题过程">💡 解题过程</h2>
<p>动态规划的子问题分解属于自顶向下的思想，因此在解题时可以按照 <code>暴力搜索 -&gt; 记忆化搜索 -&gt; 动态规划搜索</code> 的顺序来实现代码，这样循序渐进地优化更符合我们的思考过程，也可以降低我们从一开始直接推导状态转移方程的心理压力。</p>
<p>接下来，我们先尝试着给出一个可行的题解，然后在这个基础上慢慢迭代优化。</p>
<p>解题方法函数原型:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">rob</span>(nums []<span style="color:#6ab825;font-weight:bold">int</span>) <span style="color:#6ab825;font-weight:bold">int</span> {}
</span></span></code></pre></div><h3 id="单元测试">单元测试</h3>
<p>为了节省篇幅，这里给出针对本题的单元测试代码，不管 <code>暴力搜索 -&gt; 记忆化搜索 -&gt; 动态规划搜索</code> 哪种实现方式，都可以直接运行该单元测试。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">Test_rob</span>(t *testing.T) {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">type</span> args <span style="color:#6ab825;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>		nums []<span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	tests := []<span style="color:#6ab825;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>		name <span style="color:#6ab825;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>		args args
</span></span><span style="display:flex;"><span>		want <span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>	}{
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#ed9d13">&#34;test-1&#34;</span>,
</span></span><span style="display:flex;"><span>			args{[]<span style="color:#6ab825;font-weight:bold">int</span>{<span style="color:#3677a9">0</span>}},
</span></span><span style="display:flex;"><span>			<span style="color:#3677a9">0</span>,
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#ed9d13">&#34;test-2&#34;</span>,
</span></span><span style="display:flex;"><span>			args{[]<span style="color:#6ab825;font-weight:bold">int</span>{<span style="color:#3677a9">1</span>}},
</span></span><span style="display:flex;"><span>			<span style="color:#3677a9">1</span>,
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#ed9d13">&#34;test-3&#34;</span>,
</span></span><span style="display:flex;"><span>			args{[]<span style="color:#6ab825;font-weight:bold">int</span>{<span style="color:#3677a9">1</span>, <span style="color:#3677a9">2</span>}},
</span></span><span style="display:flex;"><span>			<span style="color:#3677a9">2</span>,
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#ed9d13">&#34;test-4&#34;</span>,
</span></span><span style="display:flex;"><span>			args{[]<span style="color:#6ab825;font-weight:bold">int</span>{<span style="color:#3677a9">1</span>, <span style="color:#3677a9">2</span>, <span style="color:#3677a9">3</span>}},
</span></span><span style="display:flex;"><span>			<span style="color:#3677a9">4</span>,
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#ed9d13">&#34;test-5&#34;</span>,
</span></span><span style="display:flex;"><span>			args{[]<span style="color:#6ab825;font-weight:bold">int</span>{<span style="color:#3677a9">1</span>, <span style="color:#3677a9">2</span>, <span style="color:#3677a9">3</span>, <span style="color:#3677a9">4</span>}},
</span></span><span style="display:flex;"><span>			<span style="color:#3677a9">6</span>,
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#ed9d13">&#34;test-6&#34;</span>,
</span></span><span style="display:flex;"><span>			args{[]<span style="color:#6ab825;font-weight:bold">int</span>{<span style="color:#3677a9">2</span>, <span style="color:#3677a9">7</span>, <span style="color:#3677a9">9</span>, <span style="color:#3677a9">3</span>, <span style="color:#3677a9">1</span>}},
</span></span><span style="display:flex;"><span>			<span style="color:#3677a9">12</span>,
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#ed9d13">&#34;test-7&#34;</span>,
</span></span><span style="display:flex;"><span>			args{[]<span style="color:#6ab825;font-weight:bold">int</span>{<span style="color:#3677a9">2</span>, <span style="color:#3677a9">1</span>}},
</span></span><span style="display:flex;"><span>			<span style="color:#3677a9">2</span>,
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> _, tt := <span style="color:#6ab825;font-weight:bold">range</span> tests {
</span></span><span style="display:flex;"><span>		t.<span style="color:#447fcf">Run</span>(tt.name, <span style="color:#6ab825;font-weight:bold">func</span>(t *testing.T) {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> got := <span style="color:#447fcf">rob</span>(tt.args.nums); got != tt.want {
</span></span><span style="display:flex;"><span>				t.<span style="color:#447fcf">Errorf</span>(<span style="color:#ed9d13">&#34;rob() = %v, want %v&#34;</span>, got, tt.want)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		})
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="-暴力搜索">💪 暴力搜索</h2>
<p><strong>解题思路:</strong></p>
<p>我们可以将参数列表想象成一排房屋，任务是计算从第一个房屋走到最后一个房屋，可以偷取到的最大金额。</p>
<p>对于每一个房屋，我们有两种选择：</p>
<ol>
<li>偷取当前房屋，然后再去偷取下下一个房屋 (因为偷取下一个房屋会引发报警)，这样可以得到 <code>nums[cur] + nums[cur+2]</code> 的金额</li>
<li>不偷取当前房屋，直接去偷取下一个房屋，这样可以得到 <code>nums[cur+1]</code> 的金额</li>
<li>两者之间的最大值就是单次可以偷取到的最大金额</li>
</ol>
<p>举例来说，我们从第 1 个房屋开始，分别偷取第 1, 3, 5 个房屋，可以偷取到的金额是 2 + 9 + 1 = 12，也可以从第 2 个房屋开始，分别偷取第 2, 4 个房屋，可以偷取到的金额是 7 + 3 = 10。</p>
<p><img src="https://dbwu.tech/images/algorithm/rob_2.png" alt="房屋偷取示例"></p>
<h3 id="实现代码">实现代码</h3>
<p>根据上面的解题思路，可以写出如下的递归代码:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 暴力搜索 (超时)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 超时原因: 重复检测
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">robBruteForce</span>(nums []<span style="color:#6ab825;font-weight:bold">int</span>) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#447fcf">robFrom</span>(nums, <span style="color:#3677a9">0</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">robFrom</span>(nums []<span style="color:#6ab825;font-weight:bold">int</span>, begin <span style="color:#6ab825;font-weight:bold">int</span>) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> begin &gt;= <span style="color:#24909d">len</span>(nums) {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 偷取当前房屋
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 偷取完当前房屋后，跳过下一个房屋，去偷下下一个房屋
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	steal := nums[begin] + <span style="color:#447fcf">robFrom</span>(nums, begin+<span style="color:#3677a9">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 不偷取当前房屋
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 去偷下一个房屋
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	skip := <span style="color:#447fcf">robFrom</span>(nums, begin+<span style="color:#3677a9">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 返回两种偷取方案种的最大值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#24909d">max</span>(steal, skip)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="提交超时">提交超时</h3>
<p>运行单元测试:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ go <span style="color:#24909d">test</span> -v -count=<span style="color:#3677a9">1</span> . 
</span></span></code></pre></div><p>输出结果如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>=== RUN   <span style="color:#40ffff">Test_rob</span>
</span></span><span style="display:flex;"><span>=== RUN   Test_rob/test-1
</span></span><span style="display:flex;"><span>=== RUN   Test_rob/test-2
</span></span><span style="display:flex;"><span>=== RUN   Test_rob/test-3
</span></span><span style="display:flex;"><span>=== RUN   Test_rob/test-4
</span></span><span style="display:flex;"><span>=== RUN   Test_rob/test-5
</span></span><span style="display:flex;"><span>=== RUN   Test_rob/test-6
</span></span><span style="display:flex;"><span>=== RUN   Test_rob/test-7
</span></span><span style="display:flex;"><span>--- PASS: Test_rob (0.00s)
</span></span><span style="display:flex;"><span>    --- PASS: Test_rob/test-1 (0.00s)
</span></span><span style="display:flex;"><span>    --- PASS: Test_rob/test-2 (0.00s)
</span></span><span style="display:flex;"><span>    --- PASS: Test_rob/test-3 (0.00s)
</span></span><span style="display:flex;"><span>    --- PASS: Test_rob/test-4 (0.00s)
</span></span><span style="display:flex;"><span>    --- PASS: Test_rob/test-5 (0.00s)
</span></span><span style="display:flex;"><span>    --- PASS: Test_rob/test-6 (0.00s)
</span></span><span style="display:flex;"><span>    --- PASS: Test_rob/test-7 (0.00s)
</span></span><span style="display:flex;"><span>PASS
</span></span><span style="display:flex;"><span>ok      leetcode/0198.House-Robber      0.002s
</span></span></code></pre></div><p>单元测试全部通过，表面上来看，我们的暴力搜索实现没有问题，现在去官方提交看看运行结果。</p>
<p><img src="https://dbwu.tech/images/algorithm/rob.png" alt="提交超时"></p>
<p>提交代码到官方后，提示 “测试超出时间限制”，说明代码的运行时间复杂度太高了，也就是代码运行时间存在优化空间。</p>
<h3 id="超时原因分析">超时原因分析</h3>
<p>在尝试优化暴力搜索之前，我们先来分析一下刚才的算法为何时间复杂度很高。</p>
<p>对于每个房屋，我们都需要检测从其开始到最后一个房屋，可以偷窃到的最大金额，这会产生一个问题: <strong>元素重复检测，也就是因为 “重叠子问题” 导致的 子问题重复计算</strong>。</p>
<p>举例来说，遇到第 1 个房屋 (index = 0) 时，在递归过程中会出现两种方案:</p>
<ol>
<li>偷窃当前房屋，然后 (递归) 偷窃下下个 (第 3 个) 房屋 (index = 2)</li>
<li>不偷窃当前房屋，然后 (递归) 偷窃下个 (第 2 个) 房屋 (index = 1)</li>
</ol>
<p>无论执行哪种方案，第 3 个房屋  (index = 2) 都会被重复检测，以此类推，随着递归的深度不断增加，重复检测的房屋会越来越多。</p>
<p>如图所示，重复检测的房屋使用相同的颜色进行标记。</p>
<p><img src="https://dbwu.tech/images/algorithm/rob_3.png" alt="房屋重复检测示例"></p>
<hr>
<h2 id="-记忆化搜索">📝 记忆化搜索</h2>
<p>现在我们已经分析出了暴力搜索的超时原因 (子问题重复计算)，和 Fibonacci 问题类似，作为优化方案，可以采用一个 <code>额外的备忘录</code> 来记录已经检测过的元素组合，具体来说:</p>
<ol>
<li>递归过程中，如果当前房屋已经检测过，直接返回备忘录中的金额即可</li>
<li>如果当前房屋未检测过，进行递归检测，并在递归结束后将对应的金额添加到备忘录中</li>
</ol>
<p>下面是对应的实现代码:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 记忆化: 避免重复计算
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">robMemo</span>(nums []<span style="color:#6ab825;font-weight:bold">int</span>) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	n := <span style="color:#24909d">len</span>(nums)
</span></span><span style="display:flex;"><span>	memo := <span style="color:#24909d">make</span>([]<span style="color:#6ab825;font-weight:bold">int</span>, n)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 备忘录金额初始化为 -1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#3677a9">0</span>; i &lt; n; i++ {
</span></span><span style="display:flex;"><span>		memo[i] = -<span style="color:#3677a9">1</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#447fcf">robFromMemo</span>(nums, <span style="color:#3677a9">0</span>, &amp;memo)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">robFromMemo</span>(nums []<span style="color:#6ab825;font-weight:bold">int</span>, begin <span style="color:#6ab825;font-weight:bold">int</span>, memo *[]<span style="color:#6ab825;font-weight:bold">int</span>) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> begin &gt;= <span style="color:#24909d">len</span>(nums) {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> (*memo)[begin] != -<span style="color:#3677a9">1</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> (*memo)[begin]
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 偷取当前房屋
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 偷取完当前房屋后，跳过下一个房屋，去偷下下一个房屋
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	steal := nums[begin] + <span style="color:#447fcf">robFrom</span>(nums, begin+<span style="color:#3677a9">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 不偷取当前房屋
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 去偷下一个房屋
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	skip := <span style="color:#447fcf">robFrom</span>(nums, begin+<span style="color:#3677a9">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	(*memo)[begin] = <span style="color:#24909d">max</span>(steal, skip)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 返回两种偷取方案种的最大值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#24909d">max</span>(steal, skip)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/rob_4.png" alt="提交测试通过"></p>
<h3 id="代码执行过程示例">代码执行过程示例</h3>
<p>如图所示，有了备忘录之后，每个元素组合只会被计算一次，计算量会大大减少。</p>
<p><img src="https://dbwu.tech/images/algorithm/rob_5.png" alt="提交测试通过"></p>
<p>由于每个房屋只会被检测一次，所以算法的整体性能是非常高的，当然，因为备忘录使用了额外的内存空间，外加递归过程中产生的堆栈分配，使得内存占用提高很多，所以该记忆化搜索算法属于典型的 “空间换时间”。</p>
<hr>
<h2 id="-动态规划">🚀 动态规划</h2>
<p>现在实现了暴力搜索和记忆化搜索代码之后，我们来思考如何编写动态规划代码。</p>
<h3 id="状态转移方程">状态转移方程</h3>
<blockquote>
<p>设计正确的状态转移方程是解决动态规划问题的前提。</p>
</blockquote>
<p>和记忆化搜索一样，动态规划也通过存储中间结果来避免重复计算，但是动态规划采用循环迭代来实现，尝试从最小的问题开始，逐步构建问题的解。</p>
<blockquote>
<p>自顶向下时，计算从当前房屋开始，到最后一个房屋，可以偷窃的最大金额</p>
<p>自底向上时，计算以当前房屋作为最后一个房屋，根据已有的状态结果，可以偷窃的最大金额</p>
</blockquote>
<p>例如对于房屋 3 来说，其可以偷窃的最大金额为下列两个金额中的较大值:</p>
<ol>
<li>偷窃房屋 3: 金额为房屋 1 和房屋 3 的金额之和</li>
<li>不偷窃房屋 2: 金额为房屋 2 的金额</li>
</ol>
<p>根据这两个规则条件，可以推导出对应的状态转移方程，其中 <code>F(i)</code> 表示可以从第 i 个房屋中偷取到的最大金额，<code>nums[i]</code> 表示第 i 个房屋中的金额。</p>
<p>$$
\begin{align*}
F(i) =
\begin{cases}
\max\ (F(i-2) +  nums[i], F(i-1) ) \ &amp; \text {,} \text{if i &gt; 1} \\
\max\ (nums[1], nums[0] ) \ &amp; \text {,} \text{if i == 1} \\
nums[0] \ &amp; \text {,} \text{if i == 0}
\end{cases}
\end{align*}
$$</p>
<h3 id="实现代码-1">实现代码</h3>
<p>计算出状态转移方程之后，剩下的事情就是将算法步骤直接翻译为代码就可以了，下面的是动态规划的实现代码。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 动态规划
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">rob</span>(nums []<span style="color:#6ab825;font-weight:bold">int</span>) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	n := <span style="color:#24909d">len</span>(nums)
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> n == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#3677a9">1</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> n == <span style="color:#3677a9">1</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> nums[<span style="color:#3677a9">0</span>]
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	dp := <span style="color:#24909d">make</span>([]<span style="color:#6ab825;font-weight:bold">int</span>, n)
</span></span><span style="display:flex;"><span>	dp[<span style="color:#3677a9">0</span>] = nums[<span style="color:#3677a9">0</span>]
</span></span><span style="display:flex;"><span>	dp[<span style="color:#3677a9">1</span>] = <span style="color:#24909d">max</span>(dp[<span style="color:#3677a9">0</span>], nums[<span style="color:#3677a9">1</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#3677a9">2</span>; i &lt; n; i++ {
</span></span><span style="display:flex;"><span>		dp[i] = <span style="color:#24909d">max</span>(dp[i-<span style="color:#3677a9">2</span>]+nums[i], dp[i-<span style="color:#3677a9">1</span>])
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> dp[n-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/rob_6.png" alt="提交通过"></p>
<p>下面是动态规划代码的执行过程部分示例。</p>
<p><img src="https://dbwu.tech/images/algorithm/rob_7.png" alt="动态规划执行过程图解"></p>
<h4 id="状态压缩优化">状态压缩优化</h4>
<p>在刚才的动态规划实现代码中，虽然使用了一个数组来保存中间状态结果，但是最终返回数据时，只需要最后一个状态 (也就是到最后一个房屋时，可以偷窃的最大金额)，而且在状态转换过程中，可以发现 <code>F(i)</code> 之和 <code>F(i - 1), F(i - 2)</code> 有关系，因此可以将状态数组压缩到两个变量 <code>first, second</code> 。</p>
<p>以当前房屋作为 “最后一个房屋” (相对位置)来说：</p>
<ol>
<li>first:  偷窃上上个房屋，可以得到的最大金额，也就是状态转移中的 <code>F(i - 2)</code></li>
<li>second: 偷窃上个房屋，可以得到的最大金额，也就是状态转移中的 <code>F(i - 1)</code></li>
</ol>
<p>当检测完当前房屋之后，<code>second</code> 就变为了 “当前房屋”，<code>first</code> 就变成了 “上个房屋”，两个变量在遍历房屋的过程中 “滚动更新”，不断交替，最后返回 <code>second</code> 变量即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 优化 DP 数组为两个滚动变量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">rob2</span>(nums []<span style="color:#6ab825;font-weight:bold">int</span>) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	n := <span style="color:#24909d">len</span>(nums)
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> n == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#3677a9">1</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> n == <span style="color:#3677a9">1</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> nums[<span style="color:#3677a9">0</span>]
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	first := nums[<span style="color:#3677a9">0</span>]
</span></span><span style="display:flex;"><span>	second := <span style="color:#24909d">max</span>(first, nums[<span style="color:#3677a9">1</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#3677a9">2</span>; i &lt; n; i++ {
</span></span><span style="display:flex;"><span>		first, second = second, <span style="color:#24909d">max</span>(first+nums[i], second)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> second
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/rob_8.png" alt="状态压缩执行过程图解"></p>
<hr>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://github.com/duanbiaowu/leetcode">LeetCode 题解</a></li>
</ul>


</article>

<article>
    <img src="https://dbwu.tech/images/wechat.png">
</article>

<article>
    <h3>转载申请</h3>

    <p>
        本作品采用 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> 进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，商业转载请联系作者获得授权。
    </p>
</article>

<section class="post-nav">
    <ul>
        <li>
        
            <a href="https://dbwu.tech/posts/algorithm/dynamic_programming/"><i class="fa fa-chevron-circle-left"></i> 动态规划简明教程 - 1</a>
        
        </li>
        <li>
        
            <a href="https://dbwu.tech/posts/network/vlan/">为什么需要 VLAN 网络 <i class="fa fa-chevron-circle-right"></i> </a>
        
        </li>
    </ul>
</section>
  
    
    
  


<script src="https://giscus.app/client.js"
        data-repo="duanbiaowu/dbwu.tech"
        data-repo-id="R_kgDOIkkjjw"
        data-category="Announcements"
        data-category-id="DIC_kwDOIkkjj84CV78j"
        data-mapping="specific"
        data-term="动态规划简明教程 - 2"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous" async>
</script>




</main>
    <footer>
        <ul>
            <li>
                <h6><a href="mailto:codean.net@gmail.com">codean.net@gmail.com</a> | 
                    <img src="https://dbwu.tech/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" />
                    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61011302001681" target="_blank">陕公网安备 61011302001681 号</a> |
                    <a href="https://beian.miit.gov.cn" target="_blank">陕ICP备2023004378号-1</a> |
                    Rendered by <a href="https://themes.gohugo.io" title="Hugo" target="_blank">Hugo</a>
                </h6>
            </li>
            
            
        </ul>
    </footer>
</div>
<script src="https://dbwu.tech/js/scripts.js"></script>


</body>

</html>

