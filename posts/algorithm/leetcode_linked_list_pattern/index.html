<!doctype html>

<html lang="en">

<head>
  <title>LeetCode Linked List 刷题模板 - 蛮荆</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="" />
<meta name="author" content="" />
<link rel="shortcut icon" href="https://dbwu.tech/favicon.ico" type="image/x-icon" /><meta property="og:title" content="LeetCode Linked List 刷题模板" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dbwu.tech/posts/algorithm/leetcode_linked_list_pattern/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-10T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-03-10T00:00:00+00:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode Linked List 刷题模板"/>
<meta name="twitter:description" content=""/>

<meta name="generator" content="Hugo 0.120.3">
    
    <script src="https://dbwu.tech/js/mathjax-config.js" defer></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CZMGTTFLNY"></script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3261056100776781" crossorigin="anonymous"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-CZMGTTFLNY');
  </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>


  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/normalize.min.css" />
  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/all.min.css" />
  
    
    <link href="//fonts.googleapis.com/css?family=Staatliches" rel="stylesheet">
  
  
  <link rel="stylesheet" type="text/css" href="https://dbwu.tech/css/styles-light.css" />
  </head>

<body>
  <div id="container">
    <header>
      
      <h1>
        <a href="https://dbwu.tech/">蛮荆</a>
      </h1>

      <ul id="social-media">
      </ul>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="active" href="https://dbwu.tech/posts/">
                <i class="fa-li fa  fa-lg"></i><span>归档</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/tags/">
                <i class="fa-li fa  fa-lg"></i><span>标签</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://github.com/duanbiaowu">
                <i class="fa-li fa  fa-lg"></i><span>Github</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/index.xml">
                <i class="fa-li fa  fa-lg"></i><span>RSS</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<article>

    <h1>LeetCode Linked List 刷题模板</h1>

    
      
<p>
    <span>2022-03-10</span>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/%E7%AE%97%E6%B3%95">算法</a>
    
</p>

    

    
      

    

    <h2 id="链表特点">链表特点</h2>
<p><img src="https://dbwu.tech/images/algorithm/linked_lists_vs_array.jpg" alt="图片来源: https://en.wikipedia.org/"></p>
<p>相较于数组，链表的特点如下：</p>
<h3 id="优点">优点</h3>
<ol>
<li>动态长度：链表的长度可以动态调整 (内存充足的情况下)，不需要像数组预先指定大小</li>
<li>内存无需连续：链表中的元素在内存中可以是不连续的，提升内存使用灵活性</li>
</ol>
<h3 id="缺点">缺点</h3>
<ol>
<li>随机访问低效：链表随机访问时，需要从头节点开始遍历，时间复杂度为 O(N)</li>
<li>插入和删除操作低效：链表中插入和删除元素时，需要移动大量元素，时间复杂度为 O(N)</li>
<li>额外的存储空间：链表每个节点需要额外的指针来指向下一个节点</li>
<li>内存局部性较差：链表中的元素在内存中是分散存储的，可能导致缓存不命中，降低访问效率</li>
</ol>
<h2 id="刷题概述">刷题概述</h2>
<p><strong>链表的本质和表现形式都非常简单，就是将不同的节点使用指针连接起来而已</strong>。LeetCode 上面链表类大部分问题，如果在纸上画出解题思路和过程，都是非常直观简单的问题，但是真正写代码时，想要快速写出 Bug Free 的代码依然需要花费一番功夫，这其中的症结主要在于两点:</p>
<ol>
<li><strong>链表各节点之间依赖于指针连接</strong>，如果任意两个节点之间丢失了这个指针，例如将指针错误指向节点，就是导致整个链表无法进行连接，结果必然是错误的，80% 的错误都是因为这个原因导致的</li>
<li><strong>链表类问题对空间复杂度的要求基本都是 O(1)</strong>, 这意味着不能引入额外的数据结构来辅助解决问题，例如反转链表问题：要求只能在原地反转，不能引入额外的 栈 (Stack) 来辅助存储节点，然后在栈存储的基础上再反转节点</li>
</ol>
<p>但是作为高频笔试题类目，链表的重要性不言而喻，必须熟练掌握而且能够快速解决常见的题目，毕竟从面试官的角度来说，求职者可以写不出动态规划、贪心、回溯等题目，但是如果链表类题目都写不出来，那基本上凉凉了。</p>
<h3 id="笨办法">笨办法</h3>
<p>笔者没有太多关于链表类题目的 “技巧” 可以分享，自己在刷题时采用的是最笨的方法，遇到问题时，在纸上画一画链表各节点的状态变化，理清思路，确保没有大的问题之后开始写代码 + 调试过程，然后先保证能写出可以 AC 的代码，最后再对照 LeetCode 官方和其他大佬给出的解题方案学习优化。</p>
<hr>
<h2 id="概念对齐">概念对齐</h2>
<p>市场上关于《数据结构和算法》的图书多如牛毛，每本书中关于相同的概念可能会有不同的名词和描述，为了规范上下文概念，本文将各名词同一如下：</p>
<ul>
<li>节点: 链表中的任意节点，包含头节点和尾节点</li>
<li>头节点：指向链表第一个节点的指针 (一般指参数传递的指针)</li>
<li>尾节点: 指向链表最后一个节点的指针 (一般用于链表遍历时扫描判断)，<strong>尾节点的指针指向 NULL</strong></li>
</ul>
<p><img src="https://dbwu.tech/images/algorithm/linked_list_demo.png" alt="链表基本概念"></p>
<h2 id="常见错误">常见错误</h2>
<h3 id="直接使用-head-指针遍历">直接使用 head 指针遍历</h3>
<p>最常见的错误就是直接使用参数链表 head 头节点指针进行遍历，造成的问题就是随着 head 指针不断遍历链表，<strong>head 指针最初指向链表的头节点的连接关系就丢失了</strong>。</p>
<p>典型的错误代码如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">Solution</span>(head *ListNode) *ListNode {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 直接使用 head 遍历链表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">for</span> head != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        head = head.Next
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span> head
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/head_point_lost.png" alt="head 指针最终丢失最初的指向"></p>
<p>针对这个问题的解决方案是使用一个临时变量来表示扫描链表时的索引指针，这样不管临时指针变量怎么变化，head 指针变量永远指向链表的头节点。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">Solution</span>(head *ListNode) *ListNode {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 临时变量 cur 来表示扫描链表时的索引指针
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	cur := head
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 直接使用 cur 遍历链表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">for</span> cur != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        cur = cur.Next
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span> head
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="节点指针丢失">节点指针丢失</h3>
<p>遍历链表时，节点和节点之间的连接关系丢失，指针指向了错误的节点，造成的结果就是链表断开了，分成 2 个或多个子链表，更严重的情况下甚至会出现环形链表。</p>
<p><img src="https://dbwu.tech/images/algorithm/node_point_lost.png" alt="节点指针丢失"></p>
<h3 id="头指针为-nil">头指针为 nil</h3>
<p>这个边界检查好就行，链表类问题答案中有 1/3 的代码是边界检查，下面是一个通用类模板:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 如果节点为空 或者 只有一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 直接返回就好了，无需处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">if</span> head == <span style="color:#6ab825;font-weight:bold">nil</span> || head.Next == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="通用脚手架代码">通用脚手架代码</h2>
<p>虽然 LeetCode 题解一般没有多少代，但是良好的软件工程实践必须保持，单元测试还是要写的，编写 LeetCode 题解代码的同时顺带编写配套的单元测试，可以带来两个好处：</p>
<ol>
<li>可以在本地快速运行测试代码，相对 LeetCode 在线编码提升编码效率</li>
<li>遇到无法通过的测试用例时，可以在本地进行调试，相对 LeetCode 在线 Debug 过程更加可控</li>
</ol>
<p>所有题解的测试用例可以直接复制粘贴官方和社区提供的，无需自己从零开始编写，所以基本不会有太多的额外时间消耗。</p>
<h3 id="脚手架">脚手架</h3>
<p>笔者根据 LeetCode 官方提供的链表数据结构，提供了两个简单的脚手架函数，用于快速生成测试和调试代码</p>
<ol>
<li>根据数组生成对应的链表，可以省去很多的重复性链表代码</li>
<li>打印指定的链表，可以非常直观地看到当前链表的状态和各个节点的数据，判断链表是否异常，例如节点断开、头指针丢失等问题</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 链表节点定义
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">type</span> ListNode <span style="color:#6ab825;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	Val  <span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>	Next *ListNode
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 根据指定的数组 (切片) 生成对应的链表并返回头节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">GenerateListNodesByArray</span>(nums []<span style="color:#6ab825;font-weight:bold">int</span>) *ListNode {
</span></span><span style="display:flex;"><span>	dummy := &amp;ListNode{}
</span></span><span style="display:flex;"><span>	cur := dummy
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> _, val := <span style="color:#6ab825;font-weight:bold">range</span> nums {
</span></span><span style="display:flex;"><span>		cur.Next = &amp;ListNode{Val: val}
</span></span><span style="display:flex;"><span>		cur = cur.Next
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> dummy.Next
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 打印指定的链表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">Dump</span>(head *ListNode) *ListNode {
</span></span><span style="display:flex;"><span>	cur := head
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 直接使用 cur 遍历链表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">for</span> cur != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		fmt.<span style="color:#447fcf">Printf</span>(<span style="color:#ed9d13">&#34;%d -&gt; \t&#34;</span>, cur.Val)
</span></span><span style="display:flex;"><span>        cur = cur.Next
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	fmt.<span style="color:#447fcf">Println</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="哨兵模式">哨兵模式</h2>
<blockquote>
<p>最经典的链表解题方案 (或者没有) 之一。</p>
</blockquote>
<p>哨兵模式主要应用在以下题型:</p>
<ul>
<li>需要保留参数 head 头节点的指针并作为返回值返回，例如 “删除链表中的节点” 类型问题</li>
<li>无法提前确认返回值具体是哪个节点，例如 “合并链表” 类型问题，“反转链表” 类型问题</li>
</ul>
<p><img src="https://dbwu.tech/images/algorithm/linked_list_dummy_node_1.png" alt="哨兵节点永远指向 Head 头节点"></p>
<h3 id="代码模板">代码模板</h3>
<p>使用哨兵模式时，要记住两个必需的核心变量:</p>
<ol>
<li>哨兵节点：作为基准保存返回值，其 Next 指向具体的返回值，一般命名为 <code>dummy</code>, 当然也有人称之为 <code>哑巴节点</code></li>
<li>扫描节点：从链表头节点开始向后扫描，直到尾节点或符合条件的节点，作用简单来说就是 <code>游标指针</code>，一般命名为 <code>cur</code></li>
</ol>
<p>下面是一个典型的使用哨兵模式解题的代码模板:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">Solution</span>(head *ListNode) *ListNode {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 哨兵节点指向 头节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    dummy := &amp;ListNode{Next: head}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 游标节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    cur := dummy
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> cur.Next != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 执行某些解题逻辑代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 更新游标指针
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 虽然游标指针一直在变化，但是哨兵节点指针的指向没有发生变化
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		cur = cur.Next
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 返回哨兵节点指向的 头节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">return</span> dummy.Next
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="-相关题目">💡 相关题目</h3>
<p>读者可以通过对比题解代码和上文中的模板代码，来体会通过模板快速解题的效率和细节。</p>
<h4 id="1-合并两个有序链表">1. 合并两个有序链表</h4>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><img src="https://dbwu.tech/images/algorithm/mergeTwoLists.jpg" alt="图片来源: https://leetcode.cn"></p>
<p>快速套用哨兵节点模板:</p>
<ul>
<li>一个哨兵节点: 用于存储合并后的链表头节点，并在最后返回</li>
<li>一个游标节点：用于遍历并更新合并后的链表</li>
<li><strong>填充具体的解题逻辑</strong>：同时遍历链表 1 和链表 2，将两个链表中的当前较小值插入到合并到后的链表中，同时注意处理好边界条件</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 非 VIP 用户提交
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 执行用时分布击败 100.00% 使用 Go 的用户
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 消耗内存分布击败 81.81% 使用 Go 的用户
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">mergeTwoLists</span>(l1 *ListNode, l2 *ListNode) *ListNode {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 哨兵节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	dummy := &amp;ListNode{Val: <span style="color:#3677a9">0</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 游标节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	cur := dummy
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> l1 != <span style="color:#6ab825;font-weight:bold">nil</span> &amp;&amp; l2 != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> l1.Val &lt; l2.Val {
</span></span><span style="display:flex;"><span>			cur.Next = l1
</span></span><span style="display:flex;"><span>			l1 = l1.Next
</span></span><span style="display:flex;"><span>		} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>			cur.Next = l2
</span></span><span style="display:flex;"><span>			l2 = l2.Next
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		cur = cur.Next
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> l1 == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		cur.Next = l2
</span></span><span style="display:flex;"><span>	} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>		cur.Next = l1
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> dummy.Next
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面是题解代码执行过程，其中每一步合并后的节点，使用不同的颜色和填充进行区分：</p>
<p><img src="https://dbwu.tech/images/algorithm/two_linked_list_merge.png" alt="合并两个有序链表执行过程"></p>
<h4 id="2-两数相加">2. 两数相加</h4>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p><img src="https://dbwu.tech/images/algorithm/addtwonumber1.jpg" alt="图片来源: https://leetcode.cn"></p>
<p>这道题的本质也是 “合并两个链表”，不过和上一题的区别在于合并的不是两个链表中单独的节点，而是对应节点上面的值。</p>
<p>快速套用哨兵节点模板:</p>
<ul>
<li>一个哨兵节点: 用于存储合并后的头节点并在最后返回</li>
<li>一个游标节点：用于遍历并更新合并后的链表</li>
<li><strong>填充具体的解题逻辑</strong>：同时遍历链表 1 和链表 2，取出两个链表的当前节点进行相加，并将结果放入合并后的链表的下一个节点，同时注意处理好 “进位制” 和边界条件</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 非 VIP 用户提交
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 执行用时分布击败 57.35% 使用 Go 的用户
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 消耗内存分布击败 43.80% 使用 Go 的用户
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">addTwoNumbers</span>(l1 *ListNode, l2 *ListNode) *ListNode {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 哨兵节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    dummy := &amp;ListNode{Val: <span style="color:#3677a9">0</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 游标节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    cur := dummy
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    n1, n2, carry := <span style="color:#3677a9">0</span>, <span style="color:#3677a9">0</span>, <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">for</span> l1 != <span style="color:#6ab825;font-weight:bold">nil</span> || l2 != <span style="color:#6ab825;font-weight:bold">nil</span> || carry != <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 计算链表 1 的当前值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        <span style="color:#6ab825;font-weight:bold">if</span> l1 == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>            n1 = <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>            n1 = l1.Val
</span></span><span style="display:flex;"><span>            l1 = l1.Next
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 计算链表 2 的当前值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        <span style="color:#6ab825;font-weight:bold">if</span> l2 == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>            n2 = <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>            n2 = l2.Val
</span></span><span style="display:flex;"><span>            l2 = l2.Next
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 当计算出来的新节点放到当前节点后面
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        cur.Next = &amp;ListNode{Val: (n1 + n2 + carry) % <span style="color:#3677a9">10</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 计算是否需要进位
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        carry = (n1 + n2 + carry) / <span style="color:#3677a9">10</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 更新当前节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        cur = cur.Next
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span> dummy.Next
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/two_linked_list_add.png" alt="两个链表相加执行过程"></p>
<h4 id="3-两两交换链表中的节点">3. 两两交换链表中的节点</h4>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><img src="https://dbwu.tech/images/algorithm/swap-nodes-in-pairs.png" alt="图片来源: https://leetcode.cn"></p>
<p>快速套用哨兵节点模板:</p>
<ul>
<li>一个哨兵节点: 用于存储交换后的头节点并在最后返回 (也就是原始链表的第二个节点)</li>
<li>一个游标节点：用于遍历并更新合并后的链表</li>
<li><strong>填充具体的解题逻辑</strong>：使用游标指针遍历链表，当游标指针的下一个节点和下下一个节点同时不为 nil 时，交换两者</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 非 VIP 用户提交
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 执行用时分布击败 100.00% 使用 Go 的用户
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 消耗内存分布击败 76.28% 使用 Go 的用户
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">swapPairs</span>(head *ListNode) *ListNode {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 哨兵节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	dummy := &amp;ListNode{Next: head}
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 游标节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	cur := dummy
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// cur 必须从 dummy 开始
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 这样才可以更换 dummy.Next (head) 指针的指向
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 因为最终要返回 dummy.Next
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// cur 初始化时指向 dummy
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 但是在遍历过程中会不断发生变更
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 而 dummy 只会在第一次指向 head.Next.Next 之后就不会发生改变
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 正确的答案，最终的 dummy.Next 指向的是源链表的第二个节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> cur.Next != <span style="color:#6ab825;font-weight:bold">nil</span> &amp;&amp; cur.Next.Next != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		node1 := cur.Next
</span></span><span style="display:flex;"><span>		node2 := cur.Next.Next
</span></span><span style="display:flex;"><span>		cur.Next = node2
</span></span><span style="display:flex;"><span>		node1.Next = node2.Next
</span></span><span style="display:flex;"><span>		node2.Next = node1
</span></span><span style="display:flex;"><span>		cur = node1
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> dummy.Next
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/swapPairs2.png" alt="两两交换链表中的节点 - 执行过程"></p>
<h3 id="双哨兵模式">双哨兵模式</h3>
<p>有的时候，需要保存的基准节点可能不止一个，怎么办？那就需要多少个基准节点，就使用多少个哨兵节点就好了，例如下面的这道题。</p>
<h4 id="1-分隔链表">1. 分隔链表</h4>
<p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。你应当 保留 两个分区中每个节点的初始相对位置。</p>
<p><img src="https://dbwu.tech/images/algorithm/linked_list_partition.png" alt="图片来源: https://leetcode.cn"></p>
<p>题目的要求很简单，就是将小于 X 的节点链接起来形成一个链表，然后将大于等于 X 的节点链接起来形成一个链表，然后将两个链表前后串起来即可，不需要实现排序。</p>
<p>快速套用哨兵节点模板:</p>
<ul>
<li>两个哨兵节点: 将小于 X 的所有节点单独形成一个链表 small, 将大于等于 X 的所有节点单独形成一个链表 large, 声明两个哨兵节点分别指向 small 链表的头节点和 large 链表的头节点</li>
<li>一个游标节点：用于遍历并更新合并后的链表，因为最终返回值是 small 链表的头节点，所以可以直接使用参数 head 指针作为游标指针</li>
<li><strong>填充具体的解题逻辑</strong>：使用游标指针遍历链表，将小于 X 的节点插入到链表 small 末尾, 将大于等于 X 的节点插入到链表 large 末尾，遍历完成之后，连接 small 链表和 large 链表，并切断 large 链表的尾指针指向</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">partition</span>(head *ListNode, x <span style="color:#6ab825;font-weight:bold">int</span>) *ListNode {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 哨兵节点：指向 small 链表的头节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	smallDummy := &amp;ListNode{}
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 哨兵节点：指向 large 链表的头节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	largeDummy := &amp;ListNode{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 小于 X 的所有节点形成的链表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	small := smallDummy
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 大于等于 X 的所有节点形成的链表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	large := largeDummy
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 直接使用 head 作为游标指针
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> head != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> head.Val &lt; x {
</span></span><span style="display:flex;"><span>			small.Next = head
</span></span><span style="display:flex;"><span>			small = small.Next
</span></span><span style="display:flex;"><span>		} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>			large.Next = head
</span></span><span style="display:flex;"><span>			large = large.Next
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		head = head.Next
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 切断 large 链表的尾指针
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 例如源链表为 1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2, X = 3
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 那么在分割完成后
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// small 链表为 1 -&gt; 2 -&gt; 2 -&gt; 5 ...
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// large 链表为 4 -&gt; 3 -&gt; 5 -&gt; 2 ...
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 这时就需要将 large 链表末尾指针给切断，否则就形成了 “环形链表”
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	large.Next = <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 将 small 链表连接到 large 链表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	small.Next = largeDummy.Next
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 返回 small 链表的头节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">return</span> smallDummy.Next
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/two_linked_list_partition_2.png" alt="两个链表分隔 + 合并执行过程"></p>
<hr>
<h2 id="快慢指针">快慢指针</h2>
<blockquote>
<p>最经典的链表解题方案 (如果有的话) 之二。</p>
</blockquote>
<p>顾名思义，快慢指针就是使用两个指针来遍历链表，快指针走的快 (例如每次扫描两个及以上节点)，慢指针走的慢 (例如每次扫描一个节点)，严格意义上来说，<strong>“快慢指针” 属于 “双指针” 的解题类型范畴</strong>，之所以在这篇关于链表类的文章中单独拎出来，主要有两点：</p>
<ol>
<li>链表的节点就是由指针连接起来的，天然适用于快慢指针来遍历，比如我们可以使用 <strong>快慢指针来简洁实现 “找到链表的中间节点”</strong></li>
<li>链表类型的某些问题，使用快慢指针是最简洁优雅的方案，例如经典的 “判断链表中是否存在环问题”</li>
</ol>
<h3 id="代码模板-1">代码模板</h3>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">Solution</span>(head *ListNode) <span style="color:#6ab825;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 通用边界检查
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">if</span> head == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 初始化快、慢两个指针
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    slow, fast := head, head.Next
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 主要这里的边界检查
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 因为快指针每次走两步，需要需要检测两步之内的节点是否为 nil
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 慢指针无需执行边界检查
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 因为只要快指针不为 nil, 慢指针肯定也不会为 nil
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">for</span> fast != <span style="color:#6ab825;font-weight:bold">nil</span> &amp;&amp; fast.Next != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 执行某些解题逻辑代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 快指针每次走 2 步 
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        fast = fast.Next.Next
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 慢指针每次走 1 步
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        slow = slow.Next
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/fast_slow_point_demo.png" alt="快慢指针执行过程"></p>
<h3 id="-相关题目-1">💡 相关题目</h3>
<p>读者可以通过对比题解代码和上文中的模板代码，来体会通过模板快速解题的效率和细节。</p>
<h4 id="1-环形链表">1. 环形链表</h4>
<p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p><img src="https://dbwu.tech/images/algorithm/linked_list_has_cycle.png" alt="图片来源: https://leetcode.cn"></p>
<p>快速套用快慢指针解题模板:</p>
<ul>
<li>定义快慢指针: 快指针每次扫描 2 个节点，慢指针每次扫描 1 个节点</li>
<li><strong>填充具体的解题逻辑</strong>：因为慢指针扫描到链表一半长度的时候，快指针就扫描到链表的末尾了，所以如果链表存在环的话，那么快慢两个指针一定会相遇</li>
</ul>
<p><strong>还有一个细节需要注意</strong>: 即使只有一个节点，也可能是环形链表，所以下面的代码无法通过全部测试。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">if</span> head == <span style="color:#6ab825;font-weight:bold">nil</span> || head.Next == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 非 VIP 用户提交
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 执行用时分布击败 58.65% 使用 Go 的用户
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 消耗内存分布击败 79.63% 使用 Go 的用户
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">hasCycle</span>(head *ListNode) <span style="color:#6ab825;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 需要注意的是，即使只有一个节点，也可能是环形链表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 所以这段代码无法通过测试
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// if head == nil || head.Next == nil {
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 	return false
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// }
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> head == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 快指针先走一步，避免链表只有一个节点时误判为环形链表
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	slow, fast := head, head.Next
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> fast != <span style="color:#6ab825;font-weight:bold">nil</span> &amp;&amp; fast.Next != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> slow == fast {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		fast = fast.Next.Next
</span></span><span style="display:flex;"><span>		slow = slow.Next
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/linked_list_has_cycle_2.png" alt="链表中检测是否存在环 - 执行过程"></p>
<h4 id="2-删除重复节点">2. 删除重复节点</h4>
<p>给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</p>
<p><img src="https://dbwu.tech/images/algorithm/remove-duplicates-from-sorted-list-ii.jpeg" alt="图片来源: https://leetcode.cn"></p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 非 VIP 用户提交
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 执行用时分布击败 59.62% 使用 Go 的用户
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 消耗内存分布击败 34.55% 使用 Go 的用户
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">deleteDuplicatesIteratively</span>(head *ListNode) *ListNode {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> head == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> head
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	dummy := &amp;ListNode{Next: head}
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 这里哨兵节点极大提高了代码可读性
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 直接从 cur.Next (也就是头节点) 开始
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 这样即使头节点就是重复元素，也可以直接将其删除，然后将哨兵节点的 Next 指针指向到第一个不重复的节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	cur := dummy
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> cur.Next != <span style="color:#6ab825;font-weight:bold">nil</span> &amp;&amp; cur.Next.Next != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> cur.Next.Val == cur.Next.Next.Val {
</span></span><span style="display:flex;"><span>			x := cur.Next.Val
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 删除掉所有和当前节点值相等的后续节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 注意这里不改变 cur 指针的指向，而是直接改变 cur.Next 指针的指向
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 也就是说，每次判断的都是以 [下个节点] 和 [下下个节点]
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 当前节点从哨兵节点开始，本身就是不重复的值，因为重复的值在节点连接过程中都被删除掉了
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#6ab825;font-weight:bold">for</span> cur.Next != <span style="color:#6ab825;font-weight:bold">nil</span> &amp;&amp; cur.Next.Val == x {
</span></span><span style="display:flex;"><span>				cur.Next = cur.Next.Next
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>			cur = cur.Next
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> dummy.Next
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/remove-duplicates-from-sorted-list-ii.png" alt="删除重复节点 - 执行过程"></p>
<p>虽然上面的题解代码中并没有使用到快慢指针，而只是使用一个 cur 指针作为遍历指针，但其实整个思路和快慢指针是一致的，我们可以外部的 cur 指针遍历循环看作是慢指针，每次走一步，将内部的 cur 指针遍历看作是快指针，每次都 N 步 (N 等于重复的数字个数)，感兴趣的读者可以将两层循环替换为快慢两个指针来扫描，体验一下思路相通的妙处。除了快慢指针之外，这个解题方案还用到了哨兵哨兵，也是一道经典题。</p>
<p><strong>题外话</strong>: 如果将链表换做数组，那么删除所有重复元素非常简单，所以唯一有差异或者容易出错的地方还是在于链表这种数据结构，</p>
<h4 id="3-删除倒数第-n-个节点">3. 删除倒数第 N 个节点</h4>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p><img src="https://dbwu.tech/images/algorithm/remove-nth-node-from-end-of-list.jpeg" alt="图片来源: https://leetcode.cn"></p>
<p><strong>快速题解:</strong></p>
<p>删除倒数第 N 个节点，反过来看，倒数第 N 个节点也就是整数第 M - N 个节点，其中 M 表示链表的长度，所以解题可以分为两步:</p>
<ol>
<li>计算链表的长度 M</li>
<li>从前向后遍历链表，删除第 M - N 个节点</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 计算链表的长度 M
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">getLength</span>(head *ListNode) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	length := <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> head.Next != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		head = head.Next
</span></span><span style="display:flex;"><span>		length++
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> length
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 删除链表第 M - N 个节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">removeNthFromEnd</span>(head *ListNode, n <span style="color:#6ab825;font-weight:bold">int</span>) *ListNode {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> n &lt;= <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> head
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 熟悉的哨兵节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	dummy := &amp;ListNode{<span style="color:#3677a9">0</span>, head}
</span></span><span style="display:flex;"><span>	length := <span style="color:#447fcf">getLength</span>(head)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 熟悉的游标节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	cur := dummy
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#3677a9">0</span>; i &lt; length-n+<span style="color:#3677a9">1</span>; i++ {
</span></span><span style="display:flex;"><span>		cur = cur.Next
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	cur.Next = cur.Next.Next
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> dummy.Next
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>优化题解:</strong></p>
<p>在上面的题解中，我们一共遍历了两次链表，但是题目要求只遍历一次链表来解决问题，所以这道题肯定还存在更快速 “解题技巧”。</p>
<p>这里我们依然可以 <strong>引入快慢针对的思路</strong>：既然倒数第 N 个节点就是正数的 M - N 个节点，那么我们设定 <strong>一个快指针先走 N 步，然后设定一个慢和快指针以相同的步幅一起走</strong> (指针每次向前移动一次)，这样等到快指针移动到末尾时，慢指针正好移动到第 M - N 个节点，也就是倒数第 N 个节点，删除慢指针指向的节点即可。</p>
<p><strong>注意细节</strong>：因为头节点就是第一个节点，所以这里慢指针应该指向的是哨兵节点。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 非 VIP 用户提交
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 执行用时分布击败 100.00% 使用 Go 的用户
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 消耗内存分布击败 76.13% 使用 Go 的用户
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">removeNthFromEnd</span>(head *ListNode, n <span style="color:#6ab825;font-weight:bold">int</span>) *ListNode {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> n &lt;= <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> head
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 哨兵节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	dummy := &amp;ListNode{<span style="color:#3677a9">0</span>, head}
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 注意快慢指针的初始化指向
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	fast, slow := head, dummy
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 快指针先走 N 步
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#3677a9">0</span>; i &lt; n &amp;&amp; fast != <span style="color:#6ab825;font-weight:bold">nil</span>; i++ {
</span></span><span style="display:flex;"><span>		fast = fast.Next
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 然后快慢指针一起走
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> fast != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		slow = slow.Next
</span></span><span style="display:flex;"><span>		fast = fast.Next
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 当快指针扫描到链表结尾时
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 慢指针指向的正好是需要删除的节点的前置节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	slow.Next = slow.Next.Next
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> dummy.Next
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/remove-nth-node-from-end-of-list.png" alt="删除倒数第 N 个节点 - 执行过程"></p>
<p>不得不说，这个题真是快慢指针的经典应用了。</p>
<hr>
<h2 id="反转模式">反转模式</h2>
<blockquote>
<p>涉及到原地链表反转类问题，尽可能不要使用额外的数据结构和辅助空间，属于减分项。</p>
</blockquote>
<p>反转操作过程中需要注意的是：<strong>两两节点交换反转之后，不要丢掉指针和节点的连接关系，以及头节点和尾节点的边界处理</strong>。</p>
<h3 id="go-语言的骚操作">Go 语言的骚操作</h3>
<p>交换两个链表节点，Go 语言实现非常简单，其他语言需要一个可能临时 tmp 节点来作为中转。</p>
<p>实际算法笔试中，尽量不要写带有强烈的语言特性 (语法糖) 的代码，而应该写出 “语法更加通用” 的代码，也就是你给出的题解算法，不论用什么代码实现，看起来都是差不多的。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">reverseListForGolang</span>(head *ListNode) *ListNode {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">var</span> prev *ListNode
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> head != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		prev, head, head.Next = head, head.Next, prev
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> prev
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="-相关题目-2">💡 相关题目</h3>
<p>读者可以通过对比题解代码和上文中的模板代码，来体会通过模板快速解题的效率和细节。</p>
<h4 id="1-反转链表">1. 反转链表</h4>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<p><img src="https://dbwu.tech/images/algorithm/linked_list_reverse_demo.png" alt="图片来源: https://leetcode.cn"></p>
<p>定义三个指针变量分别指向:</p>
<ul>
<li>prev : 当前节点的前一个节点指针，初始化时为 <code>nil</code></li>
<li>cur  : 当前节点指针，游标指针，初始化时指向链表头节点</li>
<li>next : 当前节点的下一个节点指针，遍历时不断更新</li>
</ul>
<p>链表扫描结束之后，prev 指针变量指向反转后的链表头节点，直接返回即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">reverseList</span>(head *ListNode) *ListNode {
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">var</span> prev *ListNode
</span></span><span style="display:flex;"><span>    cur := head
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">for</span> cur != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        next := cur.Next
</span></span><span style="display:flex;"><span>        cur.Next = prev
</span></span><span style="display:flex;"><span>        prev = cur
</span></span><span style="display:flex;"><span>        cur = next
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span> prev
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/reverse_linked_list.png" alt="反转链表执行过程"></p>
<h4 id="2-两两交换链表中的节点">2. 两两交换链表中的节点</h4>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><img src="https://dbwu.tech/images/algorithm/swap-nodes-in-pairs.png" alt="图片来源: https://leetcode.cn"></p>
<p>如果从反转链表的角度来看的话，这个题可以变种为：反转链表的部分节点，因为前文中已经给到题解，这里就不再赘述了。</p>
<h2 id="小结">小结</h2>
<p>熟练掌握本文中提到的两套刷题模板：<strong>哨兵节点 + 快慢指针</strong>，从此百分之八十的链表类题目刷起来犹如切瓜砍菜般简单。</p>
<p><img src="https://dbwu.tech/images/algorithm/hwhqhl.png" alt="都看到这里了，不点个赞再走么？"></p>


</article>

<article>
    <img src="https://dbwu.tech/images/wechat.png">
</article>

<article>
    <h3>转载申请</h3>

    <p>
        本作品采用 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> 进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，商业转载请联系作者获得授权。
    </p>
</article>

<section class="post-nav">
    <ul>
        <li>
        
            <a href="https://dbwu.tech/posts/algorithm/leetcode_bit_pattern/"><i class="fa fa-chevron-circle-left"></i> LeetCode 位运算刷题模板</a>
        
        </li>
        <li>
        
            <a href="https://dbwu.tech/posts/algorithm/leetcode_hash_pattern/">LeetCode Hash 刷题模板 <i class="fa fa-chevron-circle-right"></i> </a>
        
        </li>
    </ul>
</section>
  
    
    
  


<script src="https://giscus.app/client.js"
        data-repo="duanbiaowu/dbwu.tech"
        data-repo-id="R_kgDOIkkjjw"
        data-category="Announcements"
        data-category-id="DIC_kwDOIkkjj84CV78j"
        data-mapping="specific"
        data-term="LeetCode Linked List 刷题模板"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous" async>
</script>




</main>
    <footer>
        <ul>
            <li>
                <h6><a href="mailto:codean.net@gmail.com">codean.net@gmail.com</a> | 
                    <img src="https://dbwu.tech/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" />
                    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61011302001681" target="_blank">陕公网安备 61011302001681 号</a> |
                    <a href="https://beian.miit.gov.cn" target="_blank">陕ICP备2023004378号-1</a> |
                    Rendered by <a href="https://themes.gohugo.io" title="Hugo" target="_blank">Hugo</a>
                </h6>
            </li>
            
            
        </ul>
    </footer>
</div>
<script src="https://dbwu.tech/js/scripts.js"></script>


</body>

</html>

