<!doctype html>

<html lang="en">

<head>
  <title>LeetCode DFS 刷题模板 - 蛮荆</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="" />
<meta name="author" content="" />
<link rel="shortcut icon" href="https://dbwu.tech/favicon.ico" type="image/x-icon" /><meta property="og:title" content="LeetCode DFS 刷题模板" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dbwu.tech/posts/algorithm/leetcode_dfs_pattern/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-05T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-05-05T00:00:00+00:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode DFS 刷题模板"/>
<meta name="twitter:description" content=""/>

<meta name="generator" content="Hugo 0.120.3">
    
    <script src="https://dbwu.tech/js/mathjax-config.js" defer></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CZMGTTFLNY"></script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3261056100776781" crossorigin="anonymous"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-CZMGTTFLNY');
  </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>


  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/normalize.min.css" />
  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/all.min.css" />
  
    
    <link href="//fonts.googleapis.com/css?family=Staatliches" rel="stylesheet">
  
  
  <link rel="stylesheet" type="text/css" href="https://dbwu.tech/css/styles-light.css" />
  </head>

<body>
  <div id="container">
    <header>
      
      <h1>
        <a href="https://dbwu.tech/">蛮荆</a>
      </h1>

      <ul id="social-media">
      </ul>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="active" href="https://dbwu.tech/posts/">
                <i class="fa-li fa  fa-lg"></i><span>归档</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/tags/">
                <i class="fa-li fa  fa-lg"></i><span>标签</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://github.com/duanbiaowu">
                <i class="fa-li fa  fa-lg"></i><span>Github</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/index.xml">
                <i class="fa-li fa  fa-lg"></i><span>RSS</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<article>

    <h1>LeetCode DFS 刷题模板</h1>

    
      
<p>
    <span>2022-05-05</span>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/%E7%AE%97%E6%B3%95">算法</a>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/leetcode">LeetCode</a>
    
</p>

    

    
      

    

    <h2 id="-概述">📖 概述</h2>
<p>DFS (深度优先搜索) 是一种用于遍历树或图数据结构的算法，其基本思想是从起始节点 (通常是根节点) 出发，沿着路径尽可能进行深度搜索，直到到达最深的节点，然后再回溯到之前的节点继续 (递归) 深度搜索其他路径，直到搜索完所有可能的路径，算法结束。</p>
<blockquote>
<p>DFS: 不撞南墙不回头</p>
<p>BFS: 步步为营</p>
</blockquote>
<h3 id="算法基本步骤">算法基本步骤</h3>
<ol>
<li>从起始节点 (根节点) 开始遍历，将其标记为已访问</li>
<li>单次遍历过程中，对于 “当前节点”，依次访问其所有相邻节点</li>
<li>对于每个相邻节点，如果未被访问过，递归调用 DFS</li>
<li>当所有相邻节点都被访问过或当前节点没有相邻节点时，回溯到上一级节点，继续搜索其他路径</li>
</ol>
<h3 id="执行过程示例">执行过程示例</h3>
<p>下面是一个典型的图数据结构:</p>
<p><img src="https://dbwu.tech/images/algorithm/300px-Graph.traversal.example.svg.png" alt="图片来源: https://en.wikipedia.org/wiki/Depth-first_search"></p>
<p>对该图执行 DFS 算法时，具体的执行过程中，每个节点被访问的顺序如图所示:</p>
<p><img src="https://dbwu.tech/images/algorithm/Depth-First-Search.gif" alt="图片来源: https://en.wikipedia.org/wiki/Depth-first_search"></p>
<h3 id="伪代码">伪代码</h3>
<p>下面的是对应的 Golang 伪代码:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 使用邻接表 表示图的数据结构
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">type</span> Graph <span style="color:#6ab825;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	vertices <span style="color:#6ab825;font-weight:bold">map</span>[<span style="color:#6ab825;font-weight:bold">int</span>][]<span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 深度优先搜索
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">DFS</span>(graph Graph, start <span style="color:#6ab825;font-weight:bold">int</span>, visited <span style="color:#6ab825;font-weight:bold">map</span>[<span style="color:#6ab825;font-weight:bold">int</span>]<span style="color:#6ab825;font-weight:bold">bool</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 标记当前节点为已访问
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	visited[start] = <span style="color:#6ab825;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 遍历当前节点的所有相邻节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> _, v := <span style="color:#6ab825;font-weight:bold">range</span> graph.vertices[start] {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 如果相邻节点未被访问过，递归调用 DFS
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> !visited[v] {
</span></span><span style="display:flex;"><span>			<span style="color:#447fcf">DFS</span>(graph, v, visited)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 从节点 0 开始进行深度优先搜索
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#447fcf">DFS</span>(graph, <span style="color:#3677a9">0</span>, visited)
</span></span></code></pre></div><hr>
<h2 id="-典型题目-图">💡 典型题目 (图)</h2>
<p>LeetCode 中的 DFS (图数据结构) 相关题目都是在 DFS 基础上加上题目的具体逻辑即可，解题步骤 (模板) 可以分为四步:</p>
<ol>
<li><strong>确定 DFS 结束条件和边界处理 (核心)</strong></li>
<li>确定 DFS 起始节点</li>
<li>确定单次访问节点</li>
<li>DFS 过程中的状态变量如何更新 (一般使用参数传递)</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// DFS 刷题模板代码 (针对图数据结构)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">Solution</span>(...) ... {
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 初始化状态
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 定义 DFS 函数
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">var</span> dfs <span style="color:#6ab825;font-weight:bold">func</span>(...)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 实现 DFS 函数
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    dfs = <span style="color:#6ab825;font-weight:bold">func</span>(...) {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 递归结束条件 (边界处理)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        <span style="color:#6ab825;font-weight:bold">if</span> ... {
</span></span><span style="display:flex;"><span>            <span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 状态更新
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 遍历当前节点的相邻节点或下一步可能的选择
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        <span style="color:#6ab825;font-weight:bold">for</span> ... {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 如果符合题目逻辑条件，继续递归
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>            <span style="color:#999;font-style:italic">// 如果下一步有效，进行递归调用
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>            <span style="color:#6ab825;font-weight:bold">if</span> ... {
</span></span><span style="display:flex;"><span>                <span style="color:#447fcf">dfs</span>(...)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 返回调用 DFS 函数的结果
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">return</span> ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="1-岛屿数量">1. 岛屿数量</h3>
<p>给你一个由 &lsquo;1&rsquo;（陆地）和 &lsquo;0&rsquo;（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#999;font-style:italic"># 示例来自: https://leetcode.cn/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 1：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：grid = [
</span></span><span style="display:flex;"><span>  [<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>],
</span></span><span style="display:flex;"><span>  [<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>],
</span></span><span style="display:flex;"><span>  [<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>],
</span></span><span style="display:flex;"><span>  [<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>]
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>输出：1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 2：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：grid = [
</span></span><span style="display:flex;"><span>  [<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>],
</span></span><span style="display:flex;"><span>  [<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>],
</span></span><span style="display:flex;"><span>  [<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>],
</span></span><span style="display:flex;"><span>  [<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>]
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>输出：3
</span></span></code></pre></div><p>快速套模板:</p>
<ol>
<li>递归结束条件: 当前坐标超出边界 (二维数组索引越界)，或者当前节点不是 &lsquo;1&rsquo; (陆地)</li>
<li>确定 DFS 起始节点: 参数使用二维数组表示图的邻接表，那么就从数组第一个元素开始 <code>grid [0][0]</code></li>
<li>确定单次访问节点: 当前节点 上下左右 4 个方向所有为 &lsquo;1&rsquo; (陆地) 的节点 (这样就可以连成一片，形成一个小岛)，然后递归，单个节点访问之后，将值标记为 &lsquo;0&rsquo;, 避免重复访问</li>
<li>状态变量如何更新: 以当前节点开始，完成一轮 DFS 过程，岛屿数量 + 1</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">numIslands</span>(grid [][]<span style="color:#6ab825;font-weight:bold">byte</span>) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	res := <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> row := <span style="color:#6ab825;font-weight:bold">range</span> grid {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">for</span> col := <span style="color:#6ab825;font-weight:bold">range</span> grid[row] {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> grid[row][col] == <span style="color:#ed9d13">&#39;1&#39;</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#999;font-style:italic">// 如果找到一块陆地，以该坐标为中心，上下左右四个方向继续探索
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>				res++
</span></span><span style="display:flex;"><span>				<span style="color:#447fcf">dfs</span>(grid, row, col)
</span></span><span style="display:flex;"><span>				<span style="color:#999;font-style:italic">// 递归完成之后，以当前坐标为中心的陆地全部被标记为 &#39;0&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> res
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">dfs</span>(grid [][]<span style="color:#6ab825;font-weight:bold">byte</span>, row, col <span style="color:#6ab825;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 递归结束条件 (边界处理)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 如果坐标已越界或者当前坐标不是陆地
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> row &lt; <span style="color:#3677a9">0</span> || row &gt;= <span style="color:#24909d">len</span>(grid) || col &lt; <span style="color:#3677a9">0</span> || col &gt;= <span style="color:#24909d">len</span>(grid[<span style="color:#3677a9">0</span>]) || grid[row][col] == <span style="color:#ed9d13">&#39;0&#39;</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 已经探索过的坐标标记为 0, 避免重复计算
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	grid[row][col] = <span style="color:#ed9d13">&#39;0&#39;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#447fcf">dfs</span>(grid, row-<span style="color:#3677a9">1</span>, col) <span style="color:#999;font-style:italic">// ⬆  方向递归
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">dfs</span>(grid, row+<span style="color:#3677a9">1</span>, col) <span style="color:#999;font-style:italic">// ⬇  方向递归
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">dfs</span>(grid, row, col-<span style="color:#3677a9">1</span>) <span style="color:#999;font-style:italic">// &lt;- 方向递归
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">dfs</span>(grid, row, col+<span style="color:#3677a9">1</span>) <span style="color:#999;font-style:italic">// -&gt; 方向递归
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/numIslands.png" alt="DFS 执行过程"></p>
<h3 id="2-被围绕的区域">2. 被围绕的区域</h3>
<p>给你一个 m x n 的矩阵 board ，由若干字符 &lsquo;X&rsquo; 和 &lsquo;O&rsquo; ，找到所有被 &lsquo;X&rsquo; 围绕的区域，并将这些区域里所有的 &lsquo;O&rsquo; 用 &lsquo;X&rsquo; 填充。</p>
<p><img src="https://dbwu.tech/images/algorithm/xogrid.jpg" alt="图片来源: https://leetcode.cn/"></p>
<p>解题思路:</p>
<p>题目解释中提到：任何边界上的 O 都不会被填充为 X, 所有的不被包围的 O 都直接或间接与边界上的 O 相连。那么<strong>只需要将所有可以连通的进行标记，剩下的就是无法连通的</strong>。</p>
<p>题目要求四个边界上面的格子 &lsquo;O&rsquo; 不需要被更新，那么如何在 DFS 的递归执行过程中规避掉这个问题呢？我们可以使用一个额外的字符 <code>#</code> 作为临时字符来替换掉边界上的 &lsquo;O&rsquo;, 专门用于标记已经更新过的格子，最后再将临时字符 <code>#</code> 的格子替换为 &lsquo;O&rsquo;。</p>
<p>快速套模板:</p>
<ol>
<li>递归结束条件: 当前坐标超出边界 (二维数组索引越界)，或者当前节点不是 &lsquo;O&rsquo;</li>
<li>确定 DFS 起始节点: 参数使用二维数组表示图的邻接表，那么就从数组第一个元素开始 <code>board [0][0]</code></li>
<li>确定单次访问节点: 将上下左右 四个边界的格子 及其 相连的格子 标记为 “已连通“，使用字符 <code>#</code></li>
<li>状态变量如何更新: 本题只涉及到数据修改，没有返回值，所以不需要状态变量</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">solve</span>(board [][]<span style="color:#6ab825;font-weight:bold">byte</span>)  {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 边界条件判断
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    rows := <span style="color:#24909d">len</span>(board)
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">if</span> rows == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">return</span> 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cols := <span style="color:#24909d">len</span>(board[<span style="color:#3677a9">0</span>])
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">if</span> cols == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">return</span> 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 边界上的格子 &#39;O&#39; 预处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// 将左右边界进行标记为 &#34;已连通&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">for</span> row := <span style="color:#3677a9">0</span>; row &lt; rows; row++ {
</span></span><span style="display:flex;"><span>        <span style="color:#447fcf">dfs</span>(board, row, <span style="color:#3677a9">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#447fcf">dfs</span>(board, row, cols-<span style="color:#3677a9">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 将上下边界进行标记为 &#34;已连通&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">for</span> col := <span style="color:#3677a9">1</span>; col &lt; cols - <span style="color:#3677a9">1</span>; col++ {
</span></span><span style="display:flex;"><span>        <span style="color:#447fcf">dfs</span>(board, <span style="color:#3677a9">0</span>, col)
</span></span><span style="display:flex;"><span>        <span style="color:#447fcf">dfs</span>(board, rows-<span style="color:#3677a9">1</span>, col)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 现在从矩阵的最外侧作为出发点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// 上下左右四个方向已经连通
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// 只需要遍历一次矩阵
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// 将 # 修改为 0, 因为这些属于边界上的 0
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// 将 0 改为为 X, 因为这些不属于边界上的 0
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">for</span> row := <span style="color:#3677a9">0</span>; row &lt; rows; row++ {
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">for</span> col := <span style="color:#3677a9">0</span>; col &lt; cols; col++ {
</span></span><span style="display:flex;"><span>            <span style="color:#6ab825;font-weight:bold">if</span> board[row][col] == <span style="color:#ed9d13">&#39;#&#39;</span> {
</span></span><span style="display:flex;"><span>                board[row][col] = <span style="color:#ed9d13">&#39;O&#39;</span>
</span></span><span style="display:flex;"><span>            } <span style="color:#6ab825;font-weight:bold">else</span> <span style="color:#6ab825;font-weight:bold">if</span> board[row][col] == <span style="color:#ed9d13">&#39;O&#39;</span> {
</span></span><span style="display:flex;"><span>                board[row][col] = <span style="color:#ed9d13">&#39;X&#39;</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">dfs</span>(board [][]<span style="color:#6ab825;font-weight:bold">byte</span>, row, col <span style="color:#6ab825;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 递归结束条件 (边界处理)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">if</span> row &lt; <span style="color:#3677a9">0</span> || row &gt;= <span style="color:#24909d">len</span>(board) || col &lt; <span style="color:#3677a9">0</span> || col &gt;= <span style="color:#24909d">len</span>(board[<span style="color:#3677a9">0</span>]) || board[row][col] != <span style="color:#ed9d13">&#39;O&#39;</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span>  
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    board[row][col] = <span style="color:#ed9d13">&#39;#&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#447fcf">dfs</span>(board, row-<span style="color:#3677a9">1</span>, col) <span style="color:#999;font-style:italic">// ⬆  方向递归
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">dfs</span>(board, row+<span style="color:#3677a9">1</span>, col) <span style="color:#999;font-style:italic">// ⬇  方向递归
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">dfs</span>(board, row, col-<span style="color:#3677a9">1</span>) <span style="color:#999;font-style:italic">// &lt;- 方向递归
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">dfs</span>(board, row, col+<span style="color:#3677a9">1</span>) <span style="color:#999;font-style:italic">// -&gt; 方向递归
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/130solve.png" alt="状态更新 - 执行过程"></p>
<h3 id="3-克隆图">3. 克隆图</h3>
<p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</p>
<p>节点的深度拷贝需要满足两个条件:</p>
<ol>
<li>新节点必须和源节点的值一样，并且拥有新的内存地址空间和数据结构</li>
<li>各个新节点之间的关系必须和源节点之间的关系一致</li>
</ol>
<p><img src="https://dbwu.tech/images/algorithm/133_clone_graph_question.png" alt="图片来源: https://leetcode.cn/"></p>
<p>快速套模板:</p>
<ol>
<li>递归结束条件: 当前节点为 nil, 或者当前节点已经被克隆，直接返回已经克隆的新节点</li>
<li>确定 DFS 起始节点: 题目给出的参数节点</li>
<li>确定单次访问节点: 当前节点的所有邻居节点</li>
<li>状态变量如何更新: 使用一个 Hash 存储源和克隆的新节点之间的关系，访问当前源节点时，将克隆后的新节点和源节点完成映射</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">cloneGraph</span>(node *Node) *Node {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 以参数节点开始进行 DFS 遍历
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 使用参数传递源节点和新节点的 Hash Map
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#447fcf">dfs</span>(node, <span style="color:#24909d">make</span>(<span style="color:#6ab825;font-weight:bold">map</span>[*Node]*Node))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">dfs</span>(node *Node, visited <span style="color:#6ab825;font-weight:bold">map</span>[*Node]*Node) *Node {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 递归结束条件 (边界处理)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">if</span> node == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">return</span> node
</span></span><span style="display:flex;"><span>    }   
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 如果当前节点已经被克隆过，直接返回克隆后的新节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">if</span> _, ok := visited[node]; ok {
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">return</span> visited[node]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 克隆当前节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    cloneNode := &amp;Node{node.Val, []*Node{}}
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 将当前节点标记为已经克隆
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    visited[node] = cloneNode
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 遍历当前的节点的邻节点，递归克隆
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">for</span> _, v := <span style="color:#6ab825;font-weight:bold">range</span> node.Neighbors {
</span></span><span style="display:flex;"><span>        cloneNode.Neighbors = <span style="color:#24909d">append</span>(cloneNode.Neighbors, <span style="color:#447fcf">dfs</span>(v, visited))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span> cloneNode
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/cloneGraph.png" alt="克隆图 - 执行过程"></p>
<hr>
<h2 id="-dfs-和二叉树">💡 DFS 和二叉树</h2>
<p>使用 DFS 解决二叉树 (数据结构) 相关问题时，因为左右子树需要分别进行递归操作，这是就无法计算一些 <strong>“中间状态数据值”</strong>，例如每层的节点数量、每层的节点值平均值，针对这类问题，可以将中间状态数据值保存到全局状态存储中，在 DFS 过程结束之后再计算。</p>
<p>由于 <strong>“中间状态数据值”</strong> 需要在递归的过程中不断被更新，所以调用时 <strong>需要传入指针变量</strong>，“中间状态数据值” 使用语义非常清晰，降低了代码阅读难度。</p>
<h3 id="刷题模板">刷题模板</h3>
<p>LeetCode 中的二叉树 DFS 相关题目都是在 DFS 算法基础上加上具体逻辑即可，和图 (数据结构) 不同的地方在于: 二叉树的每个节点会有左右两个子节点, 解题步骤 (模板) 可以分为四步:</p>
<ol>
<li><strong>确定 DFS 结束条件和边界处理 (核心)</strong>, 一般是 <code>if root == nil { return }</code></li>
<li>确定 DFS 起始节点，一般是二叉树 <code>root</code> 根节点</li>
<li>确定单次访问节点，也就是当前节点的左右节点  <code>root.Left</code>, <code>root.Right</code></li>
<li>DFS 过程中的状态变量如何更新 (一般使用参数传递，例如当前所在树的层级、题目要求的逻辑数据等)</li>
</ol>
<p>下面是一个使用 DFS 遍历的代码模板:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// DFS 刷题模板代码 (针对树数据结构)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">levelOrderDFS</span>(root *TreeNode) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 指针传递，充当 “全局变量”
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// 用于处理和存储 “中间状态数据值”
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">var</span> res []<span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 层级从 0 开始
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">dfs</span>(root, <span style="color:#3677a9">0</span>, &amp;res)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> res
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 注意 res 的形参类型
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">dfs</span>(root *TreeNode, depth <span style="color:#6ab825;font-weight:bold">int</span>, res *[]<span style="color:#6ab825;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// DFS 递归条件处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 根据具体的逻辑执行某些初始化操作
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> depth == <span style="color:#24909d">len</span>(*res) {
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 根据具体的逻辑，更新全局变量数据
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 递归左子树 层级 + 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">dfs</span>(root.Left, depth+<span style="color:#3677a9">1</span>, res)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 递归右子树 层级 + 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">dfs</span>(root.Right, depth+<span style="color:#3677a9">1</span>, res)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="通用递归边界条件检测">通用递归边界条件检测</h3>
<p>对于树数据结构来说，正确处理 DFS 递归条件除了避免代码执行陷入死循环之外，还可以 <strong>及时剪枝，提升代码执行效率、代码可读性</strong>。</p>
<p>下面列举了几个常见的边界条件检测:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 最常见的树递归边界处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 比较树的两个子节点是否相同
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">if</span> p == <span style="color:#6ab825;font-weight:bold">nil</span> &amp;&amp; q == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">if</span> p == <span style="color:#6ab825;font-weight:bold">nil</span> || q == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">if</span> p.Val != q.Val {
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="-典型题目-二叉树">💡 典型题目 (二叉树)</h2>
<h3 id="1-二叉树的最大深度">1. 二叉树的最大深度</h3>
<p>给定一个二叉树 root ，返回其最大深度。
二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<p><img src="https://dbwu.tech/images/algorithm/tmp-tree.png" alt="图片来源: https://leetcode.cn/"></p>
<p>如图所示的 树 的深度为 3。</p>
<p>快速套模板:</p>
<ol>
<li><strong>确定 DFS 结束条件和边界处理 (核心)</strong>, <code>if root == nil { return }</code></li>
<li>确定 DFS 起始节点，也就是参数 <code>root</code> 根节点</li>
<li>确定单次访问节点，当前节点的左右节点  <code>root.Left</code>, <code>root.Right</code></li>
<li>DFS 过程中的状态变量如何更新: (递归时使用指针类型参数传递返回值，额外传递一个参数用于表示当前树的 “层级”，也就是深度)</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">maxDepth</span>(root *TreeNode) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 状态变量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">var</span> res <span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 从 root 节点作为 DFS 起始节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 使用指针传递状态变量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">dfs</span>(root, <span style="color:#3677a9">0</span>, &amp;res)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 返回状态变量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">return</span> res
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">dfs</span>(root *TreeNode, depth <span style="color:#6ab825;font-weight:bold">int</span>, res *<span style="color:#6ab825;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// DFS 递归条件处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 因为存在树的两边高度不相等的情况
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 所以最大深度以 [当前深度] 和 [已知的最大深度] 中的较大值为准
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	*res = <span style="color:#24909d">max</span>(*res, depth+<span style="color:#3677a9">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 递归左子树时，深度 + 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">dfs</span>(root.Left, depth+<span style="color:#3677a9">1</span>, res)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 递归右子树时，深度 + 1
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">dfs</span>(root.Right, depth+<span style="color:#3677a9">1</span>, res)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#24909d">max</span>(a, b <span style="color:#6ab825;font-weight:bold">int</span>) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> a &gt; b {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> a
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> b
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/maxDepth.png" alt="二叉树的最大深度 - 执行过程"></p>
<h3 id="2-二叉树的层平均值">2. 二叉树的层平均值</h3>
<p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。</p>
<p><img src="https://dbwu.tech/images/algorithm/avg1-tree.jpg" alt="图片来源: https://leetcode.cn/"></p>
<p>给出上图所示的二叉树，会输出如下答案:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>输出：[3.00000,14.50000,11.00000]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>解释：第 <span style="color:#3677a9">0</span> 层的平均值为 3,第 <span style="color:#3677a9">1</span> 层的平均值为 14.5,第 <span style="color:#3677a9">2</span> 层的平均值为 <span style="color:#3677a9">11</span> 。
</span></span><span style="display:flex;"><span>因此返回 [3, 14.5, 11] 。
</span></span></code></pre></div><p>快速套模板:</p>
<ol>
<li><strong>确定 DFS 结束条件和边界处理 (核心)</strong>, <code>if root == nil { return }</code></li>
<li>确定 DFS 起始节点，也就是参数 <code>root</code> 根节点</li>
<li>确定单次访问节点，当前节点的左右节点  <code>root.Left</code>, <code>root.Right</code></li>
<li>DFS 过程中的状态变量如何更新: 使用指针数组参数传递 “每层节点累加值” 和 “每层节点数量”，单个递归过程中，将每层的 &ldquo;累加值“ 和 &ldquo;节点数量&rdquo; 保存起来，然后递归调用左右子树即可，最后 DFS 结束之后根据 “每层节点累加值” 和 “每层节点数量” 计算平均值</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">averageOfLevels</span>(root *TreeNode) []<span style="color:#6ab825;font-weight:bold">float64</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// sum 存储每层节点累加值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// cnt 存储每层节点数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">var</span> sum, cnt []<span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 从 root 节点作为 DFS 起始节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 使用指针传递状态变量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">dfs</span>(root, <span style="color:#3677a9">0</span>, &amp;sum, &amp;cnt)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 计算每层的平均值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">var</span> res []<span style="color:#6ab825;font-weight:bold">float64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#6ab825;font-weight:bold">range</span> sum {
</span></span><span style="display:flex;"><span>		res = <span style="color:#24909d">append</span>(res, <span style="color:#24909d">float64</span>(sum[i])/<span style="color:#24909d">float64</span>(cnt[i]))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> res
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">dfs</span>(root *TreeNode, depth <span style="color:#6ab825;font-weight:bold">int</span>, sum, cnt *[]<span style="color:#6ab825;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// DFS 递归条件处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 遇到每个层级的第一个节点时，初始化累加器和计数器
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> depth == <span style="color:#24909d">len</span>(*sum) {
</span></span><span style="display:flex;"><span>		*sum = <span style="color:#24909d">append</span>(*sum, root.Val)
</span></span><span style="display:flex;"><span>		*cnt = <span style="color:#24909d">append</span>(*cnt, <span style="color:#3677a9">1</span>)
</span></span><span style="display:flex;"><span>	} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 遇到了每个层级的第 2 - N 个节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 其中 N 等于该层上面的节点数量
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 对于树的每一层，这个分支会执行 N - 1 次
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		(*sum)[depth] += root.<span style="color:#447fcf">Val</span>
</span></span><span style="display:flex;"><span>		(*cnt)[depth]++
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 递归左子树时，深度 + 1, 同时传递两个指针数组
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">dfs</span>(root.Left, depth+<span style="color:#3677a9">1</span>, sum, cnt)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 递归右子树时，深度 + 1, 同时传递两个指针数组
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">dfs</span>(root.Right, depth+<span style="color:#3677a9">1</span>, sum, cnt)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/averageOfLevels.png" alt="二叉树的层平均值 - 执行过程"></p>
<h3 id="3-二叉树根节点到叶节点数字之和">3. 二叉树根节点到叶节点数字之和</h3>
<p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：
例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。
叶节点 是指没有子节点的节点。</p>
<p><img src="https://dbwu.tech/images/algorithm/num1tree.jpg" alt="图片来源: https://leetcode.cn/"></p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#999;font-style:italic"># 如图所示</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：root = [1,2,3]
</span></span><span style="display:flex;"><span>输出：25
</span></span><span style="display:flex;"><span>解释：
</span></span><span style="display:flex;"><span>从根到叶子节点路径 1-&gt;2 代表数字 <span style="color:#3677a9">12</span>
</span></span><span style="display:flex;"><span>从根到叶子节点路径 1-&gt;3 代表数字 <span style="color:#3677a9">13</span>
</span></span><span style="display:flex;"><span>因此，数字总和 = <span style="color:#3677a9">12</span> + <span style="color:#40ffff">13</span> = <span style="color:#3677a9">25</span>
</span></span></code></pre></div><blockquote>
<p>二叉树的遍历过程中，除了使用指针变量作为 “中间状态数据值” 之外，也可以使用返回值的方式实现，不论哪种方式，最重要的是处理好 “中间状态数据值” 在递归过程中的更新。</p>
</blockquote>
<p>快速套模板:</p>
<ol>
<li><strong>确定 DFS 结束条件和边界处理 (核心)</strong>, 这道题存在两个边界条件:
<ol>
<li>如果当前节点为 nil, 直接返回 0, <code>if root == nil { return 0 }</code></li>
<li>如果当前节点的左右子节点都为 nil, 说明当前节点就是叶子节点，直接返回 “当前累加值”</li>
</ol>
</li>
<li>确定 DFS 起始节点，也就是参数 <code>root</code> 根节点</li>
<li>确定单次访问节点，当前节点的左右节点  <code>root.Left</code>, <code>root.Right</code></li>
<li>DFS 过程中的状态变量如何更新: 使用参数传递 “当前累加值”，单个递归过程中，使用当前节点值计算并更新 “当前累加值”，然后递归调用左右子树即可</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">sumNumbers</span>(root *TreeNode) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 从 root 节点作为 DFS 起始节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// “当前累加值” 初始化为 0
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#447fcf">dfs</span>(root, <span style="color:#3677a9">0</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">dfs</span>(root *TreeNode, sum <span style="color:#6ab825;font-weight:bold">int</span>) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// DFS 递归条件处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 计算并更新 “当前累加值”
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    sum = sum*<span style="color:#3677a9">10</span> + root.Val
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 如果当前节点的左右子节点都为 nil, 说明当前节点就是叶子节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// 直接返回 “当前累加值” 
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">if</span> root.Left == <span style="color:#6ab825;font-weight:bold">nil</span> &amp;&amp; root.Right == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">return</span> sum
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#999;font-style:italic">// 递归调用左右子树 (并传入 “当前累加值” )
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#447fcf">dfs</span>(root.Left, sum) + <span style="color:#447fcf">dfs</span>(root.Right, sum)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/sumNumbers2.png" alt="二叉树根节点到叶节点数字之和 - 执行过程"></p>
<h3 id="4-二叉树中的最大路径和">4. 二叉树中的最大路径和</h3>
<p>二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<p><img src="https://dbwu.tech/images/algorithm/binary-tree-maximum-path-sum.jpeg" alt="图片来源: https://leetcode.cn/"></p>
<p>如图所示的二叉树中的最大路径和为 6，最大路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</p>
<p>快速套模板:</p>
<ol>
<li><strong>确定 DFS 结束条件和边界处理 (核心)</strong>, <code>if root == nil { return }</code></li>
<li>确定 DFS 起始节点，也就是参数 <code>root</code> 根节点</li>
<li>确定单次访问节点，当前节点的左右节点  <code>root.Left</code>, <code>root.Right</code></li>
<li>DFS 过程中的状态变量如何更新: 使用参数传递 “当前最大路径和”，单个递归过程中，首先分别递归调用左右子树获取左右子树的最大值，然后再和当前节点值计算并更新 “当前最大路径和”</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">maxPathSum</span>(root *TreeNode) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// “当前最大路径和” 初始化为一个最小的负数
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 简化边界处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	maxSum := math.MinInt32
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 从 root 节点作为 DFS 起始节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#447fcf">dfs</span>(root, &amp;maxSum)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> maxSum
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">dfs</span>(root *TreeNode, maxSum *<span style="color:#6ab825;font-weight:bold">int</span>) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// DFS 递归条件处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 子节点路径和为负数时的边界处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 计算左子树的最大路径和
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	left := <span style="color:#24909d">max</span>(<span style="color:#3677a9">0</span>, <span style="color:#447fcf">dfs</span>(root.Left, maxSum))
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 计算右子树的最大路径和
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	right := <span style="color:#24909d">max</span>(<span style="color:#3677a9">0</span>, <span style="color:#447fcf">dfs</span>(root.Right, maxSum))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 更新当前最大路径和
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	*maxSum = <span style="color:#24909d">max</span>(*maxSum, root.Val+left+right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 最大路径只能是根节点 + 左右节点中的任意一个
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 所以必须从左右节点中选择一个节点出来
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">return</span> root.Val + <span style="color:#24909d">max</span>(left, right)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/maxPathSum.png" alt="二叉树根节点到叶节点数字之和 - 执行过程"></p>


</article>

<article>
    <img src="https://dbwu.tech/images/wechat.png">
</article>

<article>
    <h3>转载申请</h3>

    <p>
        本作品采用 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> 进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，商业转载请联系作者获得授权。
    </p>
</article>

<section class="post-nav">
    <ul>
        <li>
        
            <a href="https://dbwu.tech/posts/algorithm/leetcode_binary_search_pattern/"><i class="fa fa-chevron-circle-left"></i> LeetCode Binary Search 刷题模板</a>
        
        </li>
        <li>
        
            <a href="https://dbwu.tech/posts/algorithm/leetcode_bfs_pattern/">LeetCode BFS 刷题模板 <i class="fa fa-chevron-circle-right"></i> </a>
        
        </li>
    </ul>
</section>
  
    
    
  


<script src="https://giscus.app/client.js"
        data-repo="duanbiaowu/dbwu.tech"
        data-repo-id="R_kgDOIkkjjw"
        data-category="Announcements"
        data-category-id="DIC_kwDOIkkjj84CV78j"
        data-mapping="specific"
        data-term="LeetCode DFS 刷题模板"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous" async>
</script>




</main>
    <footer>
        <ul>
            <li>
                <h6><a href="mailto:codean.net@gmail.com">codean.net@gmail.com</a> | 
                    <img src="https://dbwu.tech/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" />
                    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61011302001681" target="_blank">陕公网安备 61011302001681 号</a> |
                    <a href="https://beian.miit.gov.cn" target="_blank">陕ICP备2023004378号-1</a> |
                    Rendered by <a href="https://themes.gohugo.io" title="Hugo" target="_blank">Hugo</a>
                </h6>
            </li>
            
            
        </ul>
    </footer>
</div>
<script src="https://dbwu.tech/js/scripts.js"></script>


</body>

</html>

