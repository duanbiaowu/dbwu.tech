<!doctype html>

<html lang="en">

<head>
  <title>LeetCode BFS 刷题模板 - 蛮荆</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="" />
<meta name="author" content="" />
<link rel="shortcut icon" href="https://dbwu.tech/favicon.ico" type="image/x-icon" /><meta property="og:title" content="LeetCode BFS 刷题模板" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dbwu.tech/posts/algorithm/leetcode_bfs_pattern/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-05-11T00:00:00+00:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode BFS 刷题模板"/>
<meta name="twitter:description" content=""/>

<meta name="generator" content="Hugo 0.120.3">
    
    <script src="https://dbwu.tech/js/mathjax-config.js" defer></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CZMGTTFLNY"></script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3261056100776781" crossorigin="anonymous"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-CZMGTTFLNY');
  </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>


  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/normalize.min.css" />
  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/all.min.css" />
  
    
    <link href="//fonts.googleapis.com/css?family=Staatliches" rel="stylesheet">
  
  
  <link rel="stylesheet" type="text/css" href="https://dbwu.tech/css/styles-light.css" />
  </head>

<body>
  <div id="container">
    <header>
      
      <h1>
        <a href="https://dbwu.tech/">蛮荆</a>
      </h1>

      <ul id="social-media">
      </ul>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="active" href="https://dbwu.tech/posts/">
                <i class="fa-li fa  fa-lg"></i><span>归档</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/tags/">
                <i class="fa-li fa  fa-lg"></i><span>标签</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://github.com/duanbiaowu">
                <i class="fa-li fa  fa-lg"></i><span>Github</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/index.xml">
                <i class="fa-li fa  fa-lg"></i><span>RSS</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<article>

    <h1>LeetCode BFS 刷题模板</h1>

    
      
<p>
    <span>2022-05-11</span>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/%E7%AE%97%E6%B3%95">算法</a>
    
</p>

    

    
      

    

    <h2 id="-概述">📖 概述</h2>
<p>BFS (广度优先搜索) 是一种在树或图数据结构中搜索满足给定条件的节点的算法，其基本思想是从起始节点 (通常是根节点) 出发，探索当前深度的所有节点，然后再移动到下一个深度级别的节点，搜索过程中，需要额外的内存（通常是队列）来存储已经遍历到但尚未继续搜索的子节点，队列长度就是未搜索子节点的个数，直到搜索完所有节点或者找到满足条件的节点 (或路径)，算法结束。</p>
<blockquote>
<p>DFS: 不撞南墙不回头</p>
<p>BFS: 步步为营</p>
</blockquote>
<h3 id="算法基本步骤">算法基本步骤</h3>
<ol>
<li>初始化队列</li>
<li>将起始节点 (通常是根节点) 加入到队列中</li>
<li>循环遍历队列 (队列不为空的前提下)，执行下列操作:
<ol>
<li>从队列中取出第一个节点</li>
<li>对该节点进行逻辑处理 (例如标记已访问、计算数据、更新当前层级等)</li>
<li>将该节点相邻的所有 (或者未访问) 节点全部加入到队列中</li>
</ol>
</li>
<li>重复第 3 步，直到队列为空或者所有节点均被访问</li>
</ol>
<h3 id="执行过程示例">执行过程示例</h3>
<p>下面是一个典型的图 (同时也是一棵树) 数据结构:</p>
<p><img src="https://dbwu.tech/images/algorithm/graph_demo.png" alt="图片来源: https://en.wikipedia.org/wiki/Breadth-first_search"></p>
<p>对该图执行 BFS 算法时，具体的执行过程中，每个节点被访问的顺序如图所示:</p>
<p><img src="https://dbwu.tech/images/algorithm/Animated_BFS.gif" alt="图片来源: https://en.wikipedia.org/wiki/Breadth-first_search"></p>
<h3 id="伪代码">伪代码</h3>
<p>BFS 算法通常用于解决以下问题：</p>
<ul>
<li>求解最短路径问题 (<strong>路径上没有权重，也就是未加权图</strong>)，如迷宫最短路径、网络节点间的最短通路</li>
<li>在树或图数据结构中进行层级遍历或层级搜索</li>
<li>判断图中是否存在环路或特定路径</li>
</ul>
<p>下面的 <code>求解最短路径问题</code> 对应的 Golang 伪代码:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 使用邻接表 表示图的数据结构
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">type</span> Graph <span style="color:#6ab825;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	Nodes <span style="color:#6ab825;font-weight:bold">map</span>[<span style="color:#6ab825;font-weight:bold">int</span>][]<span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 广度优先搜索
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 找到从起始节点到目标节点的最短路径
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> (g *Graph) <span style="color:#447fcf">BFS</span>(start, target <span style="color:#6ab825;font-weight:bold">int</span>) []<span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 初始化队列，用于存储路径          
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 将起始节点加入到队列中 
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	queue := [][]<span style="color:#6ab825;font-weight:bold">int</span>{{start}}           
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 记录节点是否已访问过
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	visited := <span style="color:#24909d">make</span>(<span style="color:#6ab825;font-weight:bold">map</span>[<span style="color:#6ab825;font-weight:bold">int</span>]<span style="color:#6ab825;font-weight:bold">bool</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 循环遍历队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> <span style="color:#24909d">len</span>(queue) &gt; <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 从队列中取出第一个路径
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		path := queue[<span style="color:#3677a9">0</span>]       
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 将取出的路径从队列中移除
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		queue = queue[<span style="color:#3677a9">1</span>:]  
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 取出当前路径的最后一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		node := path[<span style="color:#24909d">len</span>(path)-<span style="color:#3677a9">1</span>]           
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 将当前节点标记为已访问
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		visited[node] = <span style="color:#6ab825;font-weight:bold">true</span>                 
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 如果当前节点是目标节点，直接返回当前路径即可
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> node == target {                 
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">return</span> path
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 遍历当前节点的所有邻居节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">for</span> _, neighbor := <span style="color:#6ab825;font-weight:bold">range</span> g.Nodes[node] { 
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> !visited[neighbor] {               
</span></span><span style="display:flex;"><span>				<span style="color:#999;font-style:italic">// 如果邻居节点未访问过，则将其加入路径形成新的路径
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>				newPath := <span style="color:#24909d">make</span>([]<span style="color:#6ab825;font-weight:bold">int</span>, <span style="color:#24909d">len</span>(path))
</span></span><span style="display:flex;"><span>				<span style="color:#24909d">copy</span>(newPath, path)
</span></span><span style="display:flex;"><span>				newPath = <span style="color:#24909d">append</span>(newPath, neighbor)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#999;font-style:italic">// 将新的路径加入队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>				queue = <span style="color:#24909d">append</span>(queue, newPath)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 未找到路径返回空
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">nil</span> 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 计算起始节点 0 到目标节点 10 的最短路径
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>graph.<span style="color:#447fcf">BFS</span>(<span style="color:#3677a9">0</span>, <span style="color:#3677a9">10</span>)
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/shortest_path.png" alt="最短路径 BFS 算法- 执行过程"></p>
<hr>
<h2 id="-bfs-和图">💡 BFS 和图</h2>
<p>LeetCode 中的 BFS (图数据结构) 相关题目都是在 BFS 基础上加上题目的具体逻辑即可，解题步骤 (模板) 和 BFS 算法一样可以分为四步:</p>
<ol>
<li>初始化队列，节点访问标记等数据结构</li>
<li>将起始节点添加到队列中</li>
<li>循环遍历队列 (队列不为空的前提下)，执行下列操作:
<ol>
<li>从队列中取出第一个节点</li>
<li>处理当前节点：对当前节点进行任何必要的操作，例如更新距离、记录路径等</li>
<li>遍历当前节点的邻居节点：对当前节点的邻居节点进行遍历，检查它们是否已经被访问过</li>
<li>如果邻居节点尚未被访问过，则将其加入队列，并标记为已访问</li>
</ol>
</li>
<li>重复第 3 步，直到队列为空或者所有节点均被访问</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// BFS 刷题模板代码 (针对图数据结构)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">bfs</span>(node *Node) *Node {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 边界处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">if</span> node == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 声明节点访问标记 Map
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    visited := <span style="color:#24909d">make</span>(<span style="color:#6ab825;font-weight:bold">map</span>[*Node]<span style="color:#6ab825;font-weight:bold">bool</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 将起始节点添加到队列中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    queue := []*Node{node}
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 将起始节点标记为已访问
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    visited[node] = <span style="color:#6ab825;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">for</span> <span style="color:#24909d">len</span>(queue) &gt; <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 从队列中取出第一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        top := queue[<span style="color:#3677a9">0</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 第一个节点出队
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        queue = queue[<span style="color:#3677a9">1</span>:]
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 处理具体的逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        ...
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 遍历当前节点的邻居节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        <span style="color:#6ab825;font-weight:bold">for</span> _, neighbor := <span style="color:#6ab825;font-weight:bold">range</span> top.Neighbors {
</span></span><span style="display:flex;"><span>            <span style="color:#6ab825;font-weight:bold">if</span> !visited[neighbor] {
</span></span><span style="display:flex;"><span>                <span style="color:#999;font-style:italic">// 如果邻居节点尚未被访问过，则将其加入队列，并标记为已访问
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>                queue = <span style="color:#24909d">append</span>(queue, neighbor)
</span></span><span style="display:flex;"><span>                visited[neighbor] = <span style="color:#6ab825;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span> ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="-典型题目-图">💡 典型题目 (图)</h2>
<p>为了更好地比较 DFS 算法和 BFS 算法的差异，本文会使用 <a href="https://dbwu.tech/posts/algorithm/leetcode_dfs_pattern/">这篇 DFS 刷题模板文章中</a> 相同的图算法题目作为示例题解。</p>
<h3 id="1-岛屿数量">1. 岛屿数量</h3>
<p>给你一个由 &lsquo;1&rsquo;（陆地）和 &lsquo;0&rsquo;（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#999;font-style:italic"># 示例来自: https://leetcode.cn/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 1：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：grid = [
</span></span><span style="display:flex;"><span>  [<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>],
</span></span><span style="display:flex;"><span>  [<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>],
</span></span><span style="display:flex;"><span>  [<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>],
</span></span><span style="display:flex;"><span>  [<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>]
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>输出：1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 2：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：grid = [
</span></span><span style="display:flex;"><span>  [<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>],
</span></span><span style="display:flex;"><span>  [<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>],
</span></span><span style="display:flex;"><span>  [<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>],
</span></span><span style="display:flex;"><span>  [<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;0&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>]
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>输出：3
</span></span></code></pre></div><p>快速套模板:</p>
<ol>
<li>遍历二维网格</li>
<li>如果当前坐标为 <strong>“陆地”</strong>，岛屿数量 + 1，同时执行 BFS 算法继续探索</li>
<li>在单次 BFS 算法过程中，循环遍历队列 (队列不为空的前提下)，执行下列操作:
<ol>
<li>从队列中取出第一个坐标，如果该坐标为 “陆地”，将该坐标从 “陆地” 标记为从 “水”，避免重复计算</li>
<li>以该坐标为中心，将上下左右四个方向的坐标分别加入队列</li>
<li>重复第 1, 2 步，直到队列为空</li>
</ol>
</li>
<li>二维网格遍历结束，所有坐标都被标记为 <strong>“水”</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">numIslands</span>(grid [][]<span style="color:#6ab825;font-weight:bold">byte</span>) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	res := <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#3677a9">0</span>; i &lt; <span style="color:#24909d">len</span>(grid); i++ {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">for</span> j := <span style="color:#3677a9">0</span>; j &lt; <span style="color:#24909d">len</span>(grid[<span style="color:#3677a9">0</span>]); j++ {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> grid[i][j] == <span style="color:#ed9d13">&#39;1&#39;</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#999;font-style:italic">// 如果找到一块陆地，以该坐标为中心，上下左右四个方向继续探索
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>				res++
</span></span><span style="display:flex;"><span>				<span style="color:#447fcf">bfs</span>(grid, i, j)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> res
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">bfs</span>(grid [][]<span style="color:#6ab825;font-weight:bold">byte</span>, i, j <span style="color:#6ab825;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 将当前的起始坐标加到队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 这里的队列使用二维数组表示
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	queue := [][<span style="color:#3677a9">2</span>]<span style="color:#6ab825;font-weight:bold">int</span>{}
</span></span><span style="display:flex;"><span>	queue = <span style="color:#24909d">append</span>(queue, [<span style="color:#3677a9">2</span>]<span style="color:#6ab825;font-weight:bold">int</span>{i, j})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> <span style="color:#24909d">len</span>(queue) &gt; <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 从队列中取出第一个坐标
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		i, j := queue[<span style="color:#3677a9">0</span>][<span style="color:#3677a9">0</span>], queue[<span style="color:#3677a9">0</span>][<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 第一个坐标出队
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		queue = queue[<span style="color:#3677a9">1</span>:]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 如果坐标未越界 并且 当前坐标是陆地
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> i &gt;= <span style="color:#3677a9">0</span> &amp;&amp; i &lt; <span style="color:#24909d">len</span>(grid) &amp;&amp; j &gt;= <span style="color:#3677a9">0</span> &amp;&amp; j &lt; <span style="color:#24909d">len</span>(grid[<span style="color:#3677a9">0</span>]) &amp;&amp; grid[i][j] == <span style="color:#ed9d13">&#39;1&#39;</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 已经探索过的坐标标记为 0, 避免重复计算
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			grid[i][j] = <span style="color:#ed9d13">&#39;0&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// ⬆ 方向继续探索
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			queue = <span style="color:#24909d">append</span>(queue, [<span style="color:#3677a9">2</span>]<span style="color:#6ab825;font-weight:bold">int</span>{i - <span style="color:#3677a9">1</span>, j})
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// ⬇ 方向继续探索
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			queue = <span style="color:#24909d">append</span>(queue, [<span style="color:#3677a9">2</span>]<span style="color:#6ab825;font-weight:bold">int</span>{i + <span style="color:#3677a9">1</span>, j})
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// &lt;- 方向继续探索
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			queue = <span style="color:#24909d">append</span>(queue, [<span style="color:#3677a9">2</span>]<span style="color:#6ab825;font-weight:bold">int</span>{i, j - <span style="color:#3677a9">1</span>})
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// -&gt; 方向继续探索
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			queue = <span style="color:#24909d">append</span>(queue, [<span style="color:#3677a9">2</span>]<span style="color:#6ab825;font-weight:bold">int</span>{i, j + <span style="color:#3677a9">1</span>})
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/numIslands2.png" alt="BFS 执行过程"></p>
<h3 id="2-被围绕的区域">2. 被围绕的区域</h3>
<p>给你一个 m x n 的矩阵 board ，由若干字符 &lsquo;X&rsquo; 和 &lsquo;O&rsquo; ，找到所有被 &lsquo;X&rsquo; 围绕的区域，并将这些区域里所有的 &lsquo;O&rsquo; 用 &lsquo;X&rsquo; 填充。</p>
<p><img src="https://dbwu.tech/images/algorithm/xogrid.jpg" alt="图片来源: https://leetcode.cn/"></p>
<p>解题思路:</p>
<p>题目解释中提到：任何边界上的 O 都不会被填充为 X, 所有的不被包围的 O 都直接或间接与边界上的 O 相连。那么<strong>只需要将所有可以连通的进行标记，剩下的就是无法连通的</strong>。</p>
<p>题目要求四个边界上面的格子 &lsquo;O&rsquo; 不需要被更新，那么如何在 DFS 的递归执行过程中规避掉这个问题呢？我们可以使用一个额外的字符 <code>#</code> 作为临时字符来替换掉边界上的 &lsquo;O&rsquo;, 专门用于标记已经更新过的格子，最后再将临时字符 <code>#</code> 的格子替换为 &lsquo;O&rsquo;。</p>
<p>快速套模板:</p>
<ol>
<li>初始化队列</li>
<li>对左右边界和上下边界进行预处理，将 &lsquo;O&rsquo; 的坐标标记为 &lsquo;#&rsquo; 并加入队列</li>
<li>循环遍历队列 (队列不为空的前提下)，执行下列操作:
<ol>
<li>从队列中取出第一个节点</li>
<li>以该坐标为中心，上下左右四个方向继续探索</li>
</ol>
</li>
<li>重复第 3 步，直到队列为空或者所有节点均被访问</li>
<li>所有值为 &lsquo;O&rsquo; 的坐标，就是无法从上下左右边界到达的坐标，直接标记为 &lsquo;X&rsquo;, 将所有值为 &lsquo;#&rsquo; 的坐标，标记为 &lsquo;O&rsquo;</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">bfs</span>(board [][]<span style="color:#6ab825;font-weight:bold">byte</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 边界处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#24909d">len</span>(board) == <span style="color:#3677a9">0</span> || <span style="color:#24909d">len</span>(board[<span style="color:#3677a9">0</span>]) == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	rows, cols := <span style="color:#24909d">len</span>(board), <span style="color:#24909d">len</span>(board[<span style="color:#3677a9">0</span>])
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">var</span> queue [][<span style="color:#3677a9">2</span>]<span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 将左右边界进行标记为 &#34;已连通&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> row := <span style="color:#3677a9">0</span>; row &lt; rows; row++ {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> board[row][<span style="color:#3677a9">0</span>] == <span style="color:#ed9d13">&#39;O&#39;</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 将值为 &#39;O&#39; 的坐标加入队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			queue = <span style="color:#24909d">append</span>(queue, [<span style="color:#3677a9">2</span>]<span style="color:#6ab825;font-weight:bold">int</span>{row, <span style="color:#3677a9">0</span>})
</span></span><span style="display:flex;"><span>			board[row][<span style="color:#3677a9">0</span>] = <span style="color:#ed9d13">&#39;#&#39;</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> board[row][cols-<span style="color:#3677a9">1</span>] == <span style="color:#ed9d13">&#39;O&#39;</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 将值为 &#39;O&#39; 的坐标加入队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			queue = <span style="color:#24909d">append</span>(queue, [<span style="color:#3677a9">2</span>]<span style="color:#6ab825;font-weight:bold">int</span>{row, cols - <span style="color:#3677a9">1</span>})
</span></span><span style="display:flex;"><span>			board[row][cols-<span style="color:#3677a9">1</span>] = <span style="color:#ed9d13">&#39;#&#39;</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 将上下边界进行标记为 &#34;已连通&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> col := <span style="color:#3677a9">1</span>; col &lt; cols-<span style="color:#3677a9">1</span>; col++ {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> board[<span style="color:#3677a9">0</span>][col] == <span style="color:#ed9d13">&#39;O&#39;</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 将值为 &#39;O&#39; 的坐标加入队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			queue = <span style="color:#24909d">append</span>(queue, [<span style="color:#3677a9">2</span>]<span style="color:#6ab825;font-weight:bold">int</span>{<span style="color:#3677a9">0</span>, col})
</span></span><span style="display:flex;"><span>			board[<span style="color:#3677a9">0</span>][col] = <span style="color:#ed9d13">&#39;#&#39;</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> board[rows-<span style="color:#3677a9">1</span>][col] == <span style="color:#ed9d13">&#39;O&#39;</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 将值为 &#39;O&#39; 的坐标加入队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			queue = <span style="color:#24909d">append</span>(queue, [<span style="color:#3677a9">2</span>]<span style="color:#6ab825;font-weight:bold">int</span>{rows - <span style="color:#3677a9">1</span>, col})
</span></span><span style="display:flex;"><span>			board[rows-<span style="color:#3677a9">1</span>][col] = <span style="color:#ed9d13">&#39;#&#39;</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	dx := []<span style="color:#6ab825;font-weight:bold">int</span>{<span style="color:#3677a9">0</span>, <span style="color:#3677a9">0</span>, -<span style="color:#3677a9">1</span>, <span style="color:#3677a9">1</span>} <span style="color:#999;font-style:italic">// x: 上下左右
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	dy := []<span style="color:#6ab825;font-weight:bold">int</span>{-<span style="color:#3677a9">1</span>, <span style="color:#3677a9">1</span>, <span style="color:#3677a9">0</span>, <span style="color:#3677a9">0</span>} <span style="color:#999;font-style:italic">// y: 上下左右
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> <span style="color:#24909d">len</span>(queue) &gt; <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 从队列中取出第一个坐标
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		top := queue[<span style="color:#3677a9">0</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 第一个坐标出队
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		queue = queue[<span style="color:#3677a9">1</span>:]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 以该坐标为中心，上下左右四个方向继续探索
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#3677a9">0</span>; i &lt; <span style="color:#3677a9">4</span>; i++ {
</span></span><span style="display:flex;"><span>			x, y := top[<span style="color:#3677a9">0</span>]+dx[i], top[<span style="color:#3677a9">1</span>]+dy[i]
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> x &gt; <span style="color:#3677a9">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt; <span style="color:#3677a9">0</span> &amp;&amp; y &lt; cols &amp;&amp; board[x][y] == <span style="color:#ed9d13">&#39;O&#39;</span> {
</span></span><span style="display:flex;"><span>				queue = <span style="color:#24909d">append</span>(queue, [<span style="color:#3677a9">2</span>]<span style="color:#6ab825;font-weight:bold">int</span>{x, y})
</span></span><span style="display:flex;"><span>				board[x][y] = <span style="color:#ed9d13">&#39;#&#39;</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 现在从矩阵的最外侧作为出发点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 上下左右四个方向已经连通
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 只需要遍历一次矩阵
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 将 # 修改为 0, 因为这些属于边界上的 0
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 将 0 改为为 X, 因为这些不属于边界上的 0
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> row := <span style="color:#3677a9">0</span>; row &lt; rows; row++ {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">for</span> col := <span style="color:#3677a9">0</span>; col &lt; cols; col++ {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> board[row][col] == <span style="color:#ed9d13">&#39;#&#39;</span> {
</span></span><span style="display:flex;"><span>				board[row][col] = <span style="color:#ed9d13">&#39;O&#39;</span>
</span></span><span style="display:flex;"><span>			} <span style="color:#6ab825;font-weight:bold">else</span> <span style="color:#6ab825;font-weight:bold">if</span> board[row][col] == <span style="color:#ed9d13">&#39;O&#39;</span> {
</span></span><span style="display:flex;"><span>				board[row][col] = <span style="color:#ed9d13">&#39;X&#39;</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/130solve2.png" alt="状态更新 - 执行过程"></p>
<h3 id="3-克隆图">3. 克隆图</h3>
<p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</p>
<p>节点的深度拷贝需要满足两个条件:</p>
<ol>
<li>新节点必须和源节点的值一样，并且拥有新的内存地址空间和数据结构</li>
<li>各个新节点之间的关系必须和源节点之间的关系一致</li>
</ol>
<p><img src="https://dbwu.tech/images/algorithm/133_clone_graph_question.png" alt="图片来源: https://leetcode.cn/"></p>
<p>快速套模板:</p>
<ol>
<li>初始化队列，克隆节点 Map</li>
<li>将起始节点添加到队列中，同时克隆当前节点并添加源节点到克隆节点的映射</li>
<li>循环遍历队列 (队列不为空的前提下)，执行下列操作:
<ol>
<li>从队列中取出第一个节点</li>
<li>遍历当前节点的邻居节点，如果邻居节点还未被克隆过，克隆邻居节点并添加源节点到克隆节点的映射，最后将邻居节点加入队列</li>
</ol>
</li>
<li>重复第 3 步，直到队列为空或者所有节点均被访问</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">cloneGraph</span>(node *Node) *Node {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#447fcf">bfs</span>(node, <span style="color:#24909d">make</span>(<span style="color:#6ab825;font-weight:bold">map</span>[*Node]*Node))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">bfs</span>(node *Node) *Node {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 边界处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> node == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> node
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 声明节点访问标记 Map
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 除了访问标记外，该 Map 还有另外一个作用
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 那就是将源节点和克隆节点进行映射
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	visited := <span style="color:#24909d">make</span>(<span style="color:#6ab825;font-weight:bold">map</span>[*Node]*Node)
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 克隆起始节点 (将起始节点标记为已访问)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	visited[node] = &amp;Node{node.Val, []*Node{}}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 将起始节点添加到队列中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	queue := []*Node{node}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> <span style="color:#24909d">len</span>(queue) &gt; <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 从队列中取出第一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		top := queue[<span style="color:#3677a9">0</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 第一个节点出队
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		queue = queue[<span style="color:#3677a9">1</span>:]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">for</span> _, v := <span style="color:#6ab825;font-weight:bold">range</span> top.Neighbors {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> _, ok := visited[v]; !ok {
</span></span><span style="display:flex;"><span>				<span style="color:#999;font-style:italic">// 如果邻居节点还未被克隆过 (未被访问过)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>				<span style="color:#999;font-style:italic">// 克隆邻居节点 (标记为已访问)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>				visited[v] = &amp;Node{v.Val, []*Node{}}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#999;font-style:italic">// 将邻居节点添加到队列中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>				queue = <span style="color:#24909d">append</span>(queue, v)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 更新当前节点的邻居节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			visited[top].Neighbors = <span style="color:#24909d">append</span>(visited[top].Neighbors, visited[v])
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 返回起始节点对应的克隆新节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">return</span> visited[node]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/cloneGraph2.png" alt="克隆图 - 执行过程"></p>
<hr>
<h2 id="-bfs-和二叉树">💡 BFS 和二叉树</h2>
<blockquote>
<p>BFS 算法最经典应用场景之一，就是二叉树层级的层级遍历和搜索相关问题。</p>
</blockquote>
<h3 id="算法复杂度">算法复杂度</h3>
<p><strong>时间复杂度</strong>：O(N)，其中 N 是二叉树中的节点个数，搜索过程中 (最坏情况下) 需要对每个节点访问一次。</p>
<p><strong>空间复杂度</strong>：O(W)，其中 W 是二叉树的最大宽度，空间复杂度和树的高度正相关，对于高度为 H 的二叉树，空间复杂度最多为 O(W) = O((H-1)^2)，也就是满二叉树的情况。</p>
<p><strong>最坏情况下，二叉树的高度等于节点个数</strong>，也就是类似如下图所示 “链表” 的二叉树结构。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>        <span style="color:#3677a9">1</span>
</span></span><span style="display:flex;"><span>	   /
</span></span><span style="display:flex;"><span>	  <span style="color:#3677a9">2</span>
</span></span><span style="display:flex;"><span>	 /
</span></span><span style="display:flex;"><span>    <span style="color:#3677a9">3</span>
</span></span><span style="display:flex;"><span>   /
</span></span><span style="display:flex;"><span>  <span style="color:#3677a9">4</span>
</span></span><span style="display:flex;"><span> /
</span></span><span style="display:flex;"><span><span style="color:#3677a9">5</span>  
</span></span></code></pre></div><blockquote>
<p>💡 解决二叉树的层级遍历相关问题时，BFS 算法和 DFS 算法的时间复杂度和空间复杂度是一样的，但是 BFS 算法相对直观和容易理解。</p>
</blockquote>
<h3 id="刷题模板">刷题模板</h3>
<p>LeetCode 中的二叉树 BFS 相关题目都是在 BFS 算法基础上加上具体逻辑即可，因为只需要一个额外的队列数据结构，再加上二叉树的层级遍历过程非常直观，所以只需要在模板代码的基础上略微修改就可以快速刷题。</p>
<ol>
<li>初始化队列</li>
<li>将根节点加入到队列中</li>
<li>循环遍历队列 (队列不为空的前提下)，执行下列操作:
<ol>
<li>从队列中取出第一个节点</li>
<li>对该节点进行逻辑处理</li>
<li>将该节点左右子节点加入到队列中</li>
</ol>
</li>
<li>重复第 3 步，直到队列为空</li>
</ol>
<p>下面是一个使用 BFS 层级遍历二叉树的代码模板。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">levelOrder</span>(root *TreeNode) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 边界处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 初始化队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 将根节点加入到队列中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>    queue := []*TreeNode{root}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">for</span> <span style="color:#24909d">len</span>(queue) &gt; <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 记录当前层的节点数
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 便于内部循环处理当前所在层的所有节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        length := <span style="color:#24909d">len</span>(queue)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 声明初始化用于处理当前层逻辑的数据结构
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 处理当前层的所有节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>        <span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#3677a9">0</span>; i &lt; length; i++ {
</span></span><span style="display:flex;"><span>            <span style="color:#999;font-style:italic">// 从队列中取出第一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>            node := queue[<span style="color:#3677a9">0</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 第一个节点出队
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>            queue = queue[<span style="color:#3677a9">1</span>:]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 处理具体的逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#999;font-style:italic">// 将当前节点的左右子节点加入队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>            <span style="color:#6ab825;font-weight:bold">if</span> node.Left != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>                queue = <span style="color:#24909d">append</span>(queue, node.Left)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#6ab825;font-weight:bold">if</span> node.Right != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>                queue = <span style="color:#24909d">append</span>(queue, node.Right)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#999;font-style:italic">// 处理具体的逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6ab825;font-weight:bold">return</span> result
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="-典型题目-二叉树">💡 典型题目 (二叉树)</h2>
<p>为了更好地比较 DFS 算法和 BFS 算法的差异，本文会使用 <a href="https://dbwu.tech/posts/algorithm/leetcode_bfs_pattern/">这篇 DFS 刷题模板文章中</a> 相同的二叉树题目作为示例题解。</p>
<h3 id="1-二叉树的最大深度">1. 二叉树的最大深度</h3>
<p>给定一个二叉树 root ，返回其最大深度。
二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<p><img src="https://dbwu.tech/images/algorithm/tmp-tree.png" alt="图片来源: https://leetcode.cn/"></p>
<p>如图所示的 树 的深度为 3。</p>
<p>快速套模板:</p>
<ol>
<li>初始化队列</li>
<li>将根节点加入到队列中</li>
<li>循环遍历队列 (队列不为空的前提下)，执行下列操作:
<ol>
<li>初始化 “当前层的总和” 为 0</li>
<li>挨个取出当前层的所有节点</li>
<li>将当前节点的值累加到 “当前层的总和”，同时将当前节点的左右子节点添加到队列中</li>
<li>计算当前层的所有节点的平均值并追加到结果集中</li>
</ol>
</li>
<li>重复第 3 步，直到队列为空</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">maxDepth</span>(root *TreeNode) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 边界处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 初始化队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 将根节点加入到队列中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	queue := []*TreeNode{root}
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 记录已到达树的深度
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	depth := <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> <span style="color:#24909d">len</span>(queue) &gt; <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 更新已到达树的深度
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		depth++
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 记录当前层的节点数
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		length := <span style="color:#24909d">len</span>(queue)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#3677a9">0</span>; i &lt; length; i++ {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 将当前节点的左右子节点加入队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#6ab825;font-weight:bold">if</span> queue[i].Left != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>				queue = <span style="color:#24909d">append</span>(queue, queue[i].Left)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> queue[i].Right != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>				queue = <span style="color:#24909d">append</span>(queue, queue[i].Right)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 利用 Go 语言的语法糖处理队列的出队操作
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		queue = queue[length:]
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> depth
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/maxDepth2.png" alt="二叉树的最大深度 - 执行过程"></p>
<h3 id="2-二叉树的层平均值">2. 二叉树的层平均值</h3>
<p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。</p>
<p><img src="https://dbwu.tech/images/algorithm/avg1-tree.jpg" alt="图片来源: https://leetcode.cn/"></p>
<p>给出上图所示的二叉树，会输出如下答案:</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>输出：[3.00000,14.50000,11.00000]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>解释：第 <span style="color:#3677a9">0</span> 层的平均值为 3,第 <span style="color:#3677a9">1</span> 层的平均值为 14.5,第 <span style="color:#3677a9">2</span> 层的平均值为 <span style="color:#3677a9">11</span> 。
</span></span><span style="display:flex;"><span>因此返回 [3, 14.5, 11] 。
</span></span></code></pre></div><p>快速套模板:</p>
<ol>
<li>初始化队列</li>
<li>将根节点加入到队列中</li>
<li>循环遍历队列 (队列不为空的前提下)，执行下列操作:
<ol>
<li>初始化 “当前层的总和” 为 0</li>
<li>挨个取出当前层的所有节点</li>
<li>将当前节点的值累加到 “当前层的总和”，同时将当前节点的左右子节点添加到队列中</li>
<li>计算当前层的所有节点的平均值并追加到结果集中</li>
</ol>
</li>
<li>重复第 3 步，直到队列为空</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">averageOfLevels</span>(root *TreeNode) []<span style="color:#6ab825;font-weight:bold">float64</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 边界处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">var</span> res []<span style="color:#6ab825;font-weight:bold">float64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> res
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 初始化队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 将根节点加入到队列中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	queue := []*TreeNode{root}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> <span style="color:#24909d">len</span>(queue) &gt; <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		length := <span style="color:#24909d">len</span>(queue)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 初始化 “当前层的总和” 为 0
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		sum := <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#3677a9">0</span>; i &lt; length; i++ {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 将当前节点的值累加到 “当前层的总和”
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			sum += queue[i].Val
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 将当前节点的左右子节点加入队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#6ab825;font-weight:bold">if</span> queue[i].Left != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>				queue = <span style="color:#24909d">append</span>(queue, queue[i].Left)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> queue[i].Right != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>				queue = <span style="color:#24909d">append</span>(queue, queue[i].Right)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 利用 Go 语言的语法糖处理队列的出队操作
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		queue = queue[length:]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 计算当前层的所有节点的平均值并追加到结果集中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		res = <span style="color:#24909d">append</span>(res, <span style="color:#24909d">float64</span>(sum)/<span style="color:#24909d">float64</span>(length))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> res
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/averageOfLevels2.png" alt="二叉树的层平均值 - 执行过程"></p>
<h3 id="3-二叉树根节点到叶节点数字之和">3. 二叉树根节点到叶节点数字之和</h3>
<p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：
例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。
叶节点 是指没有子节点的节点。</p>
<p><img src="https://dbwu.tech/images/algorithm/num1tree.jpg" alt="图片来源: https://leetcode.cn/"></p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#999;font-style:italic"># 如图所示</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：root = [1,2,3]
</span></span><span style="display:flex;"><span>输出：25
</span></span><span style="display:flex;"><span>解释：
</span></span><span style="display:flex;"><span>从根到叶子节点路径 1-&gt;2 代表数字 <span style="color:#3677a9">12</span>
</span></span><span style="display:flex;"><span>从根到叶子节点路径 1-&gt;3 代表数字 <span style="color:#3677a9">13</span>
</span></span><span style="display:flex;"><span>因此，数字总和 = <span style="color:#3677a9">12</span> + <span style="color:#40ffff">13</span> = <span style="color:#3677a9">25</span>
</span></span></code></pre></div><p>解题思路:</p>
<p><strong>和 DFS 算法不同的是</strong>: 使用 BFS 算法层级遍历二叉树时，只有遍历到了某个具体的叶子节点时，才能计算出这条路径上面的数字总和，所以在到达叶子节点之前，对于已经遍历过的层级节点路径，需要单独使用一个队列 (数组) 保存起来。</p>
<p>快速套模板:</p>
<ol>
<li>初始化节点队列和 <strong>路径数字总和队列</strong></li>
<li>将根节点加入到节点队列中，将根节点的值加入到 路径数字总和队列 中</li>
<li>循环遍历队列 (节点队列不为空的前提下)，执行下列操作:
<ol>
<li>从节点队列中取出第一个节点 <code>node</code>，从 路径数字总和队列 中取出第一个数字 <code>num</code></li>
<li>如果当前节点是叶子节点，就将 <code>num</code> 加入到结果总和中</li>
<li>如果当前节点不是叶子节点，将 <code>node</code> 的左右子节点加入节点队列，将 <code>num</code> 和 <code>node</code> 的左右子节点的值重新计算，然后加入 路径数字总和队列</li>
</ol>
</li>
<li>重复第 3 步，直到节点队列为空</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">sumNumbers</span>(root *TreeNode) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 边界处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 返回值, 路径总和
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	sum := <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 初始化两个队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 将根节点加入到节点队列中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	nodeQueue := []*TreeNode{root}
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 将根节点的值加入到 路径数字总和队列 中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	numQueue := []<span style="color:#6ab825;font-weight:bold">int</span>{root.Val}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> <span style="color:#24909d">len</span>(nodeQueue) &gt; <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 获取当前节点
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		node := nodeQueue[<span style="color:#3677a9">0</span>]
</span></span><span style="display:flex;"><span>		nodeQueue = nodeQueue[<span style="color:#3677a9">1</span>:]
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 获取当前 “路径和”
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		num := numQueue[<span style="color:#3677a9">0</span>]
</span></span><span style="display:flex;"><span>		numQueue = numQueue[<span style="color:#3677a9">1</span>:]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> node.Left == <span style="color:#6ab825;font-weight:bold">nil</span> &amp;&amp; node.Right == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 叶子节点，直接将当前的 “路径和” 累加到返回值总和中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			sum += num
</span></span><span style="display:flex;"><span>		} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 将当前节点的左右子节点加入队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 将 当前 “路径和” 和当前节点的左右子节点的值 重新计算
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">//   然后加入 路径数字总和队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#6ab825;font-weight:bold">if</span> node.Left != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>				nodeQueue = <span style="color:#24909d">append</span>(nodeQueue, node.Left)
</span></span><span style="display:flex;"><span>				numQueue = <span style="color:#24909d">append</span>(numQueue, num*<span style="color:#3677a9">10</span>+node.Left.Val)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> node.Right != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>				nodeQueue = <span style="color:#24909d">append</span>(nodeQueue, node.Right)
</span></span><span style="display:flex;"><span>				numQueue = <span style="color:#24909d">append</span>(numQueue, num*<span style="color:#3677a9">10</span>+node.Right.Val)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> sum
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/sumNumbers3.png" alt="二叉树根节点到叶节点数字之和 - 执行过程"></p>
<h3 id="4-二叉树的右视图">4. 二叉树的右视图</h3>
<p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p><img src="https://dbwu.tech/images/algorithm/tree_right_view.jpg" alt="图片来源: https://leetcode.cn/"></p>
<p>如图所示的树的右视图为 [1, 3, 4] 也就是树的每一层最右侧的节点值组成的列表。</p>
<p>快速套模板:</p>
<ol>
<li>初始化队列</li>
<li>将根节点加入到队列中</li>
<li>循环遍历队列 (队列不为空的前提下)，执行下列操作:
<ol>
<li>将当前层级中的最右边的节点值添加到返回结果数组中</li>
</ol>
</li>
<li>重复第 3 步，直到队列为空</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">rightSideView</span>(root *TreeNode) []<span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 边界处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> root == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> []<span style="color:#6ab825;font-weight:bold">int</span>{}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 声明返回值数组
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">var</span> res []<span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 初始化两个队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 将根节点加入到节点队列中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	queue := []*TreeNode{root}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> <span style="color:#24909d">len</span>(queue) &gt; <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		length := <span style="color:#24909d">len</span>(queue)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#3677a9">0</span>; i &lt; length; i++ {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 将当前节点的左右子节点加入队列
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#6ab825;font-weight:bold">if</span> queue[i].Left != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>				queue = <span style="color:#24909d">append</span>(queue, queue[i].Left)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> queue[i].Right != <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>				queue = <span style="color:#24909d">append</span>(queue, queue[i].Right)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 将当前队列 (层级) 中的最右边的节点值添加到返回结果数组中
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		res = <span style="color:#24909d">append</span>(res, queue[length-<span style="color:#3677a9">1</span>].Val)
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 利用 Go 语言的语法糖处理队列的出队操作
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		queue = queue[length:]
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> res
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/rightSideView.png" alt="二叉树的右视图 - 执行过程"></p>
<hr>
<h2 id="-其他送分题">💡 其他送分题</h2>
<p>熟练掌握使用 BFS 算法层级遍历二叉树之后，相关的题目全部是送分题。</p>
<h3 id="1-翻转二叉树">1. 翻转二叉树</h3>
<p><img src="https://dbwu.tech/images/algorithm/invert1-tree.jpg" alt="图片来源: https://leetcode.cn/"></p>
<p>解题思路:</p>
<ol>
<li>BFS 层级遍历</li>
<li>每一层中 <strong>反转当前队列中的所有节点</strong></li>
</ol>
<h3 id="2-完全二叉树的节点个数">2. 完全二叉树的节点个数</h3>
<p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p>
<p><img src="https://dbwu.tech/images/algorithm/complete.jpg" alt="图片来源: https://leetcode.cn/"></p>
<p>如图所示的二叉树节点数量为 6。</p>
<p>解题思路:</p>
<p>BFS 层级遍历时将当前队列中的所有节点数量进行累计，BFS 遍历结束后反复累计数量值。</p>
<h3 id="3-二叉树的层序遍历">3. 二叉树的层序遍历</h3>
<p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。（即逐层地，从左到右访问所有节点）。</p>
<p><img src="https://dbwu.tech/images/algorithm/tree1.jpg" alt="图片来源: https://leetcode.cn/"></p>
<p>这道题几乎就是 BFS 算法稍微一改就可以 AC 了。</p>
<p>解题思路:</p>
<ol>
<li>BFS 层级遍历，将当前层级中的所有节点值添加到一维数组中</li>
<li>将一维数组追加到返回值二维数组中</li>
</ol>
<h3 id="4-二叉树的锯齿形层序遍历">4. 二叉树的锯齿形层序遍历</h3>
<p>给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p><img src="https://dbwu.tech/images/algorithm/tree1.jpg" alt="图片来源: https://leetcode.cn/"></p>
<p>如图所示的二叉树，使用锯齿层序遍历返回值为 [[3],[20,9],[15,7]]。</p>
<p>解题思路:</p>
<ol>
<li>BFS 层级遍历，层级遍历，将当前层级中的所有节点值添加到一维数组中</li>
<li>如果当前层是奇数，将一维数组中的值顺序添加到返回值二维数组中</li>
<li>如果当前层是偶数，将一维数组中的值逆序 (反向) 添加到返回值二维数组中 (也就是先将数组反转，然后再添加到返回值二维数组中)</li>
</ol>


</article>

<article>
    <img src="https://dbwu.tech/images/wechat.png">
</article>

<article>
    <h3>转载申请</h3>

    <p>
        本作品采用 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> 进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，商业转载请联系作者获得授权。
    </p>
</article>

<section class="post-nav">
    <ul>
        <li>
        
            <a href="https://dbwu.tech/posts/algorithm/leetcode_dfs_pattern/"><i class="fa fa-chevron-circle-left"></i> LeetCode DFS 刷题模板</a>
        
        </li>
        <li>
        
            <a href="https://dbwu.tech/posts/algorithm/leetcode_topological_sorting_pattern/">LeetCode 拓扑排序 刷题模板 <i class="fa fa-chevron-circle-right"></i> </a>
        
        </li>
    </ul>
</section>
  
    
    
  


<script src="https://giscus.app/client.js"
        data-repo="duanbiaowu/dbwu.tech"
        data-repo-id="R_kgDOIkkjjw"
        data-category="Announcements"
        data-category-id="DIC_kwDOIkkjj84CV78j"
        data-mapping="specific"
        data-term="LeetCode BFS 刷题模板"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous" async>
</script>




</main>
    <footer>
        <ul>
            <li>
                <h6><a href="mailto:codean.net@gmail.com">codean.net@gmail.com</a> | 
                    <img src="https://dbwu.tech/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" />
                    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61011302001681" target="_blank">陕公网安备 61011302001681 号</a> |
                    <a href="https://beian.miit.gov.cn" target="_blank">陕ICP备2023004378号-1</a> |
                    Rendered by <a href="https://themes.gohugo.io" title="Hugo" target="_blank">Hugo</a>
                </h6>
            </li>
            
            
        </ul>
    </footer>
</div>
<script src="https://dbwu.tech/js/scripts.js"></script>


</body>

</html>

