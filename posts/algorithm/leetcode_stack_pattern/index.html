<!doctype html>

<html lang="en">

<head>
  <title>LeetCode Stack 刷题模板 - 蛮荆</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="" />
<meta name="author" content="" />
<link rel="shortcut icon" href="https://dbwu.tech/favicon.ico" type="image/x-icon" /><meta property="og:title" content="LeetCode Stack 刷题模板" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dbwu.tech/posts/algorithm/leetcode_stack_pattern/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-12T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-04-12T00:00:00+00:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode Stack 刷题模板"/>
<meta name="twitter:description" content=""/>

<meta name="generator" content="Hugo 0.120.3">
    
    <script src="https://dbwu.tech/js/mathjax-config.js" defer></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CZMGTTFLNY"></script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3261056100776781" crossorigin="anonymous"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-CZMGTTFLNY');
  </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>


  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/normalize.min.css" />
  <link rel="stylesheet" href="https://dbwu.tech/fontawesome/css/all.min.css" />
  
    
    <link href="//fonts.googleapis.com/css?family=Staatliches" rel="stylesheet">
  
  
  <link rel="stylesheet" type="text/css" href="https://dbwu.tech/css/styles-light.css" />
  </head>

<body>
  <div id="container">
    <header>
      
      <h1>
        <a href="https://dbwu.tech/">蛮荆</a>
      </h1>

      <ul id="social-media">
      </ul>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="active" href="https://dbwu.tech/posts/">
                <i class="fa-li fa  fa-lg"></i><span>归档</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/tags/">
                <i class="fa-li fa  fa-lg"></i><span>标签</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://github.com/duanbiaowu">
                <i class="fa-li fa  fa-lg"></i><span>Github</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://dbwu.tech/index.xml">
                <i class="fa-li fa  fa-lg"></i><span>RSS</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<article>

    <h1>LeetCode Stack 刷题模板</h1>

    
      
<p>
    <span>2023-04-12</span>
    
    
    <a class="article-tag" href="https://dbwu.tech/tags/%E7%AE%97%E6%B3%95">算法</a>
    
</p>

    

    
      

    

    <h2 id="-概述">📖 概述</h2>
<p>在计算机科学中，栈 (Stack) 是一种抽象数据结构，主要针对集合类数据 (最常见的是数组) 进行两种操作：</p>
<ol>
<li><strong>Push (入栈)</strong>: 将元素添加到集合中</li>
<li><strong>Pop (出栈)</strong>: 将最近加入的元素从集合中删除</li>
</ol>
<p><img src="https://dbwu.tech/images/algorithm/Lifo_stack.svg.png" alt="栈的操作 - 执行过程"></p>
<p>如上图所示的栈结构中，初始化栈内元素为 1，紧接着进行了两轮操作:</p>
<ol>
<li>将元素 2, 3, 4, 5, 6 分别入栈 (也就是图中的 1, 2, 3, 4, 5 对应的小图)</li>
<li>将元素 6, 5, 4, 2, 2 分别出栈 (也就是图中的 6, 7, 8, 9, 10 对应的小图)</li>
</ol>
<p>因为入栈和出栈的操作顺序正好相反，所以栈的顺序简称为 “后进先出”，单次缩写为 LIFO (Last In, First Out)。</p>
<h3 id="-容易出错的细节">🛠️ 容易出错的细节</h3>
<p>虽然栈 (Stack) 数据结构简单直观，易于理解，但是实践中还是有几个常见的细节会引发 Bug。</p>
<ol>
<li>入栈和出栈操作顺序错误</li>
<li><strong>边界异常</strong>: 栈为空时出栈、栈溢出 (栈已满时入栈)</li>
<li>无限循环或递归: 没有及时出栈或者出栈逻辑实现错误</li>
<li>元素类型异常: 入栈之前应该检测元素类型，尤其是当元素为接口类型时，一定要检测入栈元素是否实现了特定接口，避免运行时错误</li>
</ol>
<h3 id="golang-stack">Golang Stack</h3>
<p>Go 语言中并没有专门的 Stack 数据类型，大部分情况下使用切片 <code>Slice</code> 作为栈 (Stack) 的实现，使用方法和其他主流编程语言相比，属于实现别扭且难用型，建议读者配合日常使用的编辑器对应的插件 (高亮提示+代码自动补全) 来编写代码。</p>
<p><img src="https://dbwu.tech/images/algorithm/vscode_golang_stack.png" alt="VSCode 栈操作 - 代码自动补全"></p>
<p>如图所示为 VSCode 中操作 Stack 数据结构时对应的代码自动补全，可以调用的 <code>append</code> 方法实现入栈操作，调用 <code>last</code> 方法获取栈顶元素。</p>
<hr>
<h2 id="-典型题目">💡 典型题目</h2>
<p>LeetCode 中的 栈 (Stack) 相关题目单纯就是对栈操作的细节考察，只需要将解题步骤编写为对应的代码即可。</p>
<h3 id="1-有效的括号">1. 有效的括号</h3>
<p>给定一个只包括 &lsquo;(&rsquo;，&rsquo;)&rsquo;，&rsquo;{&rsquo;，&rsquo;}&rsquo;，&rsquo;[&rsquo;，&rsquo;]&rsquo; 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#999;font-style:italic"># 示例来源: https://leetcode.cn/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 1：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：s = <span style="color:#ed9d13">&#34;()[]{}&#34;</span>
</span></span><span style="display:flex;"><span>输出：true
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 2：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：s = <span style="color:#ed9d13">&#34;(]&#34;</span>
</span></span><span style="display:flex;"><span>输出：false
</span></span></code></pre></div><p>解题思路:</p>
<ol>
<li>将字符分为两组，左边界组: <code>(  {  [</code>, 右边界组  <code>)  }  ]</code>，并形成映射关系: <code>( =&gt; ), { =&gt; }, [ =&gt; ]</code></li>
<li>声明并初始化一个栈结构，用于存储字符</li>
<li>遍历字符串
<ol>
<li>如果当前字符属于左边界组，将其入栈</li>
<li>如果当前字符属于右边界组，取出栈顶字符</li>
<li>比较当前字符和栈顶字符是否为映射关系，如果不是，说明字符串不是有效括号，直接返回 false 即可</li>
</ol>
</li>
<li>遍历字符串结束，确认栈是否为空，如果为空，说明字符串是有效括号，如果不为空，说明字符串不是有效括号</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">isValid</span>(s <span style="color:#6ab825;font-weight:bold">string</span>) <span style="color:#6ab825;font-weight:bold">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 如果 s 的长度为奇数，肯定不是有效括号
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#24909d">len</span>(s)&amp;<span style="color:#3677a9">1</span> == <span style="color:#3677a9">1</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 将左右边界字符进行分组并形成映射
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	charMap := <span style="color:#6ab825;font-weight:bold">map</span>[<span style="color:#6ab825;font-weight:bold">byte</span>]<span style="color:#6ab825;font-weight:bold">byte</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#ed9d13">&#39;(&#39;</span>: <span style="color:#ed9d13">&#39;)&#39;</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#ed9d13">&#39;{&#39;</span>: <span style="color:#ed9d13">&#39;}&#39;</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#ed9d13">&#39;[&#39;</span>: <span style="color:#ed9d13">&#39;]&#39;</span>,
</span></span><span style="display:flex;"><span>	} 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 初始化栈
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">var</span> stack []<span style="color:#6ab825;font-weight:bold">byte</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#6ab825;font-weight:bold">range</span> s {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">if</span> _, ok := charMap[s[i]]; ok {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 左边界组的字符直接入栈
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			stack = <span style="color:#24909d">append</span>(stack, s[i])
</span></span><span style="display:flex;"><span>		} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 右边界组的字符与栈顶元素进行比较
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			index := <span style="color:#24909d">len</span>(stack) - <span style="color:#3677a9">1</span>
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#24909d">len</span>(stack) == <span style="color:#3677a9">0</span> || s[i] != charMap[stack[index]] {
</span></span><span style="display:flex;"><span>				<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">false</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			stack = stack[:index]
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 此时栈内可能还存在一些左边界字符
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 所以需要判断栈是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#24909d">len</span>(stack) == <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/isValid.png" alt="有效的括号检测 - 代码执行过程"></p>
<h3 id="2逆波兰表达式求值">2.逆波兰表达式求值</h3>
<p>给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#999;font-style:italic"># 示例来源: https://leetcode.cn/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 1：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：tokens = [<span style="color:#ed9d13">&#34;2&#34;</span>,<span style="color:#ed9d13">&#34;1&#34;</span>,<span style="color:#ed9d13">&#34;+&#34;</span>,<span style="color:#ed9d13">&#34;3&#34;</span>,<span style="color:#ed9d13">&#34;*&#34;</span>]
</span></span><span style="display:flex;"><span>输出：9
</span></span><span style="display:flex;"><span>解释：该算式转化为常见的中缀算术表达式为：((<span style="color:#3677a9">2</span> + 1) * 3) = <span style="color:#3677a9">9</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 2：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：tokens = [<span style="color:#ed9d13">&#34;4&#34;</span>,<span style="color:#ed9d13">&#34;13&#34;</span>,<span style="color:#ed9d13">&#34;5&#34;</span>,<span style="color:#ed9d13">&#34;/&#34;</span>,<span style="color:#ed9d13">&#34;+&#34;</span>]
</span></span><span style="display:flex;"><span>输出：6
</span></span><span style="display:flex;"><span>解释：该算式转化为常见的中缀算术表达式为：(<span style="color:#3677a9">4</span> + (<span style="color:#3677a9">13</span> / 5)) = <span style="color:#3677a9">6</span>
</span></span></code></pre></div><p>解题思路:</p>
<ol>
<li>声明并初始化一个栈结构，用于存储遍历过程中遇到的数字</li>
<li>遍历 tokens 数组
<ol>
<li>如果当前 token 是数字，将其入栈</li>
<li>如果当前 token 是运算符，取出栈顶的两个数字，并根据运算符执行具体的计算，然后将计算结果加入栈</li>
</ol>
</li>
<li>遍历 tokens 数组结束，<strong>返回栈底元素</strong> (也就是最后一次计算出的结果值)</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">evalRPN</span>(tokens []<span style="color:#6ab825;font-weight:bold">string</span>) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#24909d">len</span>(tokens) == <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">var</span> stack []<span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> _, token := <span style="color:#6ab825;font-weight:bold">range</span> tokens {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 将当前 token 解析为数字
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		val, err := strconv.<span style="color:#447fcf">Atoi</span>(token)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 如果没有发生错误
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 说明当前 token 为数字，直接入栈
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> err == <span style="color:#6ab825;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			stack = <span style="color:#24909d">append</span>(stack, val)
</span></span><span style="display:flex;"><span>		} <span style="color:#6ab825;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 说明当前 token 为运算符
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 取出栈顶的两个数字
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			num1, num2 := stack[<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">2</span>], stack[<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>			stack = stack[:<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">2</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 根据不同的运算符执行不同的计算
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 同时将计算结果加入到栈中s
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#6ab825;font-weight:bold">switch</span> token {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">case</span> <span style="color:#ed9d13">&#34;+&#34;</span>:
</span></span><span style="display:flex;"><span>				stack = <span style="color:#24909d">append</span>(stack, num1+num2)
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">case</span> <span style="color:#ed9d13">&#34;-&#34;</span>:
</span></span><span style="display:flex;"><span>				stack = <span style="color:#24909d">append</span>(stack, num1-num2)
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">case</span> <span style="color:#ed9d13">&#34;*&#34;</span>:
</span></span><span style="display:flex;"><span>				stack = <span style="color:#24909d">append</span>(stack, num1*num2)
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">case</span> <span style="color:#ed9d13">&#34;/&#34;</span>:
</span></span><span style="display:flex;"><span>				stack = <span style="color:#24909d">append</span>(stack, num1/num2)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 返回栈底元素
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">return</span> stack[<span style="color:#3677a9">0</span>]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/evalRPN.png" alt="有效的括号检测 - 代码执行过程"></p>
<h3 id="3-简化路径">3. 简化路径</h3>
<p>给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 &lsquo;/&rsquo; 开头），请你将其转化为更加简洁的规范路径。</p>
<p>请注意，返回的 规范路径 必须遵循下述格式：</p>
<ul>
<li>始终以斜杠 &lsquo;/&rsquo; 开头。</li>
<li>两个目录名之间必须只有一个斜杠 &lsquo;/&rsquo; 。</li>
<li>最后一个目录名（如果存在）不能 以 &lsquo;/&rsquo; 结尾。</li>
<li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 &lsquo;.&rsquo; 或 &lsquo;..&rsquo;）。</li>
</ul>
<p>返回简化后得到的 规范路径 。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#999;font-style:italic"># 示例来源: https://leetcode.cn/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 1：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：path = <span style="color:#ed9d13">&#34;/home//foo/&#34;</span>
</span></span><span style="display:flex;"><span>输出：<span style="color:#ed9d13">&#34;/home/foo&#34;</span>
</span></span><span style="display:flex;"><span>解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 2：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：path = <span style="color:#ed9d13">&#34;/a/./b/../../c/&#34;</span>
</span></span><span style="display:flex;"><span>输出：<span style="color:#ed9d13">&#34;/c&#34;</span>
</span></span></code></pre></div><p>解题思路:</p>
<ol>
<li>声明并初始化一个栈结构，用于存储遍历过程中遇到的 目录名称/文件名称</li>
<li>将参数路径使用 <code>/</code> 分隔符分割为字符串数组</li>
<li>遍历字符串数组
<ol>
<li>如果当前字符串不是有效的路径字符，例如 <code>&quot;&quot;</code> <code>.</code>, 直接跳过</li>
<li>如果当前字符串是 目录名称/文件名称，将其入栈</li>
<li>如果当前字符串表示 上级目录 <code>..</code> ，将栈顶元素出栈</li>
</ol>
</li>
<li>遍历字符串数组结束，将栈内所有元素使用 <code>/</code> 分隔符分割为字符串路径，然后在路径最前面加 <code>/</code> 即可</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">simplifyPath</span>(path <span style="color:#6ab825;font-weight:bold">string</span>) <span style="color:#6ab825;font-weight:bold">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">var</span> stack []<span style="color:#6ab825;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">for</span> _, p := <span style="color:#6ab825;font-weight:bold">range</span> strings.<span style="color:#447fcf">Split</span>(path, <span style="color:#ed9d13">&#34;/&#34;</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 无效路径字符，直接跳过
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> p == <span style="color:#ed9d13">&#34;&#34;</span> || p == <span style="color:#ed9d13">&#34;.&#34;</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#6ab825;font-weight:bold">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 目录名称/文件名称 入栈
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">if</span> p != <span style="color:#ed9d13">&#34;..&#34;</span> {
</span></span><span style="display:flex;"><span>			stack = <span style="color:#24909d">append</span>(stack, p)
</span></span><span style="display:flex;"><span>		} <span style="color:#6ab825;font-weight:bold">else</span> <span style="color:#6ab825;font-weight:bold">if</span> p == <span style="color:#ed9d13">&#34;..&#34;</span> &amp;&amp; <span style="color:#24909d">len</span>(stack) &gt; <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 如果是上级目录 ..
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 将栈顶元素出栈
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			stack = stack[:<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#ed9d13">&#34;/&#34;</span> + strings.<span style="color:#447fcf">Join</span>(stack, <span style="color:#ed9d13">&#34;/&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/simplifyPath.png" alt="简化路径 - 代码执行过程"></p>
<hr>
<h2 id="-单调栈">📖 单调栈</h2>
<p>单调栈（Monotonic Stack）是一种特殊的栈 (Stack) 结构，其元素满足特定的单调性条件，主要应用于 <strong>区间元素大小和顺序相关问题</strong>。</p>
<p>单调栈主要分为两种类型:</p>
<ol>
<li><strong>递增单调栈</strong>: 栈内元素从栈底到栈顶依次递增 (例如 1, 2, 3 &hellip;)，当新元素入栈时，如果比栈顶元素大，直接入栈，否则循环弹出栈顶元素，直到满足单调递增的条件 (也即是找到比新元素小的栈顶元素，或者栈内元素为空)，循环停止，然后将新元素入栈</li>
</ol>
<p><img src="https://dbwu.tech/images/algorithm/monotonic_inc_stack.png" alt="递增单调栈 - 代码执行过程"></p>
<ol start="2">
<li><strong>递减单调栈</strong>: 栈内元素从栈底到栈顶依次递减 (例如 3, 2, 1 &hellip;)，当新元素入栈时，如果比栈顶元素小，直接入栈，否则循环弹出栈顶元素，直到满足单调递减的条件 (也即是找到比新元素大的栈顶元素，或者栈内元素为空)，循环停止，然后将新元素入栈</li>
</ol>
<p><img src="https://dbwu.tech/images/algorithm/monotonic_dec_stack.png" alt="递减单调栈 - 代码执行过程"></p>
<h3 id="leetcode-模板">LeetCode 模板</h3>
<p>LeetCode 中单调栈相关题型解题时，可以采用如下步骤:</p>
<ol>
<li>初始化一个栈数据结构，用于存储 <strong>元素的索引或值</strong></li>
<li>遍历数组 (大多数 LeetCode 题目的输入数据是一个数组)</li>
<li><strong>维护单调性</strong>：遍历过程中，将 <strong>元素的索引或值</strong> 按照单调性规则压入栈中，根据问题的具体逻辑，需要维护栈的单调递增性或单调递减性:
<ol>
<li>如果当前元素没有破坏栈的单调性，直接入栈即可</li>
<li>如果当前元素破坏了栈的单调性，弹出栈顶的元素，并 <strong>使用栈顶元素更新问题逻辑解或者做相应的处理</strong></li>
</ol>
</li>
<li>重复第 3 步，直到数组所有元素都已处理</li>
<li>根据题目要求确定是否处理栈中剩余元素</li>
</ol>
<p>下面是一个通用的单调栈解题模板代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">Solution</span>(nums []<span style="color:#6ab825;font-weight:bold">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 1. 初始化单调栈
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	stack := <span style="color:#24909d">make</span>([]<span style="color:#6ab825;font-weight:bold">int</span>, <span style="color:#3677a9">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 2. 遍历数组
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#6ab825;font-weight:bold">range</span> nums {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 这里的示例为 单调递增栈
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 维护栈的单调性
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">for</span> <span style="color:#24909d">len</span>(stack) &gt; <span style="color:#3677a9">0</span> &amp;&amp; nums[i] &lt; nums[stack[<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>]] {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 获取栈顶元素
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			index := stack[<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 栈顶元素出栈
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			stack = stack[:<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 使用栈顶元素更新问题逻辑解或者做相应的处理
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			...
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 维护单调递增栈，将元素的索引入栈
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		stack = <span style="color:#24909d">append</span>(stack, i)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 根据题目要求确定是否处理栈中剩余元素
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> <span style="color:#24909d">len</span>(stack) &gt; <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="-典型题目-1">💡 典型题目</h2>
<h3 id="1-商品折扣">1. 商品折扣</h3>
<p>给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。</p>
<p>商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j &gt; i 且 prices[j] &lt;= prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。</p>
<p>请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#999;font-style:italic"># 示例来源: https://leetcode.cn/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 1：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：prices = [8,4,6,2,3]
</span></span><span style="display:flex;"><span>输出：[4,2,4,2,3]
</span></span><span style="display:flex;"><span>解释：
</span></span><span style="display:flex;"><span>商品 <span style="color:#3677a9">0</span> 的价格为 price[0]=<span style="color:#3677a9">8</span> ，你将得到 prices[1]=<span style="color:#3677a9">4</span> 的折扣，所以最终价格为 <span style="color:#3677a9">8</span> - <span style="color:#40ffff">4</span> = <span style="color:#3677a9">4</span> 。
</span></span><span style="display:flex;"><span>商品 <span style="color:#3677a9">1</span> 的价格为 price[1]=<span style="color:#3677a9">4</span> ，你将得到 prices[3]=<span style="color:#3677a9">2</span> 的折扣，所以最终价格为 <span style="color:#3677a9">4</span> - <span style="color:#40ffff">2</span> = <span style="color:#3677a9">2</span> 。
</span></span><span style="display:flex;"><span>商品 <span style="color:#3677a9">2</span> 的价格为 price[2]=<span style="color:#3677a9">6</span> ，你将得到 prices[3]=<span style="color:#3677a9">2</span> 的折扣，所以最终价格为 <span style="color:#3677a9">6</span> - <span style="color:#40ffff">2</span> = <span style="color:#3677a9">4</span> 。
</span></span><span style="display:flex;"><span>商品 <span style="color:#3677a9">3</span> 和 <span style="color:#3677a9">4</span> 都没有折扣。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 2：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入：prices = [1,2,3,4,5]
</span></span><span style="display:flex;"><span>输出：[1,2,3,4,5]
</span></span><span style="display:flex;"><span>解释：在这个例子中，所有商品都没有折扣。
</span></span></code></pre></div><p>直接将单调栈解题模板代码稍微修改后即可，为了便于阅读，直接将解题和思路以注释的方式写入到代码中。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">finalPrices</span>(prices []<span style="color:#6ab825;font-weight:bold">int</span>) []<span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	n := <span style="color:#24909d">len</span>(prices)
</span></span><span style="display:flex;"><span>	res := <span style="color:#24909d">make</span>([]<span style="color:#6ab825;font-weight:bold">int</span>, n)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 1. 初始化单调栈
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 因为只需要计算折扣后的值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 所以栈内存储数组值就可以
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 栈顶始终保留一个值 0 作为 “哨兵”
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 避免边界检查，同时表示语义: “没有折扣”
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	stack := []<span style="color:#6ab825;font-weight:bold">int</span>{<span style="color:#3677a9">0</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 2. 遍历数组
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 题目声明，享受折扣时的索引必须比当前索引大
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 也就是说，数组中的最后一件商品价格无法享受任何优惠
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 所以数组从后向前遍历即可
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> i := n - <span style="color:#3677a9">1</span>; i &gt;= <span style="color:#3677a9">0</span>; i-- {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 当前栈内的商品价格依次递增，符合单调递增的特性
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 也就是说，如果一个商品价格出现在栈内
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 说明还未找到 该商品价格 对应的 折扣价格
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 3. 维护单调递增性
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 如果 栈顶商品价格 比 当前商品价格 大，说明当前单调递增性已经被破坏
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 那么此时就可以开始给当前商品 寻找对应的 折扣价格 了
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 弹出栈顶商品价格，直到遇到比 当前商品价格 小的 商品价格(折扣价格)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">for</span> <span style="color:#24909d">len</span>(stack) &gt; <span style="color:#3677a9">1</span> &amp;&amp; stack[<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>] &gt; prices[i] {
</span></span><span style="display:flex;"><span>			stack = stack[:<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 4. 处理具体逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 此时 栈顶商品价格 就是 当前商品价格 可以享受的折扣
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 更新即可
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		res[i] = prices[i] - stack[<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 将当前商品价格入栈
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		stack = <span style="color:#24909d">append</span>(stack, prices[i])
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> res
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/finalPrices.png" alt="商品折扣 - 代码执行过程"></p>
<h3 id="2-每日温度">2. 每日温度</h3>
<p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#999;font-style:italic"># 示例来源: https://leetcode.cn/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 1:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入: <span style="color:#40ffff">temperatures</span> = [73,74,75,71,69,72,76,73]
</span></span><span style="display:flex;"><span>输出: [1,1,4,2,1,1,0,0]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>示例 2:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>输入: <span style="color:#40ffff">temperatures</span> = [30,40,50,60]
</span></span><span style="display:flex;"><span>输出: [1,1,1,0]
</span></span></code></pre></div><p>直接将单调栈解题模板代码稍微修改后即可，为了便于阅读，直接将解题和思路以注释的方式写入到代码中。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">dailyTemperatures</span>(temperatures []<span style="color:#6ab825;font-weight:bold">int</span>) []<span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	res := <span style="color:#24909d">make</span>([]<span style="color:#6ab825;font-weight:bold">int</span>, <span style="color:#24909d">len</span>(temperatures))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 1. 初始化单调栈
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 因为题目要求寻找 “下一个” 更高的温度对应的索引 (间隔天数)
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 所以栈内存储数组索引
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">var</span> stack []<span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 2. 遍历数组
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#6ab825;font-weight:bold">range</span> temperatures {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 当前栈内索引对应的温度依次递减，符合单调递减的特性
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 也就是说，如果一个索引出现在栈内
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 说明还未找到该索引对应的温度 的  “下一个” 更高的温度
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 3. 维护单调递减性
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 如果当前元素温度 大于 栈顶元素温度
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 说明当前单调递减性已经被破坏
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 那么当前元素就是 “下一个” 更高的温度
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">for</span> <span style="color:#24909d">len</span>(stack) &gt; <span style="color:#3677a9">0</span> &amp;&amp; temperatures[i] &gt; temperatures[stack[<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>]] {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 4. 处理具体逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 获取栈顶元素索引
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			preIndex := stack[<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 栈顶元素出栈
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			stack = stack[:<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 更新栈顶元素索引对应的温度 的  “下一个” 更高的温度
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 因为题目要求寻找 “下一个”  更高的温度在几天后
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 所以这里使用当前索引 减去 栈顶索引
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 得出的差值就是中间的间隔天数
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			res[preIndex] = i - preIndex
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 将当前元素的索引入栈
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		stack = <span style="color:#24909d">append</span>(stack, i)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> res
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/dailyTemperatures.png" alt="每日温度 - 代码执行过程"></p>
<h3 id="3-接雨水">3. 接雨水</h3>
<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p>直接将单调栈解题模板代码稍微修改后即可，为了便于阅读，直接将解题和思路以注释的方式写入到代码中。</p>
<div class="highlight"><pre tabindex="0" style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#999;font-style:italic">// 题解代码
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">trap2</span>(height []<span style="color:#6ab825;font-weight:bold">int</span>) <span style="color:#6ab825;font-weight:bold">int</span> {
</span></span><span style="display:flex;"><span>	res := <span style="color:#3677a9">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 1. 初始化单调栈
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#999;font-style:italic">// 栈内存储数组索引
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">var</span> stack []<span style="color:#6ab825;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#999;font-style:italic">// 2. 遍历数组
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>	<span style="color:#6ab825;font-weight:bold">for</span> i := <span style="color:#6ab825;font-weight:bold">range</span> height {
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 当前栈内索引对应的柱子依次递减，然后寻找右侧 “更高的柱子” 用来蓄水
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 符合单调递减的特性
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 也就是说，如果一个索引出现在栈内
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 说明还未找到该索引对应的柱子 的右侧 “更高的柱子”
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>
</span></span><span style="display:flex;"><span>		<span style="color:#999;font-style:italic">// 3. 维护单调递减性
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 如果当前柱子高度 大于 栈顶元素高度
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 说明当前单调递减性已经被破坏
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#999;font-style:italic">// 那么当前元素就是 右侧 “更高的柱子”
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>		<span style="color:#6ab825;font-weight:bold">for</span> <span style="color:#24909d">len</span>(stack) &gt; <span style="color:#3677a9">0</span> &amp;&amp; height[i] &gt; height[stack[<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>]] {
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 4. 处理具体逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 获取栈顶元素索引
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			top := stack[<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 栈顶元素出栈
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			stack = stack[:<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#999;font-style:italic">// 如果栈内只有一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 那么此时 stack 的长度等于 0
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 也就说明此时才刚刚找到 “左边的柱子”
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 还没有找到 “右边的柱子”
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 比如这种情况 [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 当 i 为 1 时，左边的柱子 (栈顶元素) 是 0
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#999;font-style:italic">// 这时接不到任何雨水，所以无需计算
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>			<span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#24909d">len</span>(stack) &gt; <span style="color:#3677a9">0</span> {
</span></span><span style="display:flex;"><span>				left := stack[<span style="color:#24909d">len</span>(stack)-<span style="color:#3677a9">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#999;font-style:italic">// 左右两个柱子之间的距离
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>				w := i - left - <span style="color:#3677a9">1</span>
</span></span><span style="display:flex;"><span>				<span style="color:#999;font-style:italic">// 左右两个柱子之间的高度，以较低的为准，“木桶原理”
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>				h := <span style="color:#24909d">min</span>(height[i], height[left]) - height[top]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#999;font-style:italic">// 将左右两个柱子之间的面积 (也就是蓄水容量) 累积到总计值
</span></span></span><span style="display:flex;"><span><span style="color:#999;font-style:italic"></span>				res += w * h
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		stack = <span style="color:#24909d">append</span>(stack, i)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6ab825;font-weight:bold">return</span> res
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://dbwu.tech/images/algorithm/trap.png" alt="接雨水 - 代码执行过程"></p>


</article>

<article>
    <img src="https://dbwu.tech/images/wechat.png">
</article>

<article>
    <h3>转载申请</h3>

    <p>
        本作品采用 <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> 进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，商业转载请联系作者获得授权。
    </p>
</article>

<section class="post-nav">
    <ul>
        <li>
        
            <a href="https://dbwu.tech/posts/golang_performance_tips/"><i class="fa fa-chevron-circle-left"></i> Go 高性能 Tips</a>
        
        </li>
        <li>
        
            <a href="https://dbwu.tech/posts/k8s/best_practice/hpa/">Kubernetes 应用最佳实践 - 水平自动伸缩 <i class="fa fa-chevron-circle-right"></i> </a>
        
        </li>
    </ul>
</section>
  
    
    
  


<script src="https://giscus.app/client.js"
        data-repo="duanbiaowu/dbwu.tech"
        data-repo-id="R_kgDOIkkjjw"
        data-category="Announcements"
        data-category-id="DIC_kwDOIkkjj84CV78j"
        data-mapping="specific"
        data-term="LeetCode Stack 刷题模板"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous" async>
</script>




</main>
    <footer>
        <ul>
            <li>
                <h6><a href="mailto:codean.net@gmail.com">codean.net@gmail.com</a> | 
                    <img src="https://dbwu.tech/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" />
                    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61011302001681" target="_blank">陕公网安备 61011302001681 号</a> |
                    <a href="https://beian.miit.gov.cn" target="_blank">陕ICP备2023004378号-1</a> |
                    Rendered by <a href="https://themes.gohugo.io" title="Hugo" target="_blank">Hugo</a>
                </h6>
            </li>
            
            
        </ul>
    </footer>
</div>
<script src="https://dbwu.tech/js/scripts.js"></script>


</body>

</html>

